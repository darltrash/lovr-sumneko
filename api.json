{
  "callbacks": [
    {
      "description": "The `lovr.conf` callback lets you configure default settings for L\u00d6VR.  It is called once right before the game starts.\n\n:::note\nMake sure you put `lovr.conf` in a file called `conf.lua`, a special file that\u0027s loaded before the rest of the framework initializes.\n:::",
      "examples": [
        {
          "code": "function lovr.conf(t)\n\n  -- Set the project version and identity\n  t.version \u003d \u00270.18.0\u0027\n  t.identity \u003d \u0027default\u0027\n\n  -- Set save directory precedence\n  t.saveprecedence \u003d true\n\n  -- Enable or disable different modules\n  t.modules.audio \u003d true\n  t.modules.data \u003d true\n  t.modules.event \u003d true\n  t.modules.graphics \u003d true\n  t.modules.headset \u003d true\n  t.modules.math \u003d true\n  t.modules.physics \u003d true\n  t.modules.system \u003d true\n  t.modules.thread \u003d true\n  t.modules.timer \u003d true\n\n  -- Audio\n  t.audio.spatializer \u003d nil\n  t.audio.samplerate \u003d 48000\n  t.audio.start \u003d true\n\n  -- Graphics\n  t.graphics.debug \u003d false\n  t.graphics.vsync \u003d true\n  t.graphics.stencil \u003d false\n  t.graphics.antialias \u003d true\n  t.graphics.shadercache \u003d true\n\n  -- Headset settings\n  t.headset.drivers \u003d { \u0027openxr\u0027, \u0027simulator\u0027 }\n  t.headset.start \u003d true\n  t.headset.supersample \u003d false\n  t.headset.seated \u003d false\n  t.headset.mask \u003d true\n  t.headset.antialias \u003d true\n  t.headset.stencil \u003d false\n  t.headset.submitdepth \u003d true\n  t.headset.overlay \u003d false\n\n  -- Math settings\n  t.math.globals \u003d true\n\n  -- Thread settings\n  t.thread.workers \u003d -1\n\n  -- Configure the desktop window\n  t.window.width \u003d 1080\n  t.window.height \u003d 600\n  t.window.fullscreen \u003d false\n  t.window.resizable \u003d false\n  t.window.title \u003d \u0027L\u00d6VR\u0027\n  t.window.icon \u003d nil\nend",
          "description": "A noop conf.lua that sets all configuration settings to their defaults:"
        }
      ],
      "key": "lovr.conf",
      "module": "lovr",
      "name": "conf",
      "notes": "Disabling unused modules can improve startup time.\n\n`t.window` can be set to nil to avoid creating the window.  The window can later be opened manually using `lovr.system.openWindow`.\n\nEnabling the `t.graphics.debug` flag will add additional error checks and will send messages from the GPU driver to the `lovr.log` callback.  This will decrease performance but can help provide information on performance problems or other bugs.  It will also cause `lovr.graphics.newShader` to embed debugging information in shaders which allows inspecting variables and stepping through shaders line-by-line in tools like RenderDoc.\n\n`t.graphics.debug` can also be enabled using the `--graphics-debug` command line option.",
      "related": ["lovr.load"],
      "summary": "Called to read configuration settings at startup.",
      "tag": "callbacks",
      "variants": [
        {
          "arguments": [
            {
              "description": "The table to edit the configuration settings on.",
              "name": "t",
              "table": [
                {
                  "description": "The version of L\u00d6VR this project targets (not used yet).",
                  "name": "version",
                  "type": "string"
                },
                {
                  "description": "A unique label for this project.",
                  "name": "identity",
                  "type": "string"
                },
                {
                  "description": "Whether the files in the save directory should have precedence over files in the source archive.",
                  "name": "saveprecedence",
                  "type": "boolean"
                },
                {
                  "description": "The set of enabled modules to use.",
                  "name": "modules",
                  "table": [
                    {
                      "description": "Whether the audio module should be enabled.",
                      "name": "audio",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether the data module should be enabled.",
                      "name": "data",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether the event module should be enabled.",
                      "name": "event",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether the graphics module should be enabled.",
                      "name": "graphics",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether the headset module should be enabled.",
                      "name": "headset",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether the math module should be enabled.",
                      "name": "math",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether the physics module should be enabled.",
                      "name": "physics",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether the system module should be enabled.",
                      "name": "system",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether the thread module should be enabled.",
                      "name": "thread",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether the timer module should be enabled.",
                      "name": "timer",
                      "type": "boolean"
                    }
                  ],
                  "type": "table"
                },
                {
                  "description": "Configuration for the audio module.",
                  "name": "audio",
                  "table": [
                    {
                      "description": "An audio spatializer to use (`simple`, `oculus`, or `phonon`).  If `nil`, all of them are attempted.",
                      "name": "spatializer",
                      "type": "string"
                    },
                    {
                      "description": "The sample rate to use for audio playback.",
                      "name": "samplerate",
                      "type": "number"
                    },
                    {
                      "description": "Whether the playback device should be automatically started.",
                      "name": "start",
                      "type": "boolean"
                    }
                  ],
                  "type": "table"
                },
                {
                  "description": "Configuration for the graphics module.",
                  "name": "graphics",
                  "table": [
                    {
                      "description": "Whether debug messages from the GPU should get sent to lovr.log.",
                      "name": "debug",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether vsync is enabled (forced off when VR is active).",
                      "name": "vsync",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether the desktop window should have a stencil buffer.",
                      "name": "stencil",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether the desktop window rendering should be antialiased.",
                      "name": "antialias",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether the shader cache should be loaded and saved to disk.",
                      "name": "shadercache",
                      "type": "boolean"
                    }
                  ],
                  "type": "table"
                },
                {
                  "description": "Configuration for the headset.",
                  "name": "headset",
                  "table": [
                    {
                      "description": "An ordered list of preferred headset drivers.",
                      "name": "drivers",
                      "type": "table"
                    },
                    {
                      "description": "Whether a VR session should begin at startup.",
                      "name": "start",
                      "type": "boolean"
                    },
                    {
                      "description": "A scaling factor to apply to the headset texture.  Can be any positive floating point number, which gets multiplied by the default texture resolution.  A value greater than 1 improves visual quality but reduces performance.  Can also be a boolean, where \"true\" means \"2.0\".",
                      "name": "supersample",
                      "type": "number"
                    },
                    {
                      "description": "Whether \u003ca data-key\u003d\"lovr.headset.isSeated\"\u003eseated mode\u003c\/a\u003e should be used instead of standing, changing the headset coordinate space to place y\u003d0 at eye level.",
                      "name": "seated",
                      "type": "boolean"
                    },
                    {
                      "description": "Enable or disable the headset mask.  This is an optimization that skips rendering pixels on the edges of the headset texture that can\u0027t be seen while in the headset due to lens distortion.  When enabled, at the beginning of the frame, the edges of the headset texture will be filled in with black (and depth \u003d 1).",
                      "name": "mask",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether headset rendering should be antialiased.",
                      "name": "antialias",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether headset rendering should have a stencil buffer.",
                      "name": "stencil",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether the depth buffer should be sent to the VR runtime (improves reprojection).",
                      "name": "submitdepth",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether the project should run as an overlay.  Can also be a number to control sort order against other overlays (default is zero, higher numbers go on top).  Requires the `overlay` headset feature to be supported, see `lovr.headset.getFeatures`.",
                      "name": "overlay",
                      "type": "boolean"
                    }
                  ],
                  "type": "table"
                },
                {
                  "description": "Configuration for the math module.",
                  "name": "math",
                  "table": [
                    {
                      "description": "Whether vector object functions should be added to the global scope.",
                      "name": "globals",
                      "type": "boolean"
                    }
                  ],
                  "type": "table"
                },
                {
                  "description": "Configuration for the thread module.",
                  "name": "thread",
                  "table": [
                    {
                      "description": "The number of worker threads to spawn.  Can be negative, which will be added to the number of cores in the system.",
                      "name": "workers",
                      "type": "number"
                    }
                  ],
                  "type": "table"
                },
                {
                  "description": "Configuration for the window.",
                  "name": "window",
                  "table": [
                    {
                      "description": "The width of the window (or 0 to use the monitor width).",
                      "name": "width",
                      "type": "number"
                    },
                    {
                      "description": "The height of the window (or 0 to use the monitor height) .",
                      "name": "height",
                      "type": "number"
                    },
                    {
                      "description": "Whether the window is fullscreen.",
                      "name": "fullscreen",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether the window is resizable.",
                      "name": "resizable",
                      "type": "boolean"
                    },
                    {
                      "description": "The window title.",
                      "name": "title",
                      "type": "string"
                    },
                    {
                      "description": "The path to the window icon file.",
                      "name": "icon",
                      "type": "string"
                    }
                  ],
                  "type": "table"
                }
              ],
              "type": "table"
            }
          ],
          "returns": {}
        }
      ]
    },
    {
      "description": "This callback is called every frame, and receives a `Pass` object as an argument which can be used to render graphics to the display.  If a VR headset is connected, this function renders to the headset display, otherwise it will render to the desktop window.",
      "key": "lovr.draw",
      "module": "lovr",
      "name": "draw",
      "notes": "To render to the desktop window when a VR headset is connected, use the `lovr.mirror` callback.\n\nThe display is cleared to the global background color before this callback is called, which can be changed using `lovr.graphics.setBackgroundColor`.\n\nSince the `lovr.graphics.submit` function always returns true, the following idiom can be used to submit graphics work manually and override the default submission:\n\n    function lovr.draw(pass)\n      local passes \u003d {}\n\n      -- ... record multiple passes and add to passes table\n\n      return lovr.graphics.submit(passes)\n    end",
      "related": [
        "lovr.mirror",
        "lovr.headset.getPass",
        "lovr.graphics.getWindowPass",
        "lovr.graphics.setBackgroundColor"
      ],
      "summary": "Called continuously to render frames to the display.",
      "tag": "callbacks",
      "variants": [
        {
          "arguments": [
            {
              "description": "A render pass targeting the main display (headset or window).",
              "name": "pass",
              "type": "Pass"
            }
          ],
          "returns": [
            {
              "description": "If truthy, the input Pass will not be submitted to the GPU.",
              "name": "skip",
              "type": "boolean"
            }
          ]
        }
      ]
    },
    {
      "description": "The `lovr.errhand` callback is run whenever an error occurs.  It receives a parameter containing the error message.  It should return a handler function that will run in a loop to render the error screen.\n\nThis handler function is of the same type as the one returned by `lovr.run` and has the same requirements (such as pumping events).  If an error occurs while this handler is running, the program will terminate immediately -- `lovr.errhand` will not be given a second chance.  Errors which occur in the error handler or in the handler it returns may not be cleanly reported, so be careful.\n\nA default error handler is supplied that renders the error message as text to the headset and to the window.",
      "examples": [
        {
          "code": "function lovr.errhand(message)\n  local function formatTraceback(s)\n    return s:gsub(\u0027\\n[^\\n]+$\u0027, \u0027\u0027):gsub(\u0027\\t\u0027, \u0027\u0027):gsub(\u0027stack traceback:\u0027, \u0027\\nStack:\\n\u0027)\n  end\n\n  message \u003d \u0027Error:\\n\\n\u0027 .. tostring(message) .. formatTraceback(debug.traceback(\u0027\u0027, 4))\n\n  print(message)\n\n  if not lovr.graphics or not lovr.graphics.isInitialized() then\n    return function() return 1 end\n  end\n\n  if lovr.audio then lovr.audio.stop() end\n\n  if not lovr.headset or lovr.headset.getPassthrough() \u003d\u003d \u0027opaque\u0027 then\n    lovr.graphics.setBackgroundColor(.11, .10, .14)\n  else\n    lovr.graphics.setBackgroundColor(0, 0, 0, 0)\n  end\n\n  local font \u003d lovr.graphics.getDefaultFont()\n\n  return function()\n    lovr.system.pollEvents()\n\n    for name, a in lovr.event.poll() do\n      if name \u003d\u003d \u0027quit\u0027 then return a or 1\n      elseif name \u003d\u003d \u0027restart\u0027 then return \u0027restart\u0027, lovr.restart and lovr.restart()\n      elseif name \u003d\u003d \u0027keypressed\u0027 and a \u003d\u003d \u0027f5\u0027 then lovr.event.restart()\n      elseif name \u003d\u003d \u0027keypressed\u0027 and a \u003d\u003d \u0027escape\u0027 then lovr.event.quit() end\n    end\n\n    if lovr.headset and lovr.headset.getDriver() ~\u003d \u0027simulator\u0027 then\n      lovr.headset.update()\n      local pass \u003d lovr.headset.getPass()\n      if pass then\n        font:setPixelDensity()\n\n        local scale \u003d .35\n        local font \u003d lovr.graphics.getDefaultFont()\n        local wrap \u003d .7 * font:getPixelDensity()\n        local lines \u003d font:getLines(message, wrap)\n        local width \u003d math.min(font:getWidth(message), wrap) * scale\n        local height \u003d .8 + #lines * font:getHeight() * scale\n        local x \u003d -width \/ 2\n        local y \u003d math.min(height \/ 2, 10)\n        local z \u003d -10\n\n        pass:setColor(.95, .95, .95)\n        pass:text(message, x, y, z, scale, 0, 0, 0, 0, wrap, \u0027left\u0027, \u0027top\u0027)\n\n        lovr.graphics.submit(pass)\n        lovr.headset.submit()\n      end\n    end\n\n    if lovr.system.isWindowOpen() then\n      local pass \u003d lovr.graphics.getWindowPass()\n      if pass then\n        local w, h \u003d lovr.system.getWindowDimensions()\n        pass:setProjection(1, lovr.math.mat4():orthographic(0, w, 0, h, -1, 1))\n        font:setPixelDensity(1)\n\n        local scale \u003d .6\n        local wrap \u003d w * .8 \/ scale\n        local width \u003d math.min(font:getWidth(message), wrap) * scale\n        local x \u003d w \/ 2 - width \/ 2\n\n        pass:setColor(.95, .95, .95)\n        pass:text(message, x, h \/ 2, 0, scale, 0, 0, 0, 0, wrap, \u0027left\u0027, \u0027middle\u0027)\n\n        lovr.graphics.submit(pass)\n        lovr.graphics.present()\n      end\n    end\n\n    lovr.math.drain()\n  end\nend",
          "description": "The default error handler."
        }
      ],
      "key": "lovr.errhand",
      "module": "lovr",
      "name": "errhand",
      "related": ["lovr.quit"],
      "summary": "Called when an error occurs.",
      "tag": "callbacks",
      "variants": [
        {
          "arguments": [
            {
              "description": "The error message.",
              "name": "message",
              "type": "string"
            }
          ],
          "returns": [
            {
              "arguments": {},
              "description": "The error handler function.  It should return nil to continue running, \"restart\" to restart the app, or a number representing an exit status.",
              "name": "handler",
              "returns": [{ "name": "result", "type": "*" }],
              "type": "function"
            }
          ]
        }
      ]
    },
    {
      "description": "The `lovr.filechanged` callback is called when a file is changed.  File watching must be enabled, either by passing `--watch` when starting L\u00d6VR or by calling `lovr.filesystem.watch`.\n\nCurrently, only files in the source directory are watched.  On Android, files in the sdcard directory are watched.",
      "key": "lovr.filechanged",
      "module": "lovr",
      "name": "filechanged",
      "notes": "L\u00d6VR provides a default implementation for `lovr.filechanged` that restarts the project if a non-hidden file was changed:\n\n    function lovr.filechanged(path)\n      if not path:match(\u0027^%.\u0027) then\n        lovr.event.restart()\n      end\n    end",
      "related": ["lovr.filesystem.watch", "lovr.filesystem.unwatch"],
      "summary": "Called when a file is changed.",
      "tag": "callbacks",
      "variants": [
        {
          "arguments": [
            {
              "description": "The path to the file that changed.",
              "name": "path",
              "type": "string"
            },
            {
              "description": "What happened to the file.",
              "name": "action",
              "type": "FileAction"
            },
            {
              "description": "The old path, for `rename` actions.",
              "name": "oldpath",
              "type": "string"
            }
          ],
          "returns": {}
        }
      ]
    },
    {
      "description": "The `lovr.focus` callback is called whenever the application acquires or loses focus (for example, when opening or closing the system VR menu).  The callback receives a `focused` argument, indicating whether or not the application is now focused.  Additionally, both the headset and desktop window have separate focus states, so a `display` argument indicates which display gained or lost input focus.  It may make sense to pause the game, reduce visual fidelity, or mute audio when the application loses focus.",
      "key": "lovr.focus",
      "module": "lovr",
      "name": "focus",
      "related": ["lovr.headset.isFocused", "lovr.visible"],
      "summary": "Called when the application gains or loses input focus.",
      "tag": "callbacks",
      "variants": [
        {
          "arguments": [
            {
              "description": "Whether the program is now focused.",
              "name": "focused",
              "type": "boolean"
            },
            {
              "description": "Whether the headset or desktop window changed input focus.",
              "name": "display",
              "type": "DisplayType"
            }
          ],
          "returns": {}
        }
      ]
    },
    {
      "description": "This callback is called when a key is pressed.",
      "key": "lovr.keypressed",
      "module": "lovr",
      "name": "keypressed",
      "related": [
        "lovr.system.wasKeyPressed",
        "lovr.keyreleased",
        "lovr.textinput",
        "lovr.system.isKeyDown"
      ],
      "summary": "Called when a key is pressed.",
      "tag": "callbacks",
      "variants": [
        {
          "arguments": [
            {
              "description": "The key that was pressed.",
              "name": "key",
              "type": "KeyCode"
            },
            {
              "description": "The id of the key (ignores keyboard layout, may vary between keyboards).",
              "name": "scancode",
              "type": "number"
            },
            {
              "description": "Whether the event is the result of a key repeat instead of an actual press.",
              "name": "repeat",
              "type": "boolean"
            }
          ],
          "returns": {}
        }
      ]
    },
    {
      "description": "This callback is called when a key is released.",
      "key": "lovr.keyreleased",
      "module": "lovr",
      "name": "keyreleased",
      "related": [
        "lovr.system.wasKeyReleased",
        "lovr.keypressed",
        "lovr.textinput",
        "lovr.system.isKeyDown"
      ],
      "summary": "Called when a key is released.",
      "tag": "callbacks",
      "variants": [
        {
          "arguments": [
            {
              "description": "The key that was released.",
              "name": "key",
              "type": "KeyCode"
            },
            {
              "description": "The id of the key (ignores keyboard layout, may vary between keyboards).",
              "name": "scancode",
              "type": "number"
            }
          ],
          "returns": {}
        }
      ]
    },
    {
      "description": "This callback is called once when the app starts.  It should be used to perform initial setup work, like loading resources and initializing classes and variables.",
      "examples": [
        {
          "code": "function lovr.load(arg)\n  model \u003d lovr.graphics.newModel(\u0027sponza.gltf\u0027)\n  texture \u003d lovr.graphics.newTexture(\u0027cena.png\u0027)\n  effects \u003d lovr.graphics.newShader(\u0027vert.glsl\u0027, \u0027frag.glsl\u0027)\n  loadLevel(1)\nend"
        }
      ],
      "key": "lovr.load",
      "module": "lovr",
      "name": "load",
      "notes": "If the project was loaded from a restart using `lovr.event.restart`, the return value from the previously-run `lovr.restart` callback will be made available to this callback as the `restart` key in the `arg` table.\n\nThe `arg` table follows the [Lua standard](https:\/\/en.wikibooks.org\/wiki\/Lua_Programming\/command_line_parameter).  The arguments passed in from the shell are put into a global table named `arg` and passed to `lovr.load`, but with indices offset such that the \"script\" (the project path) is at index 0.  So all arguments (if any) intended for the project are at successive indices starting with 1, and the executable and its \"internal\" arguments are in normal order but stored in negative indices.",
      "related": ["lovr.quit"],
      "summary": "Called once at startup.",
      "tag": "callbacks",
      "variants": [
        {
          "arguments": [
            {
              "description": "The command line arguments provided to the program.",
              "name": "arg",
              "type": "table"
            }
          ],
          "returns": {}
        }
      ]
    },
    {
      "description": "This callback is called when a message is logged.  The default implementation of this callback prints the message to the console using `print`, but it\u0027s possible to override this callback to render messages in VR, write them to a file, filter messages, and more.\n\nThe message can have a \"tag\" that is a short string representing the sender, and a \"level\" indicating how severe the message is.\n\nThe `t.graphics.debug` flag in `lovr.conf` can be used to get log messages from the GPU driver, tagged as `GPU`.  The `t.headset.debug` will enable OpenXR messages from the VR runtime, tagged as `XR`.\n\nIt is also possible to emit custom log messages using `lovr.event.push`, or by calling the callback.",
      "key": "lovr.log",
      "module": "lovr",
      "name": "log",
      "related": ["Pass:text"],
      "summary": "Called when a message is logged.",
      "tag": "callbacks",
      "variants": [
        {
          "arguments": [
            {
              "description": "The log message.  It may end in a newline.",
              "name": "message",
              "type": "string"
            },
            {
              "description": "The log level (`debug`, `info`, `warn`, or `error`).",
              "name": "level",
              "type": "string"
            },
            { "description": "The log tag.", "name": "tag", "type": "string" }
          ],
          "returns": {}
        }
      ]
    },
    {
      "description": "This callback is called every frame after rendering to the headset and is usually used to render a mirror of the headset display onto the desktop window.  It can be overridden for custom mirroring behavior.  For example, a stereo view could be drawn instead of a single eye or a 2D HUD could be rendered.",
      "examples": [
        {
          "code": "function lovr.mirror(pass)\n  if lovr.headset then\n    local texture \u003d lovr.headset.getTexture()\n    if texture then\n      pass:fill(texture)\n    else\n      return true\n    end\n  else\n    return lovr.draw and lovr.draw(pass)\n  end\nend",
          "description": "The default `lovr.mirror` implementation draws the headset mirror texture to the window if the headset is active, or just calls `lovr.draw` if there isn\u0027t a headset."
        }
      ],
      "key": "lovr.mirror",
      "module": "lovr",
      "name": "mirror",
      "related": ["lovr.system.openWindow", "lovr.draw"],
      "summary": "Called to render content to the desktop window.",
      "tag": "callbacks",
      "variants": [
        {
          "arguments": [
            {
              "description": "A render pass targeting the window.",
              "name": "pass",
              "type": "Pass"
            }
          ],
          "returns": [
            {
              "description": "If truthy, the input Pass will not be submitted to the GPU.",
              "name": "skip",
              "type": "boolean"
            }
          ]
        }
      ]
    },
    {
      "description": "The `lovr.mount` callback is called when the headset is put on or taken off.",
      "key": "lovr.mount",
      "module": "lovr",
      "name": "mount",
      "related": ["lovr.headset.isMounted"],
      "summary": "Called when the headset is put on or taken off.",
      "tag": "callbacks",
      "variants": [
        {
          "arguments": [
            {
              "description": "Whether the headset is mounted.",
              "name": "mounted",
              "type": "boolean"
            }
          ],
          "returns": {}
        }
      ]
    },
    {
      "description": "This callback is called when the mouse is moved.",
      "key": "lovr.mousemoved",
      "module": "lovr",
      "name": "mousemoved",
      "related": [
        "lovr.mousepressed",
        "lovr.mousereleased",
        "lovr.wheelmoved",
        "lovr.system.getMouseX",
        "lovr.system.getMouseY",
        "lovr.system.getMousePosition"
      ],
      "summary": "Called when the mouse is moved.",
      "tag": "callbacks",
      "variants": [
        {
          "arguments": [
            {
              "description": "The new x position of the mouse.",
              "name": "x",
              "type": "number"
            },
            {
              "description": "The new y position of the mouse.",
              "name": "y",
              "type": "number"
            },
            {
              "description": "The movement on the x axis since the last mousemove event.",
              "name": "dx",
              "type": "number"
            },
            {
              "description": "The movement on the y axis since the last mousemove event.",
              "name": "dy",
              "type": "number"
            }
          ],
          "returns": {}
        }
      ]
    },
    {
      "description": "This callback is called when a mouse button is pressed.",
      "key": "lovr.mousepressed",
      "module": "lovr",
      "name": "mousepressed",
      "related": [
        "lovr.mousereleased",
        "lovr.mousemoved",
        "lovr.wheelmoved",
        "lovr.system.isMouseDown"
      ],
      "summary": "Called when a mouse button is pressed.",
      "tag": "callbacks",
      "variants": [
        {
          "arguments": [
            {
              "description": "The x position of the mouse when the button was pressed.",
              "name": "x",
              "type": "number"
            },
            {
              "description": "The y position of the mouse when the button was pressed.",
              "name": "y",
              "type": "number"
            },
            {
              "description": "The button that was pressed.  Will be 1 for the primary button, 2 for the secondary button, or 3 for the middle mouse button.",
              "name": "button",
              "type": "number"
            }
          ],
          "returns": {}
        }
      ]
    },
    {
      "description": "This callback is called when a mouse button is released.",
      "key": "lovr.mousereleased",
      "module": "lovr",
      "name": "mousereleased",
      "related": [
        "lovr.mousepressed",
        "lovr.mousemoved",
        "lovr.wheelmoved",
        "lovr.system.isMouseDown"
      ],
      "summary": "Called when a mouse button is released.",
      "tag": "callbacks",
      "variants": [
        {
          "arguments": [
            {
              "description": "The x position of the mouse when the button was released.",
              "name": "x",
              "type": "number"
            },
            {
              "description": "The y position of the mouse when the button was released.",
              "name": "y",
              "type": "number"
            },
            {
              "description": "The button that was released.  Will be 1 for the primary button, 2 for the secondary button, or 3 for the middle mouse button.",
              "name": "button",
              "type": "number"
            }
          ],
          "returns": {}
        }
      ]
    },
    {
      "description": "This callback contains a permission response previously requested with `lovr.system.requestPermission`.  The callback contains information on whether permission was granted or denied.",
      "key": "lovr.permission",
      "module": "lovr",
      "name": "permission",
      "related": ["lovr.system.requestPermission"],
      "summary": "Called when a permission request is answered.",
      "tag": "callbacks",
      "variants": [
        {
          "arguments": [
            {
              "description": "The type of permission.",
              "name": "permission",
              "type": "Permission"
            },
            {
              "description": "Whether permission was granted or denied.",
              "name": "granted",
              "type": "boolean"
            }
          ],
          "returns": {}
        }
      ]
    },
    {
      "description": "This callback is called right before the application is about to quit.  Use it to perform any necessary cleanup work.  A truthy value can be returned from this callback to abort quitting.",
      "examples": [
        {
          "code": "function lovr.quit()\n  if shouldQuit() then\n    return false\n  else\n    return true\n  end\nend"
        }
      ],
      "key": "lovr.quit",
      "module": "lovr",
      "name": "quit",
      "related": ["lovr.event.quit", "lovr.load"],
      "summary": "Called before quitting.",
      "tag": "callbacks",
      "variants": [
        {
          "arguments": {},
          "returns": [
            {
              "description": "Whether quitting should be aborted.",
              "name": "abort",
              "type": "boolean"
            }
          ]
        }
      ]
    },
    {
      "description": "The `lovr.recenter` callback is called whenever the user performs a \"recenter\" gesture to realign the virtual coordinate space.  On most VR systems this will move the origin to the user\u0027s current position and rotate its yaw to match the view direction.  The y\u003d0 position will always be on the floor or at eye level, depending on whether `t.headset.seated` was set in `lovr.conf`.",
      "key": "lovr.recenter",
      "module": "lovr",
      "name": "recenter",
      "notes": "Note that the pose of the `floor` device will not always be at the origin of the coordinate space.  It uses a fixed position on the floor in the real world, usually the center of the configured play area.  This allows virtual objects to be positioned in a room without having them jump around after a recenter.",
      "related": [
        "lovr.headset.getBoundsWidth",
        "lovr.headset.getBoundsDepth",
        "lovr.headset.getBoundsDimensions",
        "lovr.headset.getBoundsGeometry",
        "lovr.headset.isSeated"
      ],
      "summary": "Called when the user recenters the coordinate space.",
      "tag": "callbacks",
      "variants": [{ "arguments": {}, "returns": {} }]
    },
    {
      "description": "This callback is called when the desktop window is resized.",
      "key": "lovr.resize",
      "module": "lovr",
      "name": "resize",
      "related": [
        "Pass:getDimensions",
        "Pass:getWidth",
        "Pass:getHeight",
        "lovr.headset.getDisplayDimensions",
        "lovr.conf"
      ],
      "summary": "Called when the window is resized.",
      "tag": "callbacks",
      "variants": [
        {
          "arguments": [
            {
              "description": "The new width of the window.",
              "name": "width",
              "type": "number"
            },
            {
              "description": "The new height of the window.",
              "name": "height",
              "type": "number"
            }
          ],
          "returns": {}
        }
      ]
    },
    {
      "description": "This callback is called when a restart from `lovr.event.restart` is happening.  A value can be returned to send it to the next L\u00d6VR instance, available as the `restart` key in the argument table passed to `lovr.load`.  Object instances can not be used as the restart value, since they are destroyed as part of the cleanup process.",
      "examples": [
        {
          "code": "function lovr.restart()\n  return currentLevel:getName()\nend"
        }
      ],
      "key": "lovr.restart",
      "module": "lovr",
      "name": "restart",
      "notes": "Only nil, booleans, numbers, and strings are supported types for the return value.",
      "related": ["lovr.event.restart", "lovr.load", "lovr.quit"],
      "summary": "Called when restarting.",
      "tag": "callbacks",
      "variants": [
        {
          "arguments": {},
          "returns": [
            {
              "description": "The value to send to the next `lovr.load`.",
              "name": "cookie",
              "type": "*"
            }
          ]
        }
      ]
    },
    {
      "description": "This callback is the main entry point for a L\u00d6VR program.  It calls `lovr.load` and returns a function that will be called every frame.",
      "examples": [
        {
          "code": "function lovr.run()\n  if lovr.timer then lovr.timer.step() end\n  if lovr.load then lovr.load(arg) end\n  return function()\n    if lovr.system then lovr.system.pollEvents() end\n    if lovr.event then\n      for name, a, b, c, d in lovr.event.poll() do\n        if name \u003d\u003d \u0027restart\u0027 then return \u0027restart\u0027, lovr.restart and lovr.restart()\n        elseif name \u003d\u003d \u0027quit\u0027 and (not lovr.quit or not lovr.quit(a)) then return a or 0\n        elseif name ~\u003d \u0027quit\u0027 and lovr.handlers[name] then lovr.handlers[name](a, b, c, d) end\n      end\n    end\n    local dt \u003d 0\n    if lovr.timer then dt \u003d lovr.timer.step() end\n    if lovr.headset and lovr.headset.isActive() then dt \u003d lovr.headset.update() end\n    if lovr.update then lovr.update(dt) end\n    if lovr.graphics then\n      local headset \u003d lovr.headset and lovr.headset.getPass()\n      if headset and (not lovr.draw or lovr.draw(headset)) then headset \u003d nil end\n      local window \u003d lovr.graphics.getWindowPass()\n      if window and (not lovr.mirror or lovr.mirror(window)) then window \u003d nil end\n      lovr.graphics.submit(headset, window)\n      lovr.graphics.present()\n    end\n    if lovr.headset then lovr.headset.submit() end\n    if lovr.math then lovr.math.drain() end\n  end\nend",
          "description": "The default `lovr.run`:"
        }
      ],
      "key": "lovr.run",
      "module": "lovr",
      "name": "run",
      "notes": "The main loop function can return one of the following values:\n\n- Returning `nil` will keep the main loop running.\n- Returning the string \u0027restart\u0027 plus an optional value will restart L\u00d6VR.  The value can be\n  accessed in the `restart` key of the `arg` global.\n- Returning a number will exit L\u00d6VR using the number as the exit code (0 means success).\n\nCare should be taken when overriding this callback.  For example, if the main loop does not call `lovr.system.pollEvents` then the OS will think L\u00d6VR is unresponsive, or if the quit event is not handled then closing the window won\u0027t work.",
      "related": ["lovr.load", "lovr.quit"],
      "summary": "The main entry point.",
      "tag": "callbacks",
      "variants": [
        {
          "arguments": {},
          "returns": [
            {
              "arguments": {},
              "description": "The main loop function.",
              "name": "loop",
              "returns": [{ "name": "result", "type": "*" }],
              "type": "function"
            }
          ]
        }
      ]
    },
    {
      "description": "This callback is called when text has been entered.\n\nFor example, when `shift + 1` is pressed on an American keyboard, `lovr.textinput` will be called with `!`.",
      "key": "lovr.textinput",
      "module": "lovr",
      "name": "textinput",
      "notes": "Some characters in UTF-8 unicode take multiple bytes to encode.  Due to the way Lua works, the length of these strings will be bigger than 1 even though they are just a single character.  The `utf8` library included with L\u00d6VR can be used to manipulate UTF-8 strings.  `Pass:text` will also correctly handle UTF-8.",
      "related": ["lovr.keypressed", "lovr.keyreleased"],
      "summary": "Called when text has been entered.",
      "tag": "callbacks",
      "variants": [
        {
          "arguments": [
            {
              "description": "The UTF-8 encoded character.",
              "name": "text",
              "type": "string"
            },
            {
              "description": "The integer codepoint of the character.",
              "name": "code",
              "type": "number"
            }
          ],
          "returns": {}
        }
      ]
    },
    {
      "description": "The `lovr.threaderror` callback is called whenever an error occurs in a Thread.  It receives the Thread object where the error occurred and an error message.\n\nThe default implementation of this callback will call `lovr.errhand` with the error.",
      "key": "lovr.threaderror",
      "module": "lovr",
      "name": "threaderror",
      "related": ["Thread", "Thread:getError", "lovr.errhand"],
      "summary": "Called when an error occurs in a thread.",
      "tag": "callbacks",
      "variants": [
        {
          "arguments": [
            {
              "description": "The Thread that errored.",
              "name": "thread",
              "type": "Thread"
            },
            {
              "description": "The error message.",
              "name": "message",
              "type": "string"
            }
          ],
          "returns": {}
        }
      ]
    },
    {
      "description": "The `lovr.update` callback should be used to update your game\u0027s logic.  It receives a single parameter, `dt`, which represents the amount of elapsed time between frames.  You can use this value to scale timers, physics, and animations in your game so they play at a smooth, consistent speed.",
      "examples": [
        {
          "code": "function lovr.update(dt)\n  ball.vy \u003d ball.vy + ball.gravity * dt\n  ball.y \u003d ball.y + ball.vy * dt\nend"
        }
      ],
      "key": "lovr.update",
      "module": "lovr",
      "name": "update",
      "related": ["lovr.timer.getDelta"],
      "summary": "Called every frame to update the application logic.",
      "tag": "callbacks",
      "variants": [
        {
          "arguments": [
            {
              "description": "The number of seconds elapsed since the last update.",
              "name": "dt",
              "type": "number"
            }
          ],
          "returns": {}
        }
      ]
    },
    {
      "description": "The `lovr.visible` callback is called whenever the application becomes visible or invisible. `lovr.draw` may still be called even while invisible to give the VR runtime timing info.  If the VR runtime decides the application doesn\u0027t need to render anymore, L\u00d6VR will detect this and stop calling `lovr.draw`.\n\nThis event is also fired when the desktop window is minimized or restored.  It\u0027s possible to distinguish between the headset and window using the `display` parameter.",
      "key": "lovr.visible",
      "module": "lovr",
      "name": "visible",
      "related": ["lovr.headset.isVisible", "lovr.focus"],
      "summary": "Called when the application gains or loses visibility.",
      "tag": "callbacks",
      "variants": [
        {
          "arguments": [
            {
              "description": "Whether the application is visible.",
              "name": "visible",
              "type": "boolean"
            },
            {
              "description": "Whether the headset or desktop window changed visibility.",
              "name": "display",
              "type": "DisplayType"
            }
          ],
          "returns": {}
        }
      ]
    },
    {
      "description": "This callback is called on scroll action, from a mouse wheel or a touchpad",
      "key": "lovr.wheelmoved",
      "module": "lovr",
      "name": "wheelmoved",
      "related": [
        "lovr.mousepressed",
        "lovr.mousereleased",
        "lovr.mousemoved",
        "lovr.system.isMouseDown"
      ],
      "summary": "Called when a mouse wheel is moved.",
      "tag": "callbacks",
      "variants": [
        {
          "arguments": [
            {
              "description": "The relative horizontal motion; rightward movement resuts in positive values.",
              "name": "dx",
              "type": "number"
            },
            {
              "description": "The relative vertical motion; upward movement results in positive values.",
              "name": "dy",
              "type": "number"
            }
          ],
          "returns": {}
        }
      ]
    }
  ],
  "modules": [
    {
      "description": "ENet is a UDP networking plugin bundled with L\u00d6VR that can be used for networking and multiplayer experiences.  ENet allows messages to be marked for reliable and in-order delivery, allowing the speed of UDP to be used without sacrificing reliability.\n\nThe full documentation and examples can be found on the [lua-enet](http:\/\/leafo.net\/lua-enet\/) page.  L\u00d6VE also has lua-enet documentation [here](https:\/\/love2d.org\/wiki\/lua-enet).",
      "enums": {},
      "examples": [
        {
          "code": "-- client\/main.lua\nlocal enet \u003d require \u0027enet\u0027\n\nfunction lovr.load()\n  local host \u003d enet.host_create()\n  local server \u003d host:connect(\u0027localhost:6789\u0027)\n\n  local done \u003d false\n  while not done do\n    local event \u003d host:service(100)\n    if event then\n      if event.type \u003d\u003d \u0027connect\u0027 then\n        print(\u0027Connected to\u0027, event.peer)\n        event.peer:send(\u0027hello world\u0027)\n      elseif event.type \u003d\u003d \u0027receive\u0027 then\n        print(\u0027Got message: \u0027, event.data, event.peer)\n        done \u003d true\n      end\n    end\n  end\n\n  server:disconnect()\n  host:flush()\nend\n\n-- server\/main.lua\nlocal enet \u003d require \u0027enet\u0027\n\nfunction lovr.load()\n  local host \u003d enet.host_create(\u0027localhost:6789\u0027)\n  while true do\n    local event \u003d host:service(100)\n    if event and event.type \u003d\u003d \u0027receive\u0027 then\n      print(\u0027Got message: \u0027, event.data, event.peer)\n      event.peer:send(event.data)\n    end\n  end\nend",
          "description": "Here\u0027s a simple echo server example. The client sends a message to the server and waits for a response. The server waits for a message and sends it back to the client."
        }
      ],
      "external": true,
      "functions": {},
      "key": "enet",
      "name": "enet",
      "objects": {},
      "summary": "UDP networking library.",
      "tag": "libraries"
    },
    {
      "description": "The [lovr-http](https:\/\/github.com\/bjornbytes\/lovr-http) plugin performs HTTP requests.\n\nFirst, `require` the plugin and save it into a variable: `local http \u003d require \u0027http\u0027`.\n\nThe module has one function:\n\n    status, data, headers \u003d http.request(url, [options])\n\nThis will perform an HTTP request and block until the request is complete.\n\n### Arguments\n\n`url` is the URL to request.  If it doesn\u0027t have a protocol, then `http:\/\/` will be added.\n\n`options` is optional, and is used for advanced request settings.\n\n`options.method` is the HTTP method to use, also called the verb.  `GET` is used by default if there\u0027s no data in the request, otherwise it defauls to `POST`.  It will be converted to all-caps.\n\n`options.data` is the data to send to the server, also called the body.  It can be a few different types:\n\n- When `data` is nil, no request body will be sent (and `method` will default to `GET`).\n- When `data` is a string, the string will be used directly as the request body.\n- When `data` is a table, then pairs in the table will be URL encoded and concatenated together\n  to form an `application\/x-www-form-urlencoded` body.  For example, if data is\n  `{ n \u003d 10, k \u003d \u0027v!\u0027 }`, then the request body will be something like `k\u003dv%21\u0026n\u003d10`. Table\n  pairs will only be used if the key is a string and the value is a string or number.\n- When `data` is a lightuserdata, the data pointed to by the lightuserdata will be used as the\n  request body. Additionally, the `datasize` option should be an integer indicating how big the\n  request body is, in bytes.\n\nWhen `options.data` is set, the `Content-Type` request header will default to `application\/x-www-urlencoded` unless it\u0027s set to something else.\n\n`options.headers` is a table of request headers to send to the server.  Pairs in the table will only be used if the key is a string and the value is a string or number.\n\n### Returns\n\nIf an error occurs, the function returns `nil, errormessage`.\n\nOtherwise, 3 values are returned:\n\n- `status` is an integer with the HTTP status code (200 is OK, 404 is Not Found, etc.).\n- `data` is a string with the data sent by the server (HTML, JSON, binary, etc.).\n- `headers` is a table of response headers.",
      "enums": {},
      "examples": [
        {
          "code": "local http \u003d require \u0027http\u0027\n\nlocal status, data, headers \u003d http.request(\u0027https:\/\/zombo.com\u0027)\n\nprint(\u0027welcome\u0027)\nprint(status)\nprint(data)\nprint(\u0027headers:\u0027)\nfor k, v in pairs(headers) do\n  print(\u0027\\t\u0027 .. k, v)\nend"
        }
      ],
      "external": true,
      "functions": {},
      "key": "http",
      "name": "http",
      "notes": "On Linux, this module requires the `curl` library to be installed.  Example on Debian-based distributions:\n\n    sudo apt install libcurl4",
      "objects": {},
      "summary": "HTTP(S) requests.",
      "tag": "libraries"
    },
    {
      "description": "`lovr` is the single global table that is exposed to every L\u00d6VR app. It contains a set of **modules** and a set of **callbacks**.",
      "enums": {},
      "functions": [
        {
          "description": "Get the current major, minor, and patch version of L\u00d6VR.",
          "key": "lovr.getVersion",
          "module": "lovr",
          "name": "getVersion",
          "related": ["lovr"],
          "summary": "Get the current version.",
          "tag": "version",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The major version.",
                  "name": "major",
                  "type": "number"
                },
                {
                  "description": "The minor version.",
                  "name": "minor",
                  "type": "number"
                },
                {
                  "description": "The patch number.",
                  "name": "patch",
                  "type": "number"
                },
                {
                  "description": "The version codename.",
                  "name": "codename",
                  "type": "string"
                },
                {
                  "description": "The commit hash (not available in all builds).",
                  "name": "commit",
                  "type": "string"
                }
              ]
            }
          ]
        }
      ],
      "key": "lovr",
      "name": "lovr",
      "objects": [
        {
          "description": "The superclass of all L\u00d6VR objects.  All objects have these methods.",
          "key": "Object",
          "methods": [
            {
              "description": "Immediately destroys Lua\u0027s reference to the object it\u0027s called on.  After calling this function on an object, it is an error to do anything with the object from Lua (call methods on it, pass it to other functions, etc.).  If nothing else is using the object, it will be destroyed immediately, which can be used to destroy something earlier than it would normally be garbage collected in order to reduce memory.",
              "key": "Object:release",
              "module": "lovr",
              "name": "release",
              "notes": "The object may not be destroyed immediately if something else is referring to it (e.g. it is pushed to a Channel or exists in the payload of a pending event).",
              "related": ["Object"],
              "summary": "Immediately release the Lua reference to an object.",
              "variants": [{ "arguments": {}, "returns": {} }]
            },
            {
              "description": "Returns the name of the object\u0027s type as a string.",
              "examples": [
                {
                  "code": "function isTexture(obj)\n  return type(obj) \u003d\u003d \u0027userdata\u0027 and obj:type() \u003d\u003d \u0027Texture\u0027\nend"
                }
              ],
              "key": "Object:type",
              "module": "lovr",
              "name": "type",
              "related": ["Object"],
              "summary": "Get the type name of the object.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The type of the object.",
                      "name": "type",
                      "type": "string"
                    }
                  ]
                }
              ]
            }
          ],
          "module": "lovr",
          "name": "Object",
          "notes": "Note that the functions here don\u0027t apply to any vector objects, see `Vectors`.",
          "related": ["lovr"],
          "summary": "The base object."
        }
      ],
      "sections": [
        {
          "description": "Modules are the **what** of your app; you can use the functions in modules to tell L\u00d6VR to do things. For example, you can draw things on the screen, figure out what buttons on a controller are pressed, or load a 3D model from a file.  Each module does what it says on the tin, so the `lovr.graphics` module deals with rendering graphics and `lovr.headset` allows you to interact with VR hardware.",
          "name": "Modules",
          "tag": "modules"
        },
        {
          "description": "Callbacks are the **when** of the application; you write code inside callbacks which L\u00d6VR then calls at certain points in time.  For example, the `lovr.load` callback is called once at startup, and `lovr.focus` is called when the VR application gains or loses input focus.",
          "name": "Callbacks",
          "tag": "callbacks"
        },
        {
          "description": "This function can be used to get the current version of L\u00d6VR.",
          "name": "Version",
          "tag": "version"
        },
        {
          "description": "L\u00d6VR bundles a few third-party modules by default.",
          "name": "Libraries",
          "tag": "libraries"
        }
      ],
      "summary": "In the beginning, there was nothing."
    },
    {
      "description": "The `lovr.audio` module is responsible for playing sound effects and music.  To play a sound, create a `Source` object and call `Source:play` on it.  Currently ogg, wav, and mp3 audio formats are supported.",
      "enums": [
        {
          "description": "Different types of audio material presets, for use with `lovr.audio.setGeometry`.",
          "key": "AudioMaterial",
          "module": "lovr.audio",
          "name": "AudioMaterial",
          "related": ["lovr.audio"],
          "summary": "Different types of audio materials.",
          "values": [
            {
              "description": "Generic default audio material.",
              "name": "generic"
            },
            { "description": "Brick.", "name": "brick" },
            { "description": "Carpet.", "name": "carpet" },
            { "description": "Ceramic.", "name": "ceramic" },
            { "description": "Concrete.", "name": "concrete" },
            { "description": "Glass.", "name": "glass" },
            { "description": "Gravel.", "name": "gravel" },
            { "description": "Metal.", "name": "metal" },
            { "description": "Plaster.", "name": "plaster" },
            { "description": "Rock.", "name": "rock" },
            { "description": "Wood.", "name": "wood" }
          ]
        },
        {
          "description": "Audio devices can be created in shared mode or exclusive mode.  In exclusive mode, the audio device is the only one active on the system, which gives better performance and lower latency. However, exclusive devices aren\u0027t always supported and might not be allowed, so there is a higher chance that creating one will fail.",
          "key": "AudioShareMode",
          "module": "lovr.audio",
          "name": "AudioShareMode",
          "related": ["lovr.audio.setDevice", "lovr.audio"],
          "summary": "How audio devices are shared on the system.",
          "values": [
            { "description": "Shared mode.", "name": "shared" },
            { "description": "Exclusive mode.", "name": "exclusive" }
          ]
        },
        {
          "description": "When referencing audio devices, this indicates whether it\u0027s the playback or capture device.",
          "key": "AudioType",
          "module": "lovr.audio",
          "name": "AudioType",
          "related": [
            "lovr.audio.getDevices",
            "lovr.audio.setDevice",
            "lovr.audio.start",
            "lovr.audio.stop",
            "lovr.audio.isStarted",
            "lovr.audio"
          ],
          "summary": "Different types of audio devices",
          "values": [
            {
              "description": "The playback device (speakers, headphones).",
              "name": "playback"
            },
            {
              "description": "The capture device (microphone).",
              "name": "capture"
            }
          ]
        },
        {
          "description": "Different types of effects that can be applied with `Source:setEffectEnabled`.",
          "key": "Effect",
          "module": "lovr.audio",
          "name": "Effect",
          "notes": "The active spatializer will determine which effects are supported.  If an unsupported effect is enabled on a Source, no error will be reported.  Instead, it will be silently ignored.\n\nSee `lovr.audio.getSpatializer` for a table of the supported effects for each spatializer.",
          "related": ["lovr.audio"],
          "summary": "Different types of Source effects.",
          "values": [
            {
              "description": "Models absorption as sound travels through the air, water, etc.",
              "name": "absorption"
            },
            {
              "description": "Decreases audio volume with distance (1 \/ max(distance, 1)).",
              "name": "attenuation"
            },
            {
              "description": "Causes audio to drop off when the Source is occluded by geometry.",
              "name": "occlusion"
            },
            {
              "description": "Models reverb caused by audio bouncing off of geometry.",
              "name": "reverb"
            },
            {
              "description": "Spatializes the Source using either simple panning or an HRTF.",
              "name": "spatialization"
            },
            {
              "description": "Causes audio to be heard through walls when occluded, based on audio materials.",
              "name": "transmission"
            }
          ]
        },
        {
          "description": "When figuring out how long a Source is or seeking to a specific position in the sound file, units can be expressed in terms of seconds or in terms of frames.  A frame is one set of samples for each channel (one sample for mono, two samples for stereo).",
          "key": "TimeUnit",
          "module": "lovr.audio",
          "name": "TimeUnit",
          "related": ["lovr.audio"],
          "summary": "Time units for sound samples.",
          "values": [
            { "description": "Seconds.", "name": "seconds" },
            { "description": "Frames.", "name": "frames" }
          ]
        },
        {
          "description": "When accessing the volume of Sources or the audio listener, this can be done in linear units with a 0 to 1 range, or in decibels with a range of -\u221e to 0.",
          "key": "VolumeUnit",
          "module": "lovr.audio",
          "name": "VolumeUnit",
          "related": ["lovr.audio"],
          "summary": "Different units of volume.",
          "values": [
            { "description": "Linear volume range.", "name": "linear" },
            { "description": "Decibels.", "name": "db" }
          ]
        }
      ],
      "functions": [
        {
          "description": "Returns the global air absorption coefficients for the medium.  This affects Sources that have the `absorption` effect enabled, causing audio volume to drop off with distance as it is absorbed by the medium it\u0027s traveling through (air, water, etc.).  The difference between absorption and the attenuation effect is that absorption is more subtle and is frequency-dependent, so higher-frequency bands can get absorbed more quickly than lower ones. This can be used to apply \"underwater\" effects and stuff.",
          "key": "lovr.audio.getAbsorption",
          "module": "lovr.audio",
          "name": "getAbsorption",
          "notes": "Absorption is currently only supported by the phonon spatializer.\n\nThe frequency bands correspond to `400Hz`, `2.5KHz`, and `15KHz`.\n\nThe default coefficients are `.0002`, `.0017`, and `.0182` for low, mid, and high.",
          "related": ["lovr.audio.setAbsorption", "lovr.audio"],
          "summary": "Get the absorption coefficients.",
          "tag": "listener",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The absorption coefficient for the low frequency band.",
                  "name": "low",
                  "type": "number"
                },
                {
                  "description": "The absorption coefficient for the mid frequency band.",
                  "name": "mid",
                  "type": "number"
                },
                {
                  "description": "The absorption coefficient for the high frequency band.",
                  "name": "high",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns information about the active playback or capture device.",
          "key": "lovr.audio.getDevice",
          "module": "lovr.audio",
          "name": "getDevice",
          "notes": "If no device has been set yet, this function returns `nil`.\n\nThe device doesn\u0027t need to be started.",
          "related": [
            "lovr.audio.getDevices",
            "lovr.audio.setDevice",
            "lovr.audio.setDevice",
            "lovr.audio"
          ],
          "summary": "Get the current audio device.",
          "tag": "devices",
          "variants": [
            {
              "arguments": [
                {
                  "default": "\u0027playback\u0027",
                  "description": "The type of device to query.",
                  "name": "type",
                  "type": "AudioType"
                }
              ],
              "returns": [
                {
                  "description": "The name of the device.",
                  "name": "name",
                  "type": "string"
                },
                {
                  "description": "The opaque id of the device.",
                  "name": "id",
                  "type": "userdata"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns a list of playback or capture devices.  Each device has an `id`, `name`, and a `default` flag indicating whether it\u0027s the default device.\n\nTo use a specific device id for playback or capture, pass it to `lovr.audio.setDevice`.",
          "key": "lovr.audio.getDevices",
          "module": "lovr.audio",
          "name": "getDevices",
          "related": [
            "lovr.audio.setDevice",
            "lovr.audio.getDevice",
            "lovr.audio.start",
            "lovr.audio.stop",
            "lovr.audio"
          ],
          "summary": "Get a list of audio devices.",
          "tag": "devices",
          "variants": [
            {
              "arguments": [
                {
                  "default": "\u0027playback\u0027",
                  "description": "The type of devices to query (playback or capture).",
                  "name": "type",
                  "type": "AudioType"
                }
              ],
              "returns": [
                {
                  "description": "The list of devices.",
                  "name": "devices",
                  "table": [
                    {
                      "description": "A unique, opaque id for the device.",
                      "name": "[].id",
                      "type": "userdata"
                    },
                    {
                      "description": "A human readable name for the device.",
                      "name": "[].name",
                      "type": "string"
                    },
                    {
                      "description": "Whether the device is the default audio device.",
                      "name": "[].default",
                      "type": "boolean"
                    }
                  ],
                  "type": "table"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the orientation of the virtual audio listener in angle\/axis representation.",
          "key": "lovr.audio.getOrientation",
          "module": "lovr.audio",
          "name": "getOrientation",
          "related": [
            "lovr.audio.getPosition",
            "lovr.audio.getPose",
            "Source:getOrientation",
            "lovr.audio.setOrientation",
            "lovr.audio"
          ],
          "summary": "Get the orientation of the listener.",
          "tag": "listener",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The number of radians the listener is rotated around its axis of rotation.",
                  "name": "angle",
                  "type": "number"
                },
                {
                  "description": "The x component of the axis of rotation.",
                  "name": "ax",
                  "type": "number"
                },
                {
                  "description": "The y component of the axis of rotation.",
                  "name": "ay",
                  "type": "number"
                },
                {
                  "description": "The z component of the axis of rotation.",
                  "name": "az",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the position and orientation of the virtual audio listener.",
          "key": "lovr.audio.getPose",
          "module": "lovr.audio",
          "name": "getPose",
          "related": [
            "lovr.audio.getPosition",
            "lovr.audio.getOrientation",
            "Source:getPose",
            "lovr.audio.setPose",
            "lovr.audio"
          ],
          "summary": "Get the pose of the listener.",
          "tag": "listener",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The x position of the listener, in meters.",
                  "name": "x",
                  "type": "number"
                },
                {
                  "description": "The y position of the listener, in meters.",
                  "name": "y",
                  "type": "number"
                },
                {
                  "description": "The z position of the listener, in meters.",
                  "name": "z",
                  "type": "number"
                },
                {
                  "description": "The number of radians the listener is rotated around its axis of rotation.",
                  "name": "angle",
                  "type": "number"
                },
                {
                  "description": "The x component of the axis of rotation.",
                  "name": "ax",
                  "type": "number"
                },
                {
                  "description": "The y component of the axis of rotation.",
                  "name": "ay",
                  "type": "number"
                },
                {
                  "description": "The z component of the axis of rotation.",
                  "name": "az",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the position of the virtual audio listener, in meters.",
          "key": "lovr.audio.getPosition",
          "module": "lovr.audio",
          "name": "getPosition",
          "related": ["lovr.audio.setPosition", "lovr.audio"],
          "summary": "Get the position of the listener.",
          "tag": "listener",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The x position of the listener.",
                  "name": "x",
                  "type": "number"
                },
                {
                  "description": "The y position of the listener.",
                  "name": "y",
                  "type": "number"
                },
                {
                  "description": "The z position of the listener.",
                  "name": "z",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the sample rate used by the playback device.  This can be changed using `lovr.conf`.",
          "key": "lovr.audio.getSampleRate",
          "module": "lovr.audio",
          "name": "getSampleRate",
          "related": ["lovr.conf", "lovr.audio"],
          "summary": "Get the playback device sample rate.",
          "tag": "devices",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The sample rate of the playback device, in Hz.",
                  "name": "rate",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the name of the active spatializer (`simple`, `oculus`, or `phonon`).\n\nThe `t.audio.spatializer` setting in `lovr.conf` can be used to express a preference for a particular spatializer.  If it\u0027s `nil`, all spatializers will be tried in the following order: `phonon`, `oculus`, `simple`.",
          "key": "lovr.audio.getSpatializer",
          "module": "lovr.audio",
          "name": "getSpatializer",
          "notes": "Using a feature or effect that is not supported by the current spatializer will not error, it just won\u0027t do anything.\n\n\u003ctable\u003e\n  \u003cthead\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eFeature\u003c\/td\u003e\n      \u003ctd\u003esimple\u003c\/td\u003e\n      \u003ctd\u003ephonon\u003c\/td\u003e\n      \u003ctd\u003eoculus\u003c\/td\u003e\n    \u003c\/tr\u003e\n  \u003c\/thead\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eEffect: Spatialization\u003c\/td\u003e\n      \u003ctd\u003ex\u003c\/td\u003e\n      \u003ctd\u003ex\u003c\/td\u003e\n      \u003ctd\u003ex\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eEffect: Attenuation\u003c\/td\u003e\n      \u003ctd\u003ex\u003c\/td\u003e\n      \u003ctd\u003ex\u003c\/td\u003e\n      \u003ctd\u003ex\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eEffect: Absorption\u003c\/td\u003e\n      \u003ctd\u003e\u003c\/td\u003e\n      \u003ctd\u003ex\u003c\/td\u003e\n      \u003ctd\u003e\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eEffect: Occlusion\u003c\/td\u003e\n      \u003ctd\u003e\u003c\/td\u003e\n      \u003ctd\u003ex\u003c\/td\u003e\n      \u003ctd\u003e\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eEffect: Transmission\u003c\/td\u003e\n      \u003ctd\u003e\u003c\/td\u003e\n      \u003ctd\u003ex\u003c\/td\u003e\n      \u003ctd\u003e\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eEffect: Reverb\u003c\/td\u003e\n      \u003ctd\u003e\u003c\/td\u003e\n      \u003ctd\u003ex\u003c\/td\u003e\n      \u003ctd\u003e\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003elovr.audio.setGeometry\u003c\/td\u003e\n      \u003ctd\u003e\u003c\/td\u003e\n      \u003ctd\u003ex\u003c\/td\u003e\n      \u003ctd\u003e\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eSource:setDirectivity\u003c\/td\u003e\n      \u003ctd\u003ex\u003c\/td\u003e\n      \u003ctd\u003ex\u003c\/td\u003e\n      \u003ctd\u003e\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eSource:setRadius\u003c\/td\u003e\n      \u003ctd\u003e\u003c\/td\u003e\n      \u003ctd\u003ex\u003c\/td\u003e\n      \u003ctd\u003e\u003c\/td\u003e\n    \u003c\/tr\u003e\n  \u003c\/tbody\u003e \u003c\/table\u003e",
          "related": ["lovr.conf", "lovr.audio"],
          "summary": "Get the name of the active spatializer",
          "tag": "listener",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The name of the active spatializer.",
                  "name": "spatializer",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the master volume.  All audio sent to the playback device has its volume multiplied by this factor.",
          "key": "lovr.audio.getVolume",
          "module": "lovr.audio",
          "name": "getVolume",
          "notes": "The default volume is 1.0 (0 dB).",
          "related": ["lovr.audio.setVolume", "lovr.audio"],
          "summary": "Get the master volume.",
          "tag": "listener",
          "variants": [
            {
              "arguments": [
                {
                  "default": "\u0027linear\u0027",
                  "description": "The units to return (linear or db).",
                  "name": "units",
                  "type": "VolumeUnit"
                }
              ],
              "returns": [
                {
                  "description": "The master volume.",
                  "name": "volume",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns whether an audio device is started.",
          "key": "lovr.audio.isStarted",
          "module": "lovr.audio",
          "name": "isStarted",
          "related": ["lovr.audio.start", "lovr.audio.stop", "lovr.audio"],
          "summary": "Check if an audio device is started.",
          "tag": "devices",
          "variants": [
            {
              "arguments": [
                {
                  "default": "\u0027playback\u0027",
                  "description": "The type of device to check.",
                  "name": "type",
                  "type": "AudioType"
                }
              ],
              "returns": [
                {
                  "description": "Whether the device is active.",
                  "name": "started",
                  "type": "boolean"
                }
              ]
            }
          ]
        },
        {
          "description": "Creates a new Source from an ogg, wav, or mp3 file.",
          "examples": [
            {
              "code": "function lovr.load()\n  sandstorm \u003d lovr.audio.newSource(\u0027darude.ogg\u0027, {\n    decode \u003d false,\n    effects \u003d { \u0027spatialization\u0027, attenuation \u003d false, reverb \u003d true }\n  })\n\n  sandstorm:play()\nend"
            }
          ],
          "key": "lovr.audio.newSource",
          "module": "lovr.audio",
          "name": "newSource",
          "related": ["Source:clone", "lovr.audio"],
          "summary": "Create a new Source.",
          "tag": "sources",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The filename of the sound to load.",
                  "name": "filename",
                  "type": "string"
                },
                {
                  "description": "Optional options.",
                  "name": "options",
                  "table": [
                    {
                      "default": "false",
                      "description": "Whether to immediately decode compressed sounds, instead of progressively decoding as the Source plays.  Enabling this will use more memory but reduce CPU overhead during playback.  Recommended for short sound effects.",
                      "name": "decode",
                      "type": "boolean"
                    },
                    {
                      "default": "true",
                      "description": "Whether the pitch of the Source can be changed with `Source:setPitch`.  Setting this to false will improve performance slightly.",
                      "name": "pitchable",
                      "type": "boolean"
                    },
                    {
                      "default": "true",
                      "description": "Whether the Source should use spatial effects.  Non-spatial sources will get routed directly to the speakers without further processing.  Enabling an effect on a non-spatial source will raise an error.",
                      "name": "spatial",
                      "type": "boolean"
                    },
                    {
                      "default": "nil",
                      "description": "A table of `Effect`s to enable on the Source.  This can be a list (numeric keys, effect name values) or a map (effect name keys, boolean values) or a mix of the two.  Effects can also be enabled later using `Source:setEffectEnabled`.  If nil, all effects will be enabled.  Ignored if the `spatial` flag is false.",
                      "name": "effects",
                      "type": "table"
                    }
                  ],
                  "type": "table"
                }
              ],
              "returns": [
                {
                  "description": "The new Source.",
                  "name": "source",
                  "type": "Source"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The Blob containing the Source data.",
                  "name": "blob",
                  "type": "Blob"
                },
                {
                  "description": "Optional options.",
                  "name": "options",
                  "table": [
                    {
                      "default": "false",
                      "description": "Whether to immediately decode compressed sounds, instead of progressively decoding as the Source plays.  Enabling this will use more memory but reduce CPU overhead during playback.  Recommended for short sound effects.",
                      "name": "decode",
                      "type": "boolean"
                    },
                    {
                      "default": "true",
                      "description": "Whether the pitch of the Source can be changed with `Source:setPitch`.  Setting this to false will improve performance slightly.",
                      "name": "pitchable",
                      "type": "boolean"
                    },
                    {
                      "default": "true",
                      "description": "Whether the Source should use spatial effects.  Non-spatial sources will get routed directly to the speakers without further processing.  Enabling an effect on a non-spatial source will raise an error.",
                      "name": "spatial",
                      "type": "boolean"
                    },
                    {
                      "default": "nil",
                      "description": "A table of `Effect`s to enable on the Source.  This can be a list (numeric keys, effect name values) or a map (effect name keys, boolean values) or a mix of the two.  Effects can also be enabled later using `Source:setEffectEnabled`.  If nil, all effects will be enabled.  Ignored if the `spatial` flag is false.",
                      "name": "effects",
                      "type": "table"
                    }
                  ],
                  "type": "table"
                }
              ],
              "returns": [
                {
                  "description": "The new Source.",
                  "name": "source",
                  "type": "Source"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The Sound containing raw audio samples to play.",
                  "name": "sound",
                  "type": "Sound"
                },
                {
                  "description": "Optional options.",
                  "name": "options",
                  "table": [
                    {
                      "default": "false",
                      "description": "Whether to immediately decode compressed sounds, instead of progressively decoding as the Source plays.  Enabling this will use more memory but reduce CPU overhead during playback.  Recommended for short sound effects.",
                      "name": "decode",
                      "type": "boolean"
                    },
                    {
                      "default": "true",
                      "description": "Whether the pitch of the Source can be changed with `Source:setPitch`.  Setting this to false will improve performance slightly.",
                      "name": "pitchable",
                      "type": "boolean"
                    },
                    {
                      "default": "true",
                      "description": "Whether the Source should use spatial effects.  Non-spatial sources will get routed directly to the speakers without further processing.  Enabling an effect on a non-spatial source will raise an error.",
                      "name": "spatial",
                      "type": "boolean"
                    },
                    {
                      "default": "nil",
                      "description": "A table of `Effect`s to enable on the Source.  This can be a list (numeric keys, effect name values) or a map (effect name keys, boolean values) or a mix of the two.  Effects can also be enabled later using `Source:setEffectEnabled`.  If nil, all effects will be enabled.  Ignored if the `spatial` flag is false.",
                      "name": "effects",
                      "type": "table"
                    }
                  ],
                  "type": "table"
                }
              ],
              "returns": [
                {
                  "description": "The new Source.",
                  "name": "source",
                  "type": "Source"
                }
              ]
            }
          ]
        },
        {
          "description": "Sets the global air absorption coefficients for the medium.  This affects Sources that have the `absorption` effect enabled, causing audio volume to drop off with distance as it is absorbed by the medium it\u0027s traveling through (air, water, etc.).  The difference between absorption and the attenuation effect is that absorption is more subtle and is frequency-dependent, so higher-frequency bands can get absorbed more quickly than lower ones.  This can be used to apply \"underwater\" effects and stuff.",
          "key": "lovr.audio.setAbsorption",
          "module": "lovr.audio",
          "name": "setAbsorption",
          "notes": "Absorption is currently only supported by the phonon spatializer.\n\nThe frequency bands correspond to `400Hz`, `2.5KHz`, and `15KHz`.\n\nThe default coefficients are `.0002`, `.0017`, and `.0182` for low, mid, and high.",
          "related": ["lovr.audio.getAbsorption", "lovr.audio"],
          "summary": "Set the absorption coefficients.",
          "tag": "listener",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The absorption coefficient for the low frequency band.",
                  "name": "low",
                  "type": "number"
                },
                {
                  "description": "The absorption coefficient for the mid frequency band.",
                  "name": "mid",
                  "type": "number"
                },
                {
                  "description": "The absorption coefficient for the high frequency band.",
                  "name": "high",
                  "type": "number"
                }
              ],
              "returns": {}
            }
          ]
        },
        {
          "description": "Switches either the playback or capture device to a new one.\n\nIf a device for the given type is already active, it will be stopped and destroyed.  The new device will not be started automatically, use `lovr.audio.start` to start it.\n\nA device id (previously retrieved using `lovr.audio.getDevices`) can be given to use a specific audio device, or `nil` can be used for the id to use the default audio device.\n\nA sink can be also be provided when changing the device.  A sink is an audio stream (`Sound` object with a `stream` type) that will receive all audio samples played (for playback) or all audio samples captured (for capture).  When an audio device with a sink is started, be sure to periodically call `Sound:read` on the sink to read audio samples from it, otherwise it will overflow and discard old data.  The sink can have any format, data will be converted as needed. Using a sink for the playback device will reduce performance, but this isn\u0027t the case for capture devices.\n\nAudio devices can be started in `shared` or `exclusive` mode.  Exclusive devices may have lower latency than shared devices, but there\u0027s a higher chance that requesting exclusive access to an audio device will fail (either because it isn\u0027t supported or allowed).  One strategy is to first try the device in exclusive mode, switching to shared if it doesn\u0027t work.",
          "key": "lovr.audio.setDevice",
          "module": "lovr.audio",
          "name": "setDevice",
          "related": [
            "lovr.audio.getDevice",
            "lovr.audio.getDevices",
            "lovr.audio.start",
            "lovr.audio.stop",
            "lovr.audio.getDevice",
            "lovr.audio"
          ],
          "summary": "Switch audio devices.",
          "tag": "devices",
          "variants": [
            {
              "arguments": [
                {
                  "default": "\u0027playback\u0027",
                  "description": "The device to switch.",
                  "name": "type",
                  "type": "AudioType"
                },
                {
                  "default": "nil",
                  "description": "The id of the device to use, or `nil` to use the default device.",
                  "name": "id",
                  "type": "userdata"
                },
                {
                  "default": "nil",
                  "description": "An optional audio stream to use as a sink for the device.",
                  "name": "sink",
                  "type": "Sound"
                },
                {
                  "default": "shared",
                  "description": "The sharing mode for the device.",
                  "name": "mode",
                  "type": "AudioShareMode"
                }
              ],
              "returns": [
                {
                  "description": "Whether creating the audio device succeeded.",
                  "name": "success",
                  "type": "boolean"
                }
              ]
            }
          ]
        },
        {
          "description": "Sets a mesh of triangles to use for modeling audio effects, using a table of vertices or a Model.  When the appropriate effects are enabled, audio from `Source` objects will correctly be occluded by walls and bounce around to create realistic reverb.\n\nAn optional `AudioMaterial` may be provided to specify the acoustic properties of the geometry.",
          "key": "lovr.audio.setGeometry",
          "module": "lovr.audio",
          "name": "setGeometry",
          "notes": "This is currently only supported\/used by the `phonon` spatializer.\n\nThe `Effect`s that use geometry are:\n\n- `occlusion`\n- `reverb`\n- `transmission`\n\nIf an existing geometry has been set, this function will replace it.\n\nThe triangles must use counterclockwise winding.",
          "related": [
            "lovr.audio.getSpatializer",
            "Source:setEffectEnabled",
            "lovr.audio"
          ],
          "summary": "Set the geometry for audio effects.",
          "tag": "listener",
          "variants": [
            {
              "arguments": [
                {
                  "description": "A flat table of vertices.  Each vertex is 3 numbers representing its x, y, and z position. The units used for audio coordinates are up to you, but meters are recommended.",
                  "name": "vertices",
                  "type": "table"
                },
                {
                  "description": "A list of indices, indicating how the vertices are connected into triangles.  Indices are 1-indexed and are 32 bits (they can be bigger than 65535).",
                  "name": "indices",
                  "type": "table"
                },
                {
                  "default": "\u0027generic\u0027",
                  "description": "The acoustic material to use.",
                  "name": "material",
                  "type": "AudioMaterial"
                }
              ],
              "returns": [
                {
                  "description": "Whether audio geometry is supported by the current spatializer and the geometry was loaded successfully.",
                  "name": "success",
                  "type": "boolean"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "A model to use for the audio geometry.",
                  "name": "model",
                  "type": "Model"
                },
                {
                  "default": "\u0027generic\u0027",
                  "description": "The acoustic material to use.",
                  "name": "material",
                  "type": "AudioMaterial"
                }
              ],
              "returns": [
                {
                  "description": "Whether audio geometry is supported by the current spatializer and the geometry was loaded successfully.",
                  "name": "success",
                  "type": "boolean"
                }
              ]
            }
          ]
        },
        {
          "description": "Sets the orientation of the virtual audio listener in angle\/axis representation.",
          "key": "lovr.audio.setOrientation",
          "module": "lovr.audio",
          "name": "setOrientation",
          "related": [
            "lovr.audio.setPosition",
            "lovr.audio.setPose",
            "Source:setOrientation",
            "lovr.audio.getOrientation",
            "lovr.audio"
          ],
          "summary": "Set the orientation of the listener.",
          "tag": "listener",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The number of radians the listener should be rotated around its rotation axis.",
                  "name": "angle",
                  "type": "number"
                },
                {
                  "description": "The x component of the axis of rotation.",
                  "name": "ax",
                  "type": "number"
                },
                {
                  "description": "The y component of the axis of rotation.",
                  "name": "ay",
                  "type": "number"
                },
                {
                  "description": "The z component of the axis of rotation.",
                  "name": "az",
                  "type": "number"
                }
              ],
              "description": "Set the listener orientation using numbers.",
              "returns": {}
            },
            {
              "arguments": [
                {
                  "description": "The orientation of the listener.",
                  "name": "orientation",
                  "type": "Quat"
                }
              ],
              "description": "Set the listener orientation using a vector.",
              "returns": {}
            }
          ]
        },
        {
          "description": "Sets the position and orientation of the virtual audio listener.",
          "key": "lovr.audio.setPose",
          "module": "lovr.audio",
          "name": "setPose",
          "notes": "The position of the listener doesn\u0027t use any specific units, but usually they can be thought of as meters to match the headset module.",
          "related": [
            "lovr.audio.setPosition",
            "lovr.audio.setOrientation",
            "Source:setPose",
            "lovr.audio.getPose",
            "lovr.audio"
          ],
          "summary": "Set the pose of the listener.",
          "tag": "listener",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The x position of the listener.",
                  "name": "x",
                  "type": "number"
                },
                {
                  "description": "The y position of the listener.",
                  "name": "y",
                  "type": "number"
                },
                {
                  "description": "The z position of the listener.",
                  "name": "z",
                  "type": "number"
                },
                {
                  "description": "The number of radians the listener is rotated around its axis of rotation.",
                  "name": "angle",
                  "type": "number"
                },
                {
                  "description": "The x component of the axis of rotation.",
                  "name": "ax",
                  "type": "number"
                },
                {
                  "description": "The y component of the axis of rotation.",
                  "name": "ay",
                  "type": "number"
                },
                {
                  "description": "The z component of the axis of rotation.",
                  "name": "az",
                  "type": "number"
                }
              ],
              "description": "Set the pose of the listener using numbers.",
              "returns": {}
            },
            {
              "arguments": [
                {
                  "description": "The position of the listener.",
                  "name": "position",
                  "type": "Vec3"
                },
                {
                  "description": "The orientation of the listener.",
                  "name": "orientation",
                  "type": "Quat"
                }
              ],
              "description": "Set the pose of the listener using vector types.",
              "returns": {}
            }
          ]
        },
        {
          "description": "Sets the position of the virtual audio listener.  The position doesn\u0027t have any specific units, but usually they can be thought of as meters, to match the headset module.",
          "key": "lovr.audio.setPosition",
          "module": "lovr.audio",
          "name": "setPosition",
          "related": [
            "lovr.audio.setOrientation",
            "lovr.audio.setPose",
            "Source:setPosition",
            "lovr.audio.getPosition",
            "lovr.audio"
          ],
          "summary": "Set the position of the listener.",
          "tag": "listener",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The x position of the listener.",
                  "name": "x",
                  "type": "number"
                },
                {
                  "description": "The y position of the listener.",
                  "name": "y",
                  "type": "number"
                },
                {
                  "description": "The z position of the listener.",
                  "name": "z",
                  "type": "number"
                }
              ],
              "description": "Set the listener position using numbers.",
              "returns": {}
            },
            {
              "arguments": [
                {
                  "description": "The listener position.",
                  "name": "position",
                  "type": "Vec3"
                }
              ],
              "description": "Set the listener position using a vector.",
              "returns": {}
            }
          ]
        },
        {
          "description": "Sets the master volume.  All audio sent to the playback device has its volume multiplied by this factor.",
          "key": "lovr.audio.setVolume",
          "module": "lovr.audio",
          "name": "setVolume",
          "notes": "The volume will be clamped to a 0-1 range (0 dB).",
          "related": ["lovr.audio.getVolume", "lovr.audio"],
          "summary": "Set the master volume.",
          "tag": "listener",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The master volume.",
                  "name": "volume",
                  "type": "number"
                },
                {
                  "default": "\u0027linear\u0027",
                  "description": "The units of the value.",
                  "name": "units",
                  "type": "VolumeUnit"
                }
              ],
              "returns": {}
            }
          ]
        },
        {
          "description": "Starts the active playback or capture device.  By default the playback device is initialized and started, but this can be controlled using the `t.audio.start` flag in `lovr.conf`.",
          "key": "lovr.audio.start",
          "module": "lovr.audio",
          "name": "start",
          "notes": "Starting an audio device may fail if:\n\n- The device is already started\n- No device was initialized with `lovr.audio.setDevice`\n- Lack of `audiocapture` permission on Android (see `lovr.system.requestPermission`)\n- Some other problem accessing the audio device",
          "related": [
            "lovr.audio.getDevices",
            "lovr.audio.setDevice",
            "lovr.audio.stop",
            "lovr.audio.isStarted",
            "lovr.system.requestPermission",
            "lovr.permission",
            "lovr.audio"
          ],
          "summary": "Start an audio device.",
          "tag": "devices",
          "variants": [
            {
              "arguments": [
                {
                  "default": "\u0027playback\u0027",
                  "description": "The type of device to start.",
                  "name": "type",
                  "type": "AudioType"
                }
              ],
              "returns": [
                {
                  "description": "Whether the device was successfully started.",
                  "name": "started",
                  "type": "boolean"
                }
              ]
            }
          ]
        },
        {
          "description": "Stops the active playback or capture device.  This may fail if:\n\n- The device is not started\n- No device was initialized with `lovr.audio.setDevice`",
          "key": "lovr.audio.stop",
          "module": "lovr.audio",
          "name": "stop",
          "notes": "Switching devices with `lovr.audio.setDevice` will stop the existing one.",
          "related": [
            "lovr.audio.getDevices",
            "lovr.audio.setDevice",
            "lovr.audio.start",
            "lovr.audio.isStarted",
            "lovr.audio"
          ],
          "summary": "Stop an audio device.",
          "tag": "devices",
          "variants": [
            {
              "arguments": [
                {
                  "default": "\u0027playback\u0027",
                  "description": "The type of device to stop.",
                  "name": "type",
                  "type": "AudioType"
                }
              ],
              "returns": [
                {
                  "description": "Whether the device was successfully stopped.",
                  "name": "stopped",
                  "type": "boolean"
                }
              ]
            }
          ]
        }
      ],
      "key": "lovr.audio",
      "name": "audio",
      "objects": [
        {
          "constructors": ["lovr.audio.newSource", "Source:clone"],
          "description": "A Source is an object representing a single sound.  Currently ogg, wav, and mp3 formats are supported.\n\nWhen a Source is playing, it will send audio to the speakers.  Sources do not play automatically when they are created.  Instead, the `play`, `pause`, and `stop` functions can be used to control when they should play.\n\n`Source:seek` and `Source:tell` can be used to control the playback position of the Source.  A Source can be set to loop when it reaches the end using `Source:setLooping`.",
          "key": "Source",
          "methods": [
            {
              "description": "Creates a copy of the Source, referencing the same `Sound` object and inheriting all of the settings of this Source.  However, it will be created in the stopped state and will be rewound to the beginning.",
              "key": "Source:clone",
              "module": "lovr.audio",
              "name": "clone",
              "notes": "This is a good way to create multiple Sources that play the same sound, since the audio data won\u0027t be loaded multiple times and can just be reused.  You can also create multiple `Source` objects and pass in the same `Sound` object for each one, which will have the same effect.",
              "related": ["lovr.audio.newSource", "Source"],
              "summary": "Create an identical copy of the Source.",
              "tag": "sourceUtility",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "A genetically identical copy of the Source.",
                      "name": "source",
                      "type": "Source"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the directivity settings for the Source.\n\nThe directivity is controlled by two parameters: the weight and the power.\n\nThe weight is a number between 0 and 1 controlling the general \"shape\" of the sound emitted. 0.0 results in a completely omnidirectional sound that can be heard from all directions.  1.0 results in a full dipole shape that can be heard only from the front and back.  0.5 results in a cardioid shape that can only be heard from one direction.  Numbers in between will smoothly transition between these.\n\nThe power is a number that controls how \"focused\" or sharp the shape is.  Lower power values can be heard from a wider set of angles.  It is an exponent, so it can get arbitrarily large.  Note that a power of zero will still result in an omnidirectional source, regardless of the weight.",
              "key": "Source:getDirectivity",
              "module": "lovr.audio",
              "name": "getDirectivity",
              "related": ["Source:setDirectivity", "Source"],
              "summary": "Get the directivity of the Source.",
              "tag": "sourceEffects",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The dipole weight.  0.0 is omnidirectional, 1.0 is a dipole, 0.5 is cardioid.",
                      "name": "weight",
                      "type": "number"
                    },
                    {
                      "description": "The dipole power, controlling how focused the directivity shape is.",
                      "name": "power",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the duration of the Source.",
              "key": "Source:getDuration",
              "module": "lovr.audio",
              "name": "getDuration",
              "related": ["Sound:getDuration", "Source"],
              "summary": "Get the duration of the Source.",
              "tag": "sourcePlayback",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "\u0027seconds\u0027",
                      "description": "The unit to return.",
                      "name": "unit",
                      "type": "TimeUnit"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The duration of the Source.",
                      "name": "duration",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the orientation of the Source, in angle\/axis representation.",
              "key": "Source:getOrientation",
              "module": "lovr.audio",
              "name": "getOrientation",
              "related": [
                "Source:getPosition",
                "Source:getPose",
                "lovr.audio.getOrientation",
                "Source:setOrientation",
                "Source"
              ],
              "summary": "Get the orientation of the Source.",
              "tag": "sourceEffects",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The number of radians the Source is rotated around its axis of rotation.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the pitch of the Source.",
              "key": "Source:getPitch",
              "module": "lovr.audio",
              "name": "getPitch",
              "notes": "The default pitch is 1.  Every doubling\/halving of the pitch will raise\/lower the pitch by one octave.  Changing the pitch also changes the playback speed.",
              "related": ["Source:setPitch", "Source"],
              "summary": "Get the pitch of the Source.",
              "tag": "sourcePlayback",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The pitch.",
                      "name": "pitch",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the position and orientation of the Source.",
              "key": "Source:getPose",
              "module": "lovr.audio",
              "name": "getPose",
              "related": [
                "Source:getPosition",
                "Source:getOrientation",
                "lovr.audio.getPose",
                "Source:setPose",
                "Source"
              ],
              "summary": "Get the pose of the Source.",
              "tag": "sourceEffects",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The x position of the Source, in meters.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y position of the Source, in meters.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z position of the Source, in meters.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The number of radians the Source is rotated around its axis of rotation.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the position of the Source, in meters.  Setting the position will cause the Source to be distorted and attenuated based on its position relative to the listener.",
              "key": "Source:getPosition",
              "module": "lovr.audio",
              "name": "getPosition",
              "related": [
                "Source:getOrientation",
                "Source:getPose",
                "lovr.audio.getPosition",
                "Source:setPosition",
                "Source"
              ],
              "summary": "Get the position of the Source.",
              "tag": "sourceEffects",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The x coordinate.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z coordinate.",
                      "name": "z",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the radius of the Source, in meters.\n\nThis does not control falloff or attenuation.  It is only used for smoothing out occlusion.  If a Source doesn\u0027t have a radius, then when it becomes occluded by a wall its volume will instantly drop.  Giving the Source a radius that approximates its emitter\u0027s size will result in a smooth transition between audible and occluded, improving realism.",
              "key": "Source:getRadius",
              "module": "lovr.audio",
              "name": "getRadius",
              "related": ["Source:setRadius", "Source"],
              "summary": "Get the radius of the Source.",
              "tag": "sourceEffects",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The radius of the Source, in meters.",
                      "name": "radius",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the `Sound` object backing the Source.  Multiple Sources can share one Sound, allowing its data to only be loaded once.  An easy way to do this sharing is by using `Source:clone`.",
              "key": "Source:getSound",
              "module": "lovr.audio",
              "name": "getSound",
              "related": ["Source:clone", "lovr.audio.newSource", "Source"],
              "summary": "Get the Sound object backing the Source.",
              "tag": "sourceUtility",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The Sound object.",
                      "name": "sound",
                      "type": "Sound"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the current volume factor for the Source.",
              "key": "Source:getVolume",
              "module": "lovr.audio",
              "name": "getVolume",
              "related": ["Source:setVolume", "Source"],
              "summary": "Get the volume of the Source.",
              "tag": "sourcePlayback",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "\u0027linear\u0027",
                      "description": "The units to return (linear or db).",
                      "name": "units",
                      "type": "VolumeUnit"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The volume of the Source.",
                      "name": "volume",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns whether a given `Effect` is enabled for the Source.",
              "key": "Source:isEffectEnabled",
              "module": "lovr.audio",
              "name": "isEffectEnabled",
              "notes": "The active spatializer will determine which effects are supported.  If an unsupported effect is enabled on a Source, no error will be reported.  Instead, it will be silently ignored.  See `lovr.audio.getSpatializer` for a table showing the effects supported by each spatializer.\n\nCalling this function on a non-spatial Source will always return false.",
              "related": [
                "Source:isSpatial",
                "Source:setEffectEnabled",
                "Source"
              ],
              "summary": "Check if an effect is enabled.",
              "tag": "sourceEffects",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The effect.",
                      "name": "effect",
                      "type": "Effect"
                    }
                  ],
                  "returns": [
                    {
                      "description": "Whether the effect is enabled.",
                      "name": "enabled",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns whether or not the Source will loop when it finishes.",
              "key": "Source:isLooping",
              "module": "lovr.audio",
              "name": "isLooping",
              "related": ["Source:setLooping", "Source"],
              "summary": "Check if the Source is looping.",
              "tag": "sourcePlayback",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "Whether or not the Source is looping.",
                      "name": "looping",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns whether or not the Source is playing.",
              "key": "Source:isPlaying",
              "module": "lovr.audio",
              "name": "isPlaying",
              "related": [
                "Source:play",
                "Source:pause",
                "Source:stop",
                "Source"
              ],
              "summary": "Check if the Source is playing.",
              "tag": "sourcePlayback",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "Whether the Source is playing.",
                      "name": "playing",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns whether the Source was created with the `spatial` flag.  Non-spatial sources are routed directly to the speakers and can not use effects.",
              "key": "Source:isSpatial",
              "module": "lovr.audio",
              "name": "isSpatial",
              "related": [
                "Source:isEffectEnabled",
                "Source:setEffectEnabled",
                "Source"
              ],
              "summary": "Check if the Source is spatial.",
              "tag": "sourceEffects",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "Whether the source is spatial.",
                      "name": "spatial",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Pauses the source.  It can be resumed with `Source:resume` or `Source:play`. If a paused source is rewound, it will remain paused.",
              "key": "Source:pause",
              "module": "lovr.audio",
              "name": "pause",
              "related": ["Source"],
              "summary": "Pause the Source.",
              "tag": "sourcePlayback",
              "variants": [{ "arguments": {}, "returns": {} }]
            },
            {
              "description": "Plays the Source.  This doesn\u0027t do anything if the Source is already playing.",
              "key": "Source:play",
              "module": "lovr.audio",
              "name": "play",
              "notes": "There is a maximum of 64 Sources that can be playing at once.  If 64 Sources are already playing, this function will return `false`.",
              "related": ["Source"],
              "summary": "Play the Source.",
              "tag": "sourcePlayback",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "Whether the Source successfully started playing.",
                      "name": "success",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Seeks the Source to the specified position.",
              "key": "Source:seek",
              "module": "lovr.audio",
              "name": "seek",
              "notes": "Seeking a Source backed by a stream `Sound` has no meaningful effect.",
              "related": ["Source"],
              "summary": "Set the playback position of the Source.",
              "tag": "sourcePlayback",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The position to seek to.",
                      "name": "position",
                      "type": "number"
                    },
                    {
                      "default": "\u0027seconds\u0027",
                      "description": "The units for the seek position.",
                      "name": "unit",
                      "type": "TimeUnit"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the directivity settings for the Source.\n\nThe directivity is controlled by two parameters: the weight and the power.\n\nThe weight is a number between 0 and 1 controlling the general \"shape\" of the sound emitted. 0.0 results in a completely omnidirectional sound that can be heard from all directions.  1.0 results in a full dipole shape that can be heard only from the front and back.  0.5 results in a cardioid shape that can only be heard from one direction.  Numbers in between will smoothly transition between these.\n\nThe power is a number that controls how \"focused\" or sharp the shape is.  Lower power values can be heard from a wider set of angles.  It is an exponent, so it can get arbitrarily large.  Note that a power of zero will still result in an omnidirectional source, regardless of the weight.",
              "key": "Source:setDirectivity",
              "module": "lovr.audio",
              "name": "setDirectivity",
              "related": ["Source:getDirectivity", "Source"],
              "summary": "Set the directivity of the Source.",
              "tag": "sourceEffects",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The dipole weight.  0.0 is omnidirectional, 1.0 is a dipole, 0.5 is cardioid.",
                      "name": "weight",
                      "type": "number"
                    },
                    {
                      "description": "The dipole power, controlling how focused the directivity shape is.",
                      "name": "power",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Enables or disables an effect on the Source.",
              "key": "Source:setEffectEnabled",
              "module": "lovr.audio",
              "name": "setEffectEnabled",
              "notes": "The active spatializer will determine which effects are supported.  If an unsupported effect is enabled on a Source, no error will be reported.  Instead, it will be silently ignored.  See `lovr.audio.getSpatializer` for a table showing the effects supported by each spatializer.\n\nCalling this function on a non-spatial Source will throw an error.",
              "related": [
                "Source:isSpatial",
                "Source:isEffectEnabled",
                "Source"
              ],
              "summary": "Enable or disable an effect.",
              "tag": "sourceEffects",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The effect.",
                      "name": "effect",
                      "type": "Effect"
                    },
                    {
                      "description": "Whether the effect should be enabled.",
                      "name": "enable",
                      "type": "boolean"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets whether or not the Source loops.",
              "key": "Source:setLooping",
              "module": "lovr.audio",
              "name": "setLooping",
              "notes": "Attempting to loop a Source backed by a stream `Sound` will cause an error.",
              "related": ["Source:isLooping", "Source"],
              "summary": "Set whether or not the Source loops.",
              "tag": "sourcePlayback",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "Whether or not the Source will loop.",
                      "name": "loop",
                      "type": "boolean"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the orientation of the Source in angle\/axis representation.",
              "key": "Source:setOrientation",
              "module": "lovr.audio",
              "name": "setOrientation",
              "related": [
                "Source:setPosition",
                "Source:setPose",
                "lovr.audio.setOrientation",
                "Source:getOrientation",
                "Source"
              ],
              "summary": "Set the orientation of the Source.",
              "tag": "sourceEffects",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The number of radians the Source should be rotated around its rotation axis.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    }
                  ],
                  "description": "Set the orientation using angle\/axis numbers.",
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The orientation.",
                      "name": "orientation",
                      "type": "Quat"
                    }
                  ],
                  "description": "Set the orientation using a quaternion.",
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the pitch of the Source.",
              "key": "Source:setPitch",
              "module": "lovr.audio",
              "name": "setPitch",
              "notes": "The default pitch is 1.  Every doubling\/halving of the pitch will raise\/lower the pitch by one octave.  Changing the pitch also changes the playback speed.",
              "related": ["Source:getPitch", "Source"],
              "summary": "Set the pitch of the Source.",
              "tag": "sourcePlayback",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The new pitch.",
                      "name": "pitch",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the position and orientation of the Source.",
              "key": "Source:setPose",
              "module": "lovr.audio",
              "name": "setPose",
              "notes": "The position doesn\u0027t have any defined units, but meters are used by convention.",
              "related": [
                "Source:setPosition",
                "Source:setOrientation",
                "lovr.audio.setPose",
                "Source:getPose",
                "Source"
              ],
              "summary": "Set the pose of the Source.",
              "tag": "sourceEffects",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The x position of the Source.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y position of the Source.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z position of the Source.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The number of radians the Source is rotated around its axis of rotation.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    }
                  ],
                  "description": "Set the pose using numbers.",
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The position.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "description": "The orientation.",
                      "name": "orientation",
                      "type": "Quat"
                    }
                  ],
                  "description": "Set the pose using vector types.",
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the position of the Source.  Setting the position will cause the Source to be distorted and attenuated based on its position relative to the listener.\n\nOnly mono sources can be positioned.  Setting the position of a stereo Source will cause an error.",
              "key": "Source:setPosition",
              "module": "lovr.audio",
              "name": "setPosition",
              "notes": "The position doesn\u0027t have any defined units, but meters are used by convention.",
              "related": [
                "Source:setOrientation",
                "Source:setPose",
                "Source:getPosition",
                "Source"
              ],
              "summary": "Set the position of the Source.",
              "tag": "sourceEffects",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The x coordinate of the position.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate of the position.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z coordinate of the position.",
                      "name": "z",
                      "type": "number"
                    }
                  ],
                  "description": "Set the position using numbers.",
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The position.",
                      "name": "position",
                      "type": "Vec3"
                    }
                  ],
                  "description": "Set the position using a vector.",
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the radius of the Source, in meters.\n\nThis does not control falloff or attenuation.  It is only used for smoothing out occlusion.  If a Source doesn\u0027t have a radius, then when it becomes occluded by a wall its volume will instantly drop.  Giving the Source a radius that approximates its emitter\u0027s size will result in a smooth transition between audible and occluded, improving realism.",
              "key": "Source:setRadius",
              "module": "lovr.audio",
              "name": "setRadius",
              "related": ["Source:getRadius", "Source"],
              "summary": "Set the radius of the Source.",
              "tag": "sourceEffects",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The new radius of the Source, in meters.",
                      "name": "radius",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the current volume factor for the Source.",
              "key": "Source:setVolume",
              "module": "lovr.audio",
              "name": "setVolume",
              "notes": "The volume will be clamped to a 0-1 range (0 dB).",
              "related": ["Source:getVolume", "Source"],
              "summary": "Set the volume of the Source.",
              "tag": "sourcePlayback",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The new volume.",
                      "name": "volume",
                      "type": "number"
                    },
                    {
                      "default": "\u0027linear\u0027",
                      "description": "The units of the value.",
                      "name": "units",
                      "type": "VolumeUnit"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Stops the source, also rewinding it to the beginning.",
              "key": "Source:stop",
              "module": "lovr.audio",
              "name": "stop",
              "related": [
                "Source:play",
                "Source:pause",
                "Source:isPlaying",
                "Source"
              ],
              "summary": "Stop the Source.",
              "tag": "sourcePlayback",
              "variants": [{ "arguments": {}, "returns": {} }]
            },
            {
              "description": "Returns the current playback position of the Source.",
              "key": "Source:tell",
              "module": "lovr.audio",
              "name": "tell",
              "notes": "The return value for Sources backed by a stream `Sound` has no meaning.",
              "related": ["Source"],
              "summary": "Get the playback position of the Source.",
              "tag": "sourcePlayback",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "\u0027seconds\u0027",
                      "description": "The unit to return.",
                      "name": "unit",
                      "type": "TimeUnit"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The current playback position.",
                      "name": "position",
                      "type": "number"
                    }
                  ]
                }
              ]
            }
          ],
          "module": "lovr.audio",
          "name": "Source",
          "related": ["lovr.audio"],
          "sections": [
            { "name": "Playback", "tag": "sourcePlayback" },
            { "name": "Effects", "tag": "sourceEffects" },
            { "name": "Utility", "tag": "sourceUtility" }
          ],
          "summary": "A playable sound object."
        }
      ],
      "sections": [
        {
          "description": "Sources are objects that represent a single sound instance.",
          "name": "Sources",
          "tag": "sources"
        },
        {
          "description": "The listener is a virtual object in 3D space that \"hears\" all the sounds that are playing. It can be positioned and oriented in 3D space, which controls how Sources in the world are heard.  Usually this would be locked to the headset pose.",
          "name": "Listener",
          "tag": "listener"
        },
        {
          "description": "It\u0027s possible to list the available audio devices on the system, and pick a specific device to use for either playback or capture.  Devices can also be manually started and stopped. Other useful features of `lovr.audio.setDevice` include the ability to stream all audio data to a custom sink and the option to create a device in exclusive mode for higher performance. By default, the default playback device is automatically initialized and started, but this can be configured using `lovr.conf`.",
          "name": "Devices",
          "tag": "devices"
        }
      ],
      "summary": "Plays sound.",
      "tag": "modules"
    },
    {
      "description": "The `lovr.data` module provides functions for accessing underlying data representations for several L\u00d6VR objects.",
      "enums": [
        {
          "description": "This indicates the different node properties that can be animated.",
          "key": "AnimationProperty",
          "module": "lovr.data",
          "name": "AnimationProperty",
          "related": ["lovr.data"],
          "summary": "Different animated properties.",
          "values": [
            { "description": "Node translation.", "name": "translation" },
            { "description": "Node rotation.", "name": "rotation" },
            { "description": "Node scale.", "name": "scale" },
            { "description": "Node blend shape weights.", "name": "weights" }
          ]
        },
        {
          "description": "These are the data types that can be used by vertex data in meshes.",
          "key": "AttributeType",
          "module": "lovr.data",
          "name": "AttributeType",
          "related": ["lovr.data"],
          "summary": "Data types for vertex attributes in meshes.",
          "values": [
            {
              "description": "Signed 8 bit integers (-128 to 127).",
              "name": "i8"
            },
            {
              "description": "Unsigned 8 bit integers (0 to 255).",
              "name": "u8"
            },
            {
              "description": "Signed 16 bit integers (-32768 to 32767).",
              "name": "i16"
            },
            {
              "description": "Unsigned 16 bit integers (0 to 65535).",
              "name": "u16"
            },
            {
              "description": "Signed 32 bit integers (-2147483648 to 2147483647).",
              "name": "i32"
            },
            {
              "description": "Unsigned 32 bit integers (0 to 429467295).",
              "name": "u32"
            },
            { "description": "Floating point numbers.", "name": "f32" }
          ]
        },
        {
          "description": "Sounds can have different numbers of channels, and those channels can map to various speaker layouts.",
          "key": "ChannelLayout",
          "module": "lovr.data",
          "name": "ChannelLayout",
          "related": ["lovr.data.newSound", "Sound:getFormat", "lovr.data"],
          "summary": "Different channel layouts for Sounds.",
          "values": [
            { "description": "1 channel.", "name": "mono" },
            {
              "description": "2 channels.  The first channel is for the left speaker and the second is for the right.",
              "name": "stereo"
            },
            {
              "description": "4 channels.  Ambisonic channels don\u0027t map directly to speakers but instead represent directions in 3D space, sort of like the images of a skybox.  Currently, ambisonic sounds can only be loaded, not played.",
              "name": "ambisonic"
            }
          ]
        },
        {
          "description": "These are the different types of attributes that may be present in meshes loaded from models.",
          "key": "DefaultAttribute",
          "module": "lovr.data",
          "name": "DefaultAttribute",
          "related": ["lovr.data"],
          "summary": "Attributes that can be loaded from a model.",
          "values": [
            { "description": "Vertex positions.", "name": "position" },
            { "description": "Vertex normal vectors.", "name": "normal" },
            { "description": "Vertex texture coordinates.", "name": "uv" },
            { "description": "Vertex colors.", "name": "color" },
            { "description": "Vertex tangent vectors.", "name": "tangent" },
            { "description": "Vertex joint indices.", "name": "joints" },
            { "description": "Vertex joint weights.", "name": "weights" }
          ]
        },
        {
          "description": "The DrawMode of a mesh determines how its vertices are connected together.",
          "key": "ModelDrawMode",
          "module": "lovr.data",
          "name": "ModelDrawMode",
          "related": ["ModelData:getMeshDrawMode", "lovr.data"],
          "summary": "Different draw modes for meshes in ModelDatas.",
          "values": [
            {
              "description": "Each vertex is draw as a single point.",
              "name": "points"
            },
            {
              "description": "Every pair of vertices is drawn as a line.",
              "name": "lines"
            },
            {
              "description": "Draws a single line through all of the vertices.",
              "name": "linestrip"
            },
            {
              "description": "Draws a single line through all of the vertices, then connects back to the first vertex.",
              "name": "lineloop"
            },
            {
              "description": "Vertices are rendered as triangles.  After the first 3 vertices, each subsequent vertex connects to the previous two.",
              "name": "strip"
            },
            {
              "description": "Every 3 vertices forms a triangle.",
              "name": "triangles"
            },
            {
              "description": "Vertices are rendered as triangles.  After the first 3 vertices, each subsequent vertex is connected to the previous vertex and the first vertex.",
              "name": "fan"
            }
          ]
        },
        {
          "description": "Sounds can store audio samples as 16 bit integers or 32 bit floats.",
          "key": "SampleFormat",
          "module": "lovr.data",
          "name": "SampleFormat",
          "related": ["lovr.data.newSound", "Sound:getFormat", "lovr.data"],
          "summary": "Different data types for samples in a Sound.",
          "values": [
            {
              "description": "32 bit floating point samples (between -1.0 and 1.0).",
              "name": "f32"
            },
            {
              "description": "16 bit integer samples (between -32768 and 32767).",
              "name": "i16"
            }
          ]
        },
        {
          "description": "Different ways to interpolate between animation keyframes.",
          "key": "SmoothMode",
          "module": "lovr.data",
          "name": "SmoothMode",
          "related": ["lovr.data"],
          "summary": "Different ways to interpolate between animation keyframes.",
          "values": [
            {
              "description": "The animated property will snap to the nearest keyframe.",
              "name": "step"
            },
            {
              "description": "The animated property will linearly interpolate between keyframes.",
              "name": "linear"
            },
            {
              "description": "The animated property will follow a smooth curve between nearby keyframes.",
              "name": "cubic"
            }
          ]
        },
        {
          "description": "Different data layouts for pixels in `Image` and `Texture` objects.\n\nFormats starting with `d` are depth formats, used for depth\/stencil render targets.\n\nFormats starting with `bc` and `astc` are compressed formats.  Compressed formats have better performance since they stay compressed on the CPU and GPU, reducing the amount of memory bandwidth required to look up all the pixels needed for shading.\n\nFormats without the `f` suffix are unsigned normalized formats, which store values in the range `[0,1]`.  The `f` suffix indicates a floating point format which can store values outside this range, and is used for HDR rendering or storing data in a texture.",
          "key": "TextureFormat",
          "module": "lovr.data",
          "name": "TextureFormat",
          "related": ["lovr.data"],
          "summary": "Different pixel formats in `Image` and `Texture` objects.",
          "values": [
            {
              "description": "One 8-bit channel.  1 byte per pixel.",
              "name": "r8"
            },
            {
              "description": "Two 8-bit channels.  2 bytes per pixel.",
              "name": "rg8"
            },
            {
              "description": "Four 8-bit channels.  4 bytes per pixel.",
              "name": "rgba8"
            },
            {
              "description": "One 16-bit channel.  2 bytes per pixel.",
              "name": "r16"
            },
            {
              "description": "Two 16-bit channels.  4 bytes per pixel.",
              "name": "rg16"
            },
            {
              "description": "Four 16-bit channels.  8 bytes per pixel.",
              "name": "rgba16"
            },
            {
              "description": "One 16-bit floating point channel.  2 bytes per pixel.",
              "name": "r16f"
            },
            {
              "description": "Two 16-bit floating point channels.  4 bytes per pixel.",
              "name": "rg16f"
            },
            {
              "description": "Four 16-bit floating point channels.  8 bytes per pixel.",
              "name": "rgba16f"
            },
            {
              "description": "One 32-bit floating point channel.  4 bytes per pixel.",
              "name": "r32f"
            },
            {
              "description": "Two 32-bit floating point channels.  8 bytes per pixel.",
              "name": "rg32f"
            },
            {
              "description": "Four 32-bit floating point channels.  16 bytes per pixel.",
              "name": "rgba32f"
            },
            {
              "description": "Packs three channels into 16 bits.  2 bytes per pixel.",
              "name": "rgb565"
            },
            {
              "description": "Packs four channels into 16 bits, with \"cutout\" alpha.  2 bytes per pixel.",
              "name": "rgb5a1"
            },
            {
              "description": "Packs four channels into 32 bits.  4 bytes per pixel.",
              "name": "rgb10a2"
            },
            {
              "description": "Packs three unsigned floating point channels into 32 bits.  4 bytes per pixel.",
              "name": "rg11b10f"
            },
            {
              "description": "One 16-bit depth channel.  2 bytes per pixel.",
              "name": "d16"
            },
            {
              "description": "One 24-bit depth channel.  4 bytes per pixel.",
              "name": "d24"
            },
            {
              "description": "One 24-bit depth channel and one 8-bit stencil channel.  4 bytes per pixel.",
              "name": "d24s8"
            },
            {
              "description": "One 32-bit floating point depth channel.  4 bytes per pixel.",
              "name": "d32f"
            },
            {
              "description": "One 32-bit floating point depth channel and one 8-bit stencil channel.  5 bytes per pixel.",
              "name": "d32fs8"
            },
            {
              "description": "3 channels.  8 bytes per 4x4 block, or 0.5 bytes per pixel.  Good for opaque images.",
              "name": "bc1"
            },
            {
              "description": "Four channels.  16 bytes per 4x4 block or 1 byte per pixel.  Not good for anything, because it only has 16 distinct levels of alpha.",
              "name": "bc2"
            },
            {
              "description": "Four channels.  16 bytes per 4x4 block or 1 byte per pixel.  Good for color images with transparency.",
              "name": "bc3"
            },
            {
              "description": "One unsigned normalized channel.  8 bytes per 4x4 block or 0.5 bytes per pixel.  Good for grayscale images, like heightmaps.",
              "name": "bc4u"
            },
            {
              "description": "One signed normalized channel.  8 bytes per 4x4 block or 0.5 bytes per pixel.  Similar to bc4u but has a range of -1 to 1.",
              "name": "bc4s"
            },
            {
              "description": "Two unsigned normalized channels.  16 bytes per 4x4 block, or 1 byte per pixel.  Good for normal maps.",
              "name": "bc5u"
            },
            {
              "description": "Two signed normalized channels.  16 bytes per 4x4 block or 1 byte per pixel.  Good for normal maps.",
              "name": "bc5s"
            },
            {
              "description": "Three unsigned floating point channels.  16 bytes per 4x4 block or 1 byte per pixel.  Good for HDR images.",
              "name": "bc6uf"
            },
            {
              "description": "Three floating point channels.  16 bytes per 4x4 block or 1 byte per pixel.  Good for HDR images.",
              "name": "bc6sf"
            },
            {
              "description": "Four channels.  16 bytes per 4x4 block or 1 byte per pixel.  High quality.  Good for most color images, including transparency.",
              "name": "bc7"
            },
            {
              "description": "Four channels, 16 bytes per 4x4 block or 1 byte per pixel.",
              "name": "astc4x4"
            },
            {
              "description": "Four channels, 16 bytes per 5x4 block or 0.80 bytes per pixel.",
              "name": "astc5x4"
            },
            {
              "description": "Four channels, 16 bytes per 5x5 block or 0.64 bytes per pixel.",
              "name": "astc5x5"
            },
            {
              "description": "Four channels, 16 bytes per 6x5 block or 0.53 bytes per pixel.",
              "name": "astc6x5"
            },
            {
              "description": "Four channels, 16 bytes per 6x6 block or 0.44 bytes per pixel.",
              "name": "astc6x6"
            },
            {
              "description": "Four channels, 16 bytes per 8x5 block or 0.40 bytes per pixel.",
              "name": "astc8x5"
            },
            {
              "description": "Four channels, 16 bytes per 8x6 block or 0.33 bytes per pixel.",
              "name": "astc8x6"
            },
            {
              "description": "Four channels, 16 bytes per 8x8 block or 0.25 bytes per pixel.",
              "name": "astc8x8"
            },
            {
              "description": "Four channels, 16 bytes per 10x5 block or 0.32 bytes per pixel.",
              "name": "astc10x5"
            },
            {
              "description": "Four channels, 16 bytes per 10x6 block or 0.27 bytes per pixel.",
              "name": "astc10x6"
            },
            {
              "description": "Four channels, 16 bytes per 10x8 block or 0.20 bytes per pixel.",
              "name": "astc10x8"
            },
            {
              "description": "Four channels, 16 bytes per 10x10 block or 0.16 bytes per pixel.",
              "name": "astc10x10"
            },
            {
              "description": "Four channels, 16 bytes per 12x10 block or 0.13 bytes per pixel.",
              "name": "astc12x10"
            },
            {
              "description": "Four channels, 16 bytes per 12x12 block or 0.11 bytes per pixel.",
              "name": "astc12x12"
            }
          ]
        }
      ],
      "functions": [
        {
          "description": "Creates a new Blob.",
          "key": "lovr.data.newBlob",
          "module": "lovr.data",
          "name": "newBlob",
          "related": ["lovr.filesystem.newBlob", "lovr.data"],
          "summary": "Create a new Blob.",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The amount of data to allocate for the Blob, in bytes.  All of the bytes will be filled with zeroes.",
                  "name": "size",
                  "type": "number"
                },
                {
                  "default": "\u0027\u0027",
                  "description": "A name for the Blob (used in error messages)",
                  "name": "name",
                  "type": "string"
                }
              ],
              "returns": [
                {
                  "description": "The new Blob.",
                  "name": "blob",
                  "type": "Blob"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "A string to use for the Blob\u0027s contents.",
                  "name": "contents",
                  "type": "string"
                },
                {
                  "default": "\u0027\u0027",
                  "description": "A name for the Blob (used in error messages)",
                  "name": "name",
                  "type": "string"
                }
              ],
              "returns": [
                {
                  "description": "The new Blob.",
                  "name": "blob",
                  "type": "Blob"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "A Blob to copy the contents from.",
                  "name": "source",
                  "type": "Blob"
                },
                {
                  "default": "\u0027\u0027",
                  "description": "A name for the Blob (used in error messages)",
                  "name": "name",
                  "type": "string"
                }
              ],
              "returns": [
                {
                  "description": "The new Blob.",
                  "name": "blob",
                  "type": "Blob"
                }
              ]
            }
          ]
        },
        {
          "description": "Creates a new Image.  Image data can be loaded and decoded from an image file, or a raw block of pixels with a specified width, height, and format can be created.",
          "key": "lovr.data.newImage",
          "module": "lovr.data",
          "name": "newImage",
          "notes": "The supported image file formats are png, jpg, hdr, dds, ktx1, ktx2, and astc.\n\nDDS and KTX files can contain cubemaps and array textures, in any of the texture formats L\u00d6VR supports.",
          "related": ["lovr.data"],
          "summary": "Create a new Image.",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The filename of the image to load.",
                  "name": "filename",
                  "type": "string"
                }
              ],
              "description": "Load image data from a file.",
              "returns": [
                {
                  "description": "The new Image.",
                  "name": "image",
                  "type": "Image"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The width of the texture.",
                  "name": "width",
                  "type": "number"
                },
                {
                  "description": "The height of the texture.",
                  "name": "height",
                  "type": "number"
                },
                {
                  "default": "rgba8",
                  "description": "The format of the texture\u0027s pixels.",
                  "name": "format",
                  "type": "TextureFormat"
                },
                {
                  "default": "nil",
                  "description": "Raw pixel values to use as the contents.  If `nil`, the data will all be zero.",
                  "name": "data",
                  "type": "Blob"
                }
              ],
              "description": "Create an Image with a given size and pixel format.",
              "returns": [
                {
                  "description": "The new Image.",
                  "name": "image",
                  "type": "Image"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The Image to clone.",
                  "name": "source",
                  "type": "Image"
                }
              ],
              "description": "Clone an existing Image.",
              "returns": [
                {
                  "description": "The new Image.",
                  "name": "image",
                  "type": "Image"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The Blob containing image data to decode.",
                  "name": "blob",
                  "type": "Blob"
                }
              ],
              "description": "Decode image data from a Blob.",
              "returns": [
                {
                  "description": "The new Image.",
                  "name": "image",
                  "type": "Image"
                }
              ]
            }
          ]
        },
        {
          "description": "Loads a 3D model from a file.  The supported 3D file formats are OBJ and glTF.",
          "key": "lovr.data.newModelData",
          "module": "lovr.data",
          "name": "newModelData",
          "related": ["lovr.data"],
          "summary": "Create a new ModelData.",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The filename of the model to load.",
                  "name": "filename",
                  "type": "string"
                }
              ],
              "returns": [
                {
                  "description": "The new ModelData.",
                  "name": "modelData",
                  "type": "ModelData"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The Blob containing data for a model to decode.",
                  "name": "blob",
                  "type": "Blob"
                }
              ],
              "returns": [
                {
                  "description": "The new ModelData.",
                  "name": "modelData",
                  "type": "ModelData"
                }
              ]
            }
          ]
        },
        {
          "description": "Creates a new Rasterizer from a TTF or BMFont file.",
          "key": "lovr.data.newRasterizer",
          "module": "lovr.data",
          "name": "newRasterizer",
          "related": ["lovr.data"],
          "summary": "Create a new Rasterizer.",
          "variants": [
            {
              "arguments": [
                {
                  "default": "32",
                  "description": "The resolution to render the font at, in pixels (TTF only).  Higher resolutions use more memory and processing power but may provide better quality results for some fonts\/situations.",
                  "name": "size",
                  "type": "number"
                }
              ],
              "description": "Create a Rasterizer for the default font included with L\u00d6VR (Varela Round).",
              "returns": [
                {
                  "description": "The new Rasterizer.",
                  "name": "rasterizer",
                  "type": "Rasterizer"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The filename of the font file to load.",
                  "name": "filename",
                  "type": "string"
                },
                {
                  "default": "32",
                  "description": "The resolution to render the font at, in pixels (TTF only).  Higher resolutions use more memory and processing power but may provide better quality results for some fonts\/situations.",
                  "name": "size",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "The new Rasterizer.",
                  "name": "rasterizer",
                  "type": "Rasterizer"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The Blob containing font data.",
                  "name": "blob",
                  "type": "Blob"
                },
                {
                  "default": "32",
                  "description": "The resolution to render the font at, in pixels (TTF only).  Higher resolutions use more memory and processing power but may provide better quality results for some fonts\/situations.",
                  "name": "size",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "The new Rasterizer.",
                  "name": "rasterizer",
                  "type": "Rasterizer"
                }
              ]
            }
          ]
        },
        {
          "description": "Creates a new Sound.  A sound can be loaded from an audio file, or it can be created empty with capacity for a certain number of audio frames.\n\nWhen loading audio from a file, use the `decode` option to control whether compressed audio should remain compressed or immediately get decoded to raw samples.\n\nWhen creating an empty sound, the `contents` parameter can be set to `\u0027stream\u0027` to create an audio stream.  On streams, `Sound:setFrames` will always write to the end of the stream, and `Sound:getFrames` will always read the oldest samples from the beginning.  The number of frames in the sound is the total capacity of the stream\u0027s buffer.",
          "key": "lovr.data.newSound",
          "module": "lovr.data",
          "name": "newSound",
          "notes": "It is highly recommended to use an audio format that matches the format of the audio module: `f32` sample formats at a sample rate of 48000, with 1 channel for spatialized sources or 2 channels for unspatialized sources.  This will avoid the need to convert audio during playback, which boosts performance of the audio thread.\n\nThe WAV importer supports 16, 24, and 32 bit integer data and 32 bit floating point data.  The data must be mono, stereo, or 4-channel full-sphere ambisonic.  The `WAVE_FORMAT_EXTENSIBLE` extension is supported.\n\nAmbisonic channel layouts are supported for import (but not yet for playback).  Ambisonic data can be loaded from WAV files.  It must be first-order full-sphere ambisonic data with 4 channels.  If the WAV has a `WAVE_FORMAT_EXTENSIBLE` chunk with an `AMBISONIC_B_FORMAT` format GUID, then the data is understood as using the AMB format with Furse-Malham channel ordering and normalization.  *All other* 4-channel files are assumed to be using the AmbiX format with ACN channel ordering and SN3D normalization.  AMB files will get automatically converted to AmbiX on import, so ambisonic Sounds will always be in a consistent format.\n\nOGG and MP3 files will always have the `f32` format when loaded.",
          "related": ["lovr.data"],
          "summary": "Create a new Sound.",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The number of frames the Sound can hold.",
                  "name": "frames",
                  "type": "number"
                },
                {
                  "default": "\u0027f32\u0027",
                  "description": "The sample data type.",
                  "name": "format",
                  "type": "SampleFormat"
                },
                {
                  "default": "\u0027stereo\u0027",
                  "description": "The channel layout.",
                  "name": "channels",
                  "type": "ChannelLayout"
                },
                {
                  "default": "48000",
                  "description": "The sample rate, in Hz.",
                  "name": "sampleRate",
                  "type": "number"
                },
                {
                  "default": "nil",
                  "description": "A Blob containing raw audio samples to use as the initial contents, \u0027stream\u0027 to create an audio stream, or `nil` to leave the data initialized to zero.",
                  "name": "contents",
                  "type": "*"
                }
              ],
              "description": "Create a raw or stream Sound from a frame count and format info:",
              "returns": [
                {
                  "description": "Sounds good.",
                  "name": "sound",
                  "type": "Sound"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The filename of a sound to load.",
                  "name": "filename",
                  "type": "string"
                },
                {
                  "description": "Whether compressed audio files should be immediately decoded.",
                  "name": "decode",
                  "type": "boolean"
                }
              ],
              "description": "Load a sound from a file.  Compressed audio formats (OGG, MP3) can optionally be decoded into raw sounds.",
              "returns": [
                {
                  "description": "Sounds good.",
                  "name": "sound",
                  "type": "Sound"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The Blob containing audio file data to load.",
                  "name": "blob",
                  "type": "Blob"
                },
                {
                  "description": "Whether compressed audio files should be immediately decoded.",
                  "name": "decode",
                  "type": "boolean"
                }
              ],
              "description": "Load a sound from a Blob containing the data of an audio file.  Compressed audio formats (OGG, MP3) can optionally be decoded into raw sounds.\n\nIf the Blob contains raw audio samples, use the first variant instead of this one.",
              "returns": [
                {
                  "description": "Sounds good.",
                  "name": "sound",
                  "type": "Sound"
                }
              ]
            }
          ]
        }
      ],
      "key": "lovr.data",
      "name": "data",
      "objects": [
        {
          "constructors": ["lovr.data.newBlob", "lovr.filesystem.newBlob"],
          "description": "A Blob is an object that holds binary data.  It can be passed to most functions that take filename arguments, like `lovr.graphics.newModel` or `lovr.audio.newSource`.  Blobs aren\u0027t usually necessary for simple projects, but they can be really helpful if:\n\n- You need to work with low level binary data, potentially using the LuaJIT FFI for increased\n  performance.\n- You are working with data that isn\u0027t stored as a file, such as programmatically generated data\n  or a string from a network request.\n- You want to load data from a file once and then use it to create many different objects.\n\nA Blob\u0027s size cannot be changed once it is created.",
          "key": "Blob",
          "methods": [
            {
              "description": "Returns the size of the Blob\u0027s contents, in bytes.",
              "key": "Blob:getSize",
              "module": "lovr.data",
              "name": "getSize",
              "related": ["Blob"],
              "summary": "Get the size of the Blob, in bytes.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The size of the Blob, in bytes.",
                      "name": "bytes",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the filename the Blob was loaded from, or the custom name given to it when it was created.  This label is also used in error messages.",
              "key": "Blob:getName",
              "module": "lovr.data",
              "name": "getName",
              "related": ["Blob"],
              "summary": "Get the label of the Blob.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The name of the Blob.",
                      "name": "name",
                      "type": "string"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns a raw pointer to the Blob\u0027s data.  This can be used to interface with other C libraries using the LuaJIT FFI.  Use this only if you know what you\u0027re doing!",
              "key": "Blob:getPointer",
              "module": "lovr.data",
              "name": "getPointer",
              "related": ["Blob"],
              "summary": "Get a raw pointer to the Blob\u0027s data.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "A pointer to the data.",
                      "name": "pointer",
                      "type": "userdata"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns a binary string containing the Blob\u0027s data.",
              "examples": [
                {
                  "code": "blob \u003d lovr.filesystem.newBlob(\u0027main.lua\u0027)\nstr \u003d blob:getString()\n\nfor i \u003d 1, #str do\n  print(string.byte(str, i))\nend",
                  "description": "Print each byte of the main.lua file:"
                }
              ],
              "key": "Blob:getString",
              "module": "lovr.data",
              "name": "getString",
              "notes": "This effectively allocates a new copy of the Blob as a Lua string, so this should be avoided for really big Blobs!",
              "related": ["Blob"],
              "summary": "Get the Blob\u0027s contents as a string.",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "0",
                      "description": "A byte offset into the Blob where the string will start.",
                      "name": "offset",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "The number of bytes the string will contain.  If nil, the rest of the data in the Blob will be used, based on the `offset` parameter.",
                      "name": "size",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The Blob\u0027s data.",
                      "name": "data",
                      "type": "string"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns signed 8-bit integers from the data in the Blob.",
              "key": "Blob:getI8",
              "module": "lovr.data",
              "name": "getI8",
              "related": [
                "Blob:getU8",
                "Blob:getI16",
                "Blob:getU16",
                "Blob:getI32",
                "Blob:getU32",
                "Blob:getF32",
                "Blob:getF64",
                "Blob"
              ],
              "summary": "Unpack signed 8-bit integers from the Blob.",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "0",
                      "description": "A non-negative byte offset to read from.",
                      "name": "offset",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The number of integers to read.",
                      "name": "count",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "`count` signed 8-bit integers, from -128 to 127.",
                      "name": "...",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns unsigned 8-bit integers from the data in the Blob.",
              "key": "Blob:getU8",
              "module": "lovr.data",
              "name": "getU8",
              "related": [
                "Blob:getI8",
                "Blob:getI16",
                "Blob:getU16",
                "Blob:getI32",
                "Blob:getU32",
                "Blob:getF32",
                "Blob:getF64",
                "Blob"
              ],
              "summary": "Unpack unsigned 8-bit integers from the Blob.",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "0",
                      "description": "A non-negative byte offset to read from.",
                      "name": "offset",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The number of integers to read.",
                      "name": "count",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "`count` unsigned 8-bit integers, from 0 to 255.",
                      "name": "...",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns signed 16-bit integers from the data in the Blob.",
              "key": "Blob:getI16",
              "module": "lovr.data",
              "name": "getI16",
              "related": [
                "Blob:getI8",
                "Blob:getU8",
                "Blob:getU16",
                "Blob:getI32",
                "Blob:getU32",
                "Blob:getF32",
                "Blob:getF64",
                "Blob"
              ],
              "summary": "Unpack signed 16-bit integers from the Blob.",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "0",
                      "description": "A non-negative byte offset to read from.",
                      "name": "offset",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The number of integers to read.",
                      "name": "count",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "`count` signed 16-bit integers, from -32768 to 32767.",
                      "name": "...",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns unsigned 16-bit integers from the data in the Blob.",
              "key": "Blob:getU16",
              "module": "lovr.data",
              "name": "getU16",
              "related": [
                "Blob:getI8",
                "Blob:getU8",
                "Blob:getI16",
                "Blob:getI32",
                "Blob:getU32",
                "Blob:getF32",
                "Blob:getF64",
                "Blob"
              ],
              "summary": "Unpack unsigned 16-bit integers from the Blob.",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "0",
                      "description": "A non-negative byte offset to read from.",
                      "name": "offset",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The number of integers to read.",
                      "name": "count",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "`count` unsigned 16-bit integers, from 0 to 65535.",
                      "name": "...",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns signed 32-bit integers from the data in the Blob.",
              "key": "Blob:getI32",
              "module": "lovr.data",
              "name": "getI32",
              "related": [
                "Blob:getI8",
                "Blob:getU8",
                "Blob:getI16",
                "Blob:getU16",
                "Blob:getU32",
                "Blob:getF32",
                "Blob:getF64",
                "Blob"
              ],
              "summary": "Unpack signed 32-bit integers from the Blob.",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "0",
                      "description": "A non-negative byte offset to read from.",
                      "name": "offset",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The number of integers to read.",
                      "name": "count",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "`count` signed 32-bit integers, from -2147483648 to 2147483647.",
                      "name": "...",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns unsigned 32-bit integers from the data in the Blob.",
              "key": "Blob:getU32",
              "module": "lovr.data",
              "name": "getU32",
              "related": [
                "Blob:getI8",
                "Blob:getU8",
                "Blob:getI16",
                "Blob:getU16",
                "Blob:getI32",
                "Blob:getF32",
                "Blob:getF64",
                "Blob"
              ],
              "summary": "Unpack unsigned 32-bit integers from the Blob.",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "0",
                      "description": "A non-negative byte offset to read from.",
                      "name": "offset",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The number of integers to read.",
                      "name": "count",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "`count` unsigned 32-bit integers, from 0 to 4294967296.",
                      "name": "...",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns 32-bit floating point numbers from the data in the Blob.",
              "key": "Blob:getF32",
              "module": "lovr.data",
              "name": "getF32",
              "related": [
                "Blob:getI8",
                "Blob:getU8",
                "Blob:getI16",
                "Blob:getU16",
                "Blob:getI32",
                "Blob:getU32",
                "Blob:getF64",
                "Blob"
              ],
              "summary": "Unpack 32-bit floating point numbers from the Blob.",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "0",
                      "description": "A non-negative byte offset to read from.",
                      "name": "offset",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The number of floats to read.",
                      "name": "count",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "`count` 32-bit floats.",
                      "name": "...",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns 64-bit floating point numbers from the data in the Blob.",
              "key": "Blob:getF64",
              "module": "lovr.data",
              "name": "getF64",
              "related": [
                "Blob:getI8",
                "Blob:getU8",
                "Blob:getI16",
                "Blob:getU16",
                "Blob:getI32",
                "Blob:getU32",
                "Blob:getF32",
                "Blob"
              ],
              "summary": "Unpack 64-bit floating point numbers from the Blob.",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "0",
                      "description": "A non-negative byte offset to read from.",
                      "name": "offset",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The number of doubles to read.",
                      "name": "count",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "`count` 64-bit doubles.",
                      "name": "...",
                      "type": "number"
                    }
                  ]
                }
              ]
            }
          ],
          "module": "lovr.data",
          "name": "Blob",
          "related": ["lovr.data"],
          "summary": "A chunk of binary data."
        },
        {
          "constructors": ["lovr.data.newImage"],
          "description": "An Image stores raw 2D pixel info for `Texture`s.  It has a width, height, and format.  The Image can be initialized with the contents of an image file or it can be created with uninitialized contents.  The supported image formats are `png`, `jpg`, `hdr`, `dds`, `ktx`, and `astc`.\n\nUsually you can just use Textures, but Image can be useful if you want to manipulate individual pixels, load Textures in a background thread, or use the FFI to efficiently access the raw image data.",
          "key": "Image",
          "methods": [
            {
              "description": "Encodes the Image to an uncompressed png.  This intended mainly for debugging.",
              "key": "Image:encode",
              "module": "lovr.data",
              "name": "encode",
              "related": ["lovr.filesystem.write", "Image"],
              "summary": "Encode the Image as png.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "A new Blob containing the PNG image data.",
                      "name": "blob",
                      "type": "Blob"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns a Blob containing the raw bytes of the Image.",
              "key": "Image:getBlob",
              "module": "lovr.data",
              "name": "getBlob",
              "related": ["Blob:getPointer", "Sound:getBlob", "Image"],
              "summary": "Get the bytes backing this Image as a `Blob`.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The Blob instance containing the bytes for the `Image`.",
                      "name": "blob",
                      "type": "Blob"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the dimensions of the Image, in pixels.",
              "key": "Image:getDimensions",
              "module": "lovr.data",
              "name": "getDimensions",
              "related": [
                "Image:getWidth",
                "Image:getHeight",
                "Texture:getDimensions",
                "Image"
              ],
              "summary": "Get the dimensions of the Image.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The width of the Image, in pixels.",
                      "name": "width",
                      "type": "number"
                    },
                    {
                      "description": "The height of the Image, in pixels.",
                      "name": "height",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the format of the Image.",
              "key": "Image:getFormat",
              "module": "lovr.data",
              "name": "getFormat",
              "related": ["TextureFormat", "Texture:getFormat", "Image"],
              "summary": "Get the pixel format of the Image.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The format of the pixels in the Image.",
                      "name": "format",
                      "type": "TextureFormat"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the height of the Image, in pixels.",
              "key": "Image:getHeight",
              "module": "lovr.data",
              "name": "getHeight",
              "related": [
                "Image:getWidth",
                "Image:getDimensions",
                "Texture:getHeight",
                "Image"
              ],
              "summary": "Get the height of the Image.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The height of the Image, in pixels.",
                      "name": "height",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the value of a pixel of the Image.",
              "key": "Image:getPixel",
              "module": "lovr.data",
              "name": "getPixel",
              "notes": "The following texture formats are supported: `r8`, `rg8`, `rgba8`, `r16`, `rg16`, `rgba16`, `r32f`, `rg32f`, `rgba32f`.",
              "related": [
                "Image:setPixel",
                "Image:mapPixel",
                "TextureFormat",
                "Texture:getPixels",
                "Texture:setPixels",
                "Texture:newReadback",
                "Image:setPixel",
                "Image"
              ],
              "summary": "Get the value of a pixel of the Image.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The x coordinate of the pixel to get (0-indexed).",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate of the pixel to get (0-indexed).",
                      "name": "y",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The red component of the pixel, from 0.0 to 1.0.",
                      "name": "r",
                      "type": "number"
                    },
                    {
                      "description": "The green component of the pixel, from 0.0 to 1.0.",
                      "name": "g",
                      "type": "number"
                    },
                    {
                      "description": "The blue component of the pixel, from 0.0 to 1.0.",
                      "name": "b",
                      "type": "number"
                    },
                    {
                      "description": "The alpha component of the pixel, from 0.0 to 1.0.",
                      "name": "a",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns a raw pointer to the Image\u0027s pixel data.  This can be used to interface with other C libraries or the LuaJIT FFI.",
              "examples": [
                {
                  "code": "local ffi \u003d require \u0027ffi\u0027\n\nfunction lovr.load()\n  image \u003d lovr.data.newImage(2, 2)\n\n  ffi.cdef [[\n    typedef struct { uint8_t r, g, b, a; } Pixel;\n  ]]\n\n  pointer \u003d image:getPointer()\n  pixels \u003d ffi.cast(\u0027Pixel*\u0027, pointer)\n  pixels[0] \u003d { 255, 0, 0, 255 }\n  pixels[1] \u003d { 0, 255, 0, 255 }\n  pixels[2] \u003d { 0, 0, 255, 255 }\n  pixels[3] \u003d { 255, 255, 255, 255 }\n\n  texture \u003d lovr.graphics.newTexture(image)\nend\n\nfunction lovr.draw(pass)\n  pass:setSampler(\u0027nearest\u0027)\n  pass:fill(texture)\nend",
                  "description": "Simple example of writing to Image pixels with LuaJIT\u0027s FFI module."
                }
              ],
              "key": "Image:getPointer",
              "module": "lovr.data",
              "name": "getPointer",
              "related": ["Image"],
              "summary": "Get a raw pointer to the Image pixel data.",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "1",
                      "description": "The mipmap level to get the pointer of (for DDS and KTX images).",
                      "name": "level",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The array layer to get the pointer of (for DDS and KTX images).",
                      "name": "layer",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "A pointer to the raw pixel data.",
                      "name": "pointer",
                      "type": "userdata"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the width of the Image, in pixels.",
              "key": "Image:getWidth",
              "module": "lovr.data",
              "name": "getWidth",
              "related": [
                "Image:getHeight",
                "Image:getDimensions",
                "Texture:getWidth",
                "Image"
              ],
              "summary": "Get the width of the Image.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The width of the Image, in pixels.",
                      "name": "width",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Transforms pixels in the Image using a function.\n\nThe callback function passed to this function will be called once for each pixel.  For each pixel, the function will be called with its x and y coordinate and the red, green, blue, and alpha components of its color.  Whatever the function returns will be used as the new color for the pixel.\n\nThe callback function will potentially be called thousands of times, so it\u0027s best to keep the amount of code in there small and fast.",
              "examples": [
                {
                  "code": "image:mapPixel(function(x, y, r, g, b, a)\n  local brightness \u003d .21 * r + .72 * g + .07 * b\n  return brightness, brightness, brightness, a\nend)",
                  "description": "Convert an Image to grayscale."
                },
                {
                  "code": "local ffi \u003d require \u0027ffi\u0027\n\nfunction lovr.load()\n  local w, h \u003d 256, 256\n\n  image \u003d lovr.data.newImage(w, h)\n\n  local pointer \u003d ffi.cast(\u0027uint8_t*\u0027, image:getPointer())\n\n  for y \u003d 0, h - 1 do\n    for x \u003d 0, w - 1 do\n      pointer[(y * w + x) * 4 + 0] \u003d (x \/ w) * 255\n      pointer[(y * w + x) * 4 + 1] \u003d (y \/ h) * 255\n      pointer[(y * w + x) * 4 + 2] \u003d 255\n      pointer[(y * w + x) * 4 + 3] \u003d 255\n    end\n  end\n\n  texture \u003d lovr.graphics.newTexture(image)\nend\n\nfunction lovr.draw(pass)\n  pass:fill(texture)\nend",
                  "description": "Efficient Image updates using FFI.  Due to the low-level nature, this will be a lot faster, but it\u0027s specialized to the `rgba8` image format and risks crashing if used improperly."
                }
              ],
              "key": "Image:mapPixel",
              "module": "lovr.data",
              "name": "mapPixel",
              "notes": "The following texture formats are supported: `r8`, `rg8`, `rgba8`, `r16`, `rg16`, `rgba16`, `r32f`, `rg32f`, `rgba32f`.",
              "related": [
                "Image:setPixel",
                "Image:getPixel",
                "TextureFormat",
                "Texture:setPixels",
                "Image"
              ],
              "summary": "Transform an Image by applying a function to every pixel.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The function that will be called for each pixel.",
                      "name": "callback",
                      "type": "function"
                    },
                    {
                      "default": "0",
                      "description": "The x coordinate of the upper-left corner of the area of the Image to affect.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The y coordinate of the upper-left corner of the area of the Image to affect.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "default": "image:getWidth()",
                      "description": "The width of the area to affect.",
                      "name": "w",
                      "type": "number"
                    },
                    {
                      "default": "image:getHeight()",
                      "description": "The height of the area to affect.",
                      "name": "h",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Copies a rectangle of pixels from one Image to this one.",
              "key": "Image:paste",
              "module": "lovr.data",
              "name": "paste",
              "notes": "The two Images must have the same pixel format.\n\nCompressed images cannot be copied.\n\nThe rectangle cannot go outside the dimensions of the source or destination textures.",
              "related": [
                "Image:getPixel",
                "Image:setPixel",
                "Texture:setPixels",
                "Image"
              ],
              "summary": "Copy pixels from another Image to this one.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The Image to copy pixels from.",
                      "name": "source",
                      "type": "Image"
                    },
                    {
                      "default": "0",
                      "description": "The x coordinate to paste to (0-indexed).",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The y coordinate to paste to (0-indexed).",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The x coordinate in the source to paste from (0-indexed).",
                      "name": "fromX",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The y coordinate in the source to paste from (0-indexed).",
                      "name": "fromY",
                      "type": "number"
                    },
                    {
                      "default": "source:getWidth()",
                      "description": "The width of the region to copy.",
                      "name": "width",
                      "type": "number"
                    },
                    {
                      "default": "source:getHeight()",
                      "description": "The height of the region to copy.",
                      "name": "height",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the value of a single pixel of the Image.\n\nIf you need to change a bunch of pixels, consider using `Image:mapPixel`.",
              "key": "Image:setPixel",
              "module": "lovr.data",
              "name": "setPixel",
              "notes": "The following texture formats are supported: `r8`, `rg8`, `rgba8`, `r16`, `rg16`, `rgba16`, `r32f`, `rg32f`, `rgba32f`.",
              "related": [
                "Image:mapPixel",
                "Image:getPixel",
                "TextureFormat",
                "Texture:setPixels",
                "Image:getPixel",
                "Image"
              ],
              "summary": "Set the value of a pixel of the Image.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The x coordinate of the pixel to set (0-indexed).",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate of the pixel to set (0-indexed).",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The red component of the pixel, from 0.0 to 1.0.",
                      "name": "r",
                      "type": "number"
                    },
                    {
                      "description": "The green component of the pixel, from 0.0 to 1.0.",
                      "name": "g",
                      "type": "number"
                    },
                    {
                      "description": "The blue component of the pixel, from 0.0 to 1.0.",
                      "name": "b",
                      "type": "number"
                    },
                    {
                      "default": "1.0",
                      "description": "The alpha component of the pixel, from 0.0 to 1.0.",
                      "name": "a",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            }
          ],
          "module": "lovr.data",
          "name": "Image",
          "related": ["lovr.data"],
          "summary": "An object that stores pixel data for Textures."
        },
        {
          "constructors": ["lovr.data.newModelData"],
          "description": "A ModelData is a container object that loads and holds data contained in 3D model files.  This can include a variety of things like the node structure of the asset, the vertex data it contains, contains, the `Image` and `Material` properties, and any included animations.\n\nThe current supported formats are OBJ, glTF, and STL.\n\nUsually you can just load a `Model` directly, but using a `ModelData` can be helpful if you want to load models in a thread or access more low-level information about the Model.",
          "key": "ModelData",
          "methods": [
            {
              "description": "Returns the number of channels in an animation.\n\nA channel is a set of keyframes for a single property of a node.",
              "key": "ModelData:getAnimationChannelCount",
              "module": "lovr.data",
              "name": "getAnimationChannelCount",
              "related": [
                "ModelData:getAnimationNode",
                "ModelData:getAnimationProperty",
                "ModelData"
              ],
              "summary": "Get the number of channels in an animation.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of an animation.",
                      "name": "index",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The number of channels in the animation.",
                      "name": "count",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The name of an animation.",
                      "name": "name",
                      "type": "string"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The number of channels in the animation.",
                      "name": "count",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the number of animations in the model.",
              "key": "ModelData:getAnimationCount",
              "module": "lovr.data",
              "name": "getAnimationCount",
              "related": ["Model:getAnimationCount", "ModelData"],
              "summary": "Get the number of animations in the model.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The number of animations in the model.",
                      "name": "count",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the duration of an animation.",
              "key": "ModelData:getAnimationDuration",
              "module": "lovr.data",
              "name": "getAnimationDuration",
              "notes": "The duration of the animation is calculated as the latest timestamp of all of its channels.",
              "related": ["Model:getAnimationDuration", "ModelData"],
              "summary": "Get the duration of an animation.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of the animation.",
                      "name": "index",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The duration of the animation, in seconds.",
                      "name": "duration",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The name of the animation.",
                      "name": "name",
                      "type": "string"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The duration of the animation, in seconds.",
                      "name": "duration",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns a single keyframe in a channel of an animation.",
              "key": "ModelData:getAnimationKeyframe",
              "module": "lovr.data",
              "name": "getAnimationKeyframe",
              "related": [
                "ModelData:getAnimationSmoothMode",
                "ModelData:getAnimationKeyframeCount",
                "ModelData"
              ],
              "summary": "Get a keyframe in a channel of an animation.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of an animation.",
                      "name": "index",
                      "type": "number"
                    },
                    {
                      "description": "The index of a channel in the animation.",
                      "name": "channel",
                      "type": "number"
                    },
                    {
                      "description": "The index of a keyframe in the channel.",
                      "name": "keyframe",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The timestamp of the keyframe.",
                      "name": "time",
                      "type": "number"
                    },
                    {
                      "description": "The data for the keyframe (either 3 or 4 numbers depending on the property).",
                      "name": "...",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The name of an animation.",
                      "name": "name",
                      "type": "string"
                    },
                    {
                      "description": "The index of a channel in the animation.",
                      "name": "channel",
                      "type": "number"
                    },
                    {
                      "description": "The index of a keyframe in the channel.",
                      "name": "keyframe",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The timestamp of the keyframe.",
                      "name": "time",
                      "type": "number"
                    },
                    {
                      "description": "The data for the keyframe (either 3 or 4 numbers depending on the property).",
                      "name": "...",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the number of keyframes in a channel of an animation.",
              "key": "ModelData:getAnimationKeyframeCount",
              "module": "lovr.data",
              "name": "getAnimationKeyframeCount",
              "related": [
                "ModelData:getAnimationSmoothMode",
                "ModelData:getAnimationKeyframe",
                "ModelData"
              ],
              "summary": "Get the number of keyframes in a channel of an animation.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of an animation.",
                      "name": "index",
                      "type": "number"
                    },
                    {
                      "description": "The index of a channel in the animation.",
                      "name": "channel",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The number of keyframes in the channel.",
                      "name": "count",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The name of an animation.",
                      "name": "name",
                      "type": "string"
                    },
                    {
                      "description": "The index of a channel in the animation.",
                      "name": "channel",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The number of keyframes in the channel.",
                      "name": "count",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the name of an animation.",
              "key": "ModelData:getAnimationName",
              "module": "lovr.data",
              "name": "getAnimationName",
              "notes": "If the animation does not have a name, this function returns `nil`.",
              "related": ["Model:getAnimationName", "ModelData"],
              "summary": "Get the name of an animation.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of the animation.",
                      "name": "index",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The name of the animation.",
                      "name": "name",
                      "type": "string"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the index of a node targeted by an animation\u0027s channel.",
              "key": "ModelData:getAnimationNode",
              "module": "lovr.data",
              "name": "getAnimationNode",
              "related": [
                "ModelData:getAnimationProperty",
                "ModelData:getAnimationSmoothMode",
                "ModelData"
              ],
              "summary": "Get the node targeted by the channel of an animation.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of an animation.",
                      "name": "index",
                      "type": "number"
                    },
                    {
                      "description": "The index of a channel in the animation.",
                      "name": "channel",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The index of the node targeted by the channel.",
                      "name": "node",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The name of an animation.",
                      "name": "name",
                      "type": "string"
                    },
                    {
                      "description": "The index of a channel in the animation.",
                      "name": "channel",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The index of the node targeted by the channel.",
                      "name": "node",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the property targeted by an animation\u0027s channel.",
              "key": "ModelData:getAnimationProperty",
              "module": "lovr.data",
              "name": "getAnimationProperty",
              "related": [
                "ModelData:getAnimationNode",
                "ModelData:getAnimationSmoothMode",
                "ModelData"
              ],
              "summary": "Get the property targeted by the channel of an animation.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of an animation.",
                      "name": "index",
                      "type": "number"
                    },
                    {
                      "description": "The index of a channel in the animation.",
                      "name": "channel",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The property (translation, rotation, scale, weights) affected by the keyframes.",
                      "name": "property",
                      "type": "AnimationProperty"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The name of an animation.",
                      "name": "name",
                      "type": "string"
                    },
                    {
                      "description": "The index of a channel in the animation.",
                      "name": "channel",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The property (translation, rotation, scale, weights) affected by the keyframes.",
                      "name": "property",
                      "type": "AnimationProperty"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the smooth mode of a channel in an animation.",
              "key": "ModelData:getAnimationSmoothMode",
              "module": "lovr.data",
              "name": "getAnimationSmoothMode",
              "related": [
                "ModelData:getAnimationNode",
                "ModelData:getAnimationProperty",
                "ModelData"
              ],
              "summary": "Get the smooth mode of a channel in an animation.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of an animation.",
                      "name": "index",
                      "type": "number"
                    },
                    {
                      "description": "The index of a channel in the animation.",
                      "name": "channel",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The smooth mode of the keyframes.",
                      "name": "smooth",
                      "type": "SmoothMode"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The name of an animation.",
                      "name": "name",
                      "type": "string"
                    },
                    {
                      "description": "The index of a channel in the animation.",
                      "name": "channel",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The smooth mode of the keyframes.",
                      "name": "smooth",
                      "type": "SmoothMode"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the number of blend shapes in the model.",
              "key": "ModelData:getBlendShapeCount",
              "module": "lovr.data",
              "name": "getBlendShapeCount",
              "related": [
                "ModelData:getBlendShapeName",
                "Model:getBlendShapeCount",
                "ModelData"
              ],
              "summary": "Get the number of blend shapes in the model.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The number of blend shapes in the model.",
                      "name": "count",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the name of a blend shape in the model.",
              "key": "ModelData:getBlendShapeName",
              "module": "lovr.data",
              "name": "getBlendShapeName",
              "notes": "This function will throw an error if the blend shape index is invalid.",
              "related": [
                "ModelData:getBlendShapeCount",
                "Model:getBlendShapeName",
                "ModelData"
              ],
              "summary": "Get the name of a blend shape in the model.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of a blend shape.",
                      "name": "index",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The name of the blend shape.",
                      "name": "name",
                      "type": "string"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns one of the Blobs in the model, by index.",
              "key": "ModelData:getBlob",
              "module": "lovr.data",
              "name": "getBlob",
              "related": [
                "ModelData:getBlobCount",
                "ModelData:getImage",
                "ModelData"
              ],
              "summary": "Get a Blob in the model.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of the Blob to get.",
                      "name": "index",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The Blob object.",
                      "name": "blob",
                      "type": "Blob"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the number of Blobs in the model.",
              "key": "ModelData:getBlobCount",
              "module": "lovr.data",
              "name": "getBlobCount",
              "related": [
                "ModelData:getBlob",
                "ModelData:getImageCount",
                "ModelData"
              ],
              "summary": "Get the number of Blobs stored in the model.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The number of Blobs in the model.",
                      "name": "count",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the 6 values of the model\u0027s axis-aligned bounding box.",
              "key": "ModelData:getBoundingBox",
              "module": "lovr.data",
              "name": "getBoundingBox",
              "related": [
                "ModelData:getWidth",
                "ModelData:getHeight",
                "ModelData:getDepth",
                "ModelData:getDimensions",
                "ModelData:getCenter",
                "ModelData:getBoundingSphere",
                "Model:getBoundingBox",
                "ModelData"
              ],
              "summary": "Get the bounding box of the model.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The minimum x coordinate of the vertices in the model.",
                      "name": "minx",
                      "type": "number"
                    },
                    {
                      "description": "The maximum x coordinate of the vertices in the model.",
                      "name": "maxx",
                      "type": "number"
                    },
                    {
                      "description": "The minimum y coordinate of the vertices in the model.",
                      "name": "miny",
                      "type": "number"
                    },
                    {
                      "description": "The maximum y coordinate of the vertices in the model.",
                      "name": "maxy",
                      "type": "number"
                    },
                    {
                      "description": "The minimum z coordinate of the vertices in the model.",
                      "name": "minz",
                      "type": "number"
                    },
                    {
                      "description": "The maximum z coordinate of the vertices in the model.",
                      "name": "maxz",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns a sphere approximately enclosing the vertices in the model.",
              "key": "ModelData:getBoundingSphere",
              "module": "lovr.data",
              "name": "getBoundingSphere",
              "related": [
                "ModelData:getWidth",
                "ModelData:getHeight",
                "ModelData:getDepth",
                "ModelData:getDimensions",
                "ModelData:getCenter",
                "ModelData:getBoundingBox",
                "Model:getBoundingSphere",
                "ModelData"
              ],
              "summary": "Get the bounding sphere of the model.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The x coordinate of the position of the sphere.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate of the position of the sphere.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z coordinate of the position of the sphere.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The radius of the bounding sphere.",
                      "name": "radius",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the center of the model\u0027s axis-aligned bounding box, relative to the model\u0027s origin.",
              "key": "ModelData:getCenter",
              "module": "lovr.data",
              "name": "getCenter",
              "related": [
                "ModelData:getWidth",
                "ModelData:getHeight",
                "ModelData:getDepth",
                "ModelData:getDimensions",
                "ModelData:getBoundingBox",
                "Model:getCenter",
                "ModelData"
              ],
              "summary": "Get the center of the model\u0027s bounding box.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The x offset of the center of the bounding box.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y offset of the center of the bounding box.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z offset of the center of the bounding box.",
                      "name": "z",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the depth of the model, computed from its axis-aligned bounding box.",
              "key": "ModelData:getDepth",
              "module": "lovr.data",
              "name": "getDepth",
              "related": [
                "ModelData:getWidth",
                "ModelData:getHeight",
                "ModelData:getDimensions",
                "ModelData:getCenter",
                "ModelData:getBoundingBox",
                "Model:getDepth",
                "ModelData"
              ],
              "summary": "Get the depth of the model.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The depth of the model.",
                      "name": "depth",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the width, height, and depth of the model, computed from its axis-aligned bounding box.",
              "key": "ModelData:getDimensions",
              "module": "lovr.data",
              "name": "getDimensions",
              "related": [
                "ModelData:getWidth",
                "ModelData:getHeight",
                "ModelData:getDepth",
                "ModelData:getCenter",
                "ModelData:getBoundingBox",
                "Model:getDimensions",
                "ModelData"
              ],
              "summary": "Get the dimensions of the model.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The width of the model.",
                      "name": "width",
                      "type": "number"
                    },
                    {
                      "description": "The height of the model.",
                      "name": "height",
                      "type": "number"
                    },
                    {
                      "description": "The depth of the model.",
                      "name": "depth",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the height of the model, computed from its axis-aligned bounding box.",
              "key": "ModelData:getHeight",
              "module": "lovr.data",
              "name": "getHeight",
              "related": [
                "ModelData:getWidth",
                "ModelData:getDepth",
                "ModelData:getDimensions",
                "ModelData:getCenter",
                "ModelData:getBoundingBox",
                "Model:getHeight",
                "ModelData"
              ],
              "summary": "Get the height of the model.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The height of the model.",
                      "name": "height",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns one of the Images in the model, by index.",
              "key": "ModelData:getImage",
              "module": "lovr.data",
              "name": "getImage",
              "related": [
                "ModelData:getImageCount",
                "ModelData:getBlob",
                "ModelData"
              ],
              "summary": "Get an Image in the model.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of the Image to get.",
                      "name": "index",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The Image object.",
                      "name": "image",
                      "type": "Image"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the number of Images in the model.",
              "key": "ModelData:getImageCount",
              "module": "lovr.data",
              "name": "getImageCount",
              "related": [
                "ModelData:getImage",
                "ModelData:getBlobCount",
                "ModelData"
              ],
              "summary": "Get the number of Images stored in the model.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The number of Images in the model.",
                      "name": "count",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns a table with all of the properties of a material.",
              "key": "ModelData:getMaterial",
              "module": "lovr.data",
              "name": "getMaterial",
              "notes": "All images are optional and may be `nil`.",
              "related": [
                "ModelData:getMaterialCount",
                "ModelData:getMeshMaterial",
                "lovr.graphics.newMaterial",
                "Model:getMaterial",
                "ModelData"
              ],
              "summary": "Get the material properties for a material in the model.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of a material.",
                      "name": "index",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The material properties.",
                      "name": "properties",
                      "table": [
                        {
                          "description": "The color of the material.  The table contains the `r`, `g`, `b`, and `a` components of the color, from 0 to 1.",
                          "name": "color",
                          "type": "table"
                        },
                        {
                          "description": "The glow color of the material (sometimes called emissive).  The table contains the `r`, `g`, and `b` components of the color from 0 to 1, and a fourth number indicating the strength of the glow.",
                          "name": "glow",
                          "type": "table"
                        },
                        {
                          "description": "A table with 2 numbers indicating an offset to apply to UVs.",
                          "name": "uvShift",
                          "type": "table"
                        },
                        {
                          "description": "A table with 2 numbers indicating a scale to apply to UVs.  By default, shaders apply the UV scale before the UV offset.",
                          "name": "uvScale",
                          "type": "table"
                        },
                        {
                          "description": "The metalness parameter of the material.  This is typically 0 or 1.  By default, shaders multiply this property with the value from the metalness texture (when present) to get the final metalness used for shading.",
                          "name": "metalness",
                          "type": "number"
                        },
                        {
                          "description": "The roughness parameter of the material.  By default, shaders multiply this property with the value from the roughness texture (when present) to get the final roughness used for shading.",
                          "name": "roughness",
                          "type": "number"
                        },
                        {
                          "description": "The clearcoat parameter of the material.",
                          "name": "clearcoat",
                          "type": "number"
                        },
                        {
                          "description": "The roughness of the clearcoat layer.",
                          "name": "clearcoatRoughness",
                          "type": "number"
                        },
                        {
                          "description": "A number multiplied by the value from the ambient occlusion texture to control how strong the occlusion effect is.",
                          "name": "occlusionStrength",
                          "type": "number"
                        },
                        {
                          "description": "A number multiplied by the value from the normal texture to control how strong the normal mapping effect is.",
                          "name": "normalScale",
                          "type": "number"
                        },
                        {
                          "description": "If a pixel has an alpha value less than the alpha cutoff, it will be discarded, which prevents it from occluding things behind it.  This is sometimes called \"holepunch\" or \"cutout\" alpha.  It\u0027s useful for textures with transparency.",
                          "name": "alphaCutoff",
                          "type": "number"
                        },
                        {
                          "description": "The index of the Image used for the color texture.",
                          "name": "texture",
                          "type": "number"
                        },
                        {
                          "description": "The index of the Image used for the glow texture.",
                          "name": "glowTexture",
                          "type": "number"
                        },
                        {
                          "description": "The index of the Image used for the ambient occlusion texture.  The red channel of the texture is used for ambient occlusion, allowing multiple parameters to use the same texture.",
                          "name": "occlusionTexture",
                          "type": "number"
                        },
                        {
                          "description": "The index of the Image used for the metalness texture.  The blue channel of the texture is used for metalness, allowing multiple parameters to use the same texture.",
                          "name": "metalnessTexture",
                          "type": "number"
                        },
                        {
                          "description": "The index of the Image to use for the roughness texture.  The green channel of the texture is used for roughness, allowing multiple parameters to use the same texture.",
                          "name": "roughnessTexture",
                          "type": "number"
                        },
                        {
                          "description": "The index of the Image to use for the clearcoat texture.  The red channel of the texture is used for the clearcoat parameter, allowing multiple parameters to use the same texture.",
                          "name": "clearcoatTexture",
                          "type": "number"
                        },
                        {
                          "description": "The index of the Image to use for the normal map.",
                          "name": "normalTexture",
                          "type": "number"
                        }
                      ],
                      "type": "table"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The name of a material.",
                      "name": "name",
                      "type": "string"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The material properties.",
                      "name": "properties",
                      "table": [
                        {
                          "description": "The color of the material.  The table contains the `r`, `g`, `b`, and `a` components of the color, from 0 to 1.",
                          "name": "color",
                          "type": "table"
                        },
                        {
                          "description": "The glow color of the material (sometimes called emissive).  The table contains the `r`, `g`, and `b` components of the color from 0 to 1, and a fourth number indicating the strength of the glow.",
                          "name": "glow",
                          "type": "table"
                        },
                        {
                          "description": "A table with 2 numbers indicating an offset to apply to UVs.",
                          "name": "uvShift",
                          "type": "table"
                        },
                        {
                          "description": "A table with 2 numbers indicating a scale to apply to UVs.  By default, shaders apply the UV scale before the UV offset.",
                          "name": "uvScale",
                          "type": "table"
                        },
                        {
                          "description": "The metalness parameter of the material.  This is typically 0 or 1.  By default, shaders multiply this property with the value from the metalness texture (when present) to get the final metalness used for shading.",
                          "name": "metalness",
                          "type": "number"
                        },
                        {
                          "description": "The roughness parameter of the material.  By default, shaders multiply this property with the value from the roughness texture (when present) to get the final roughness used for shading.",
                          "name": "roughness",
                          "type": "number"
                        },
                        {
                          "description": "The clearcoat parameter of the material.",
                          "name": "clearcoat",
                          "type": "number"
                        },
                        {
                          "description": "The roughness of the clearcoat layer.",
                          "name": "clearcoatRoughness",
                          "type": "number"
                        },
                        {
                          "description": "A number multiplied by the value from the ambient occlusion texture to control how strong the occlusion effect is.",
                          "name": "occlusionStrength",
                          "type": "number"
                        },
                        {
                          "description": "A number multiplied by the value from the normal texture to control how strong the normal mapping effect is.",
                          "name": "normalScale",
                          "type": "number"
                        },
                        {
                          "description": "If a pixel has an alpha value less than the alpha cutoff, it will be discarded, which prevents it from occluding things behind it.  This is sometimes called \"holepunch\" or \"cutout\" alpha.  It\u0027s useful for textures with transparency.",
                          "name": "alphaCutoff",
                          "type": "number"
                        },
                        {
                          "description": "The index of the Image used for the color texture.",
                          "name": "texture",
                          "type": "number"
                        },
                        {
                          "description": "The index of the Image used for the glow texture.",
                          "name": "glowTexture",
                          "type": "number"
                        },
                        {
                          "description": "The index of the Image used for the ambient occlusion texture.  The red channel of the texture is used for ambient occlusion, allowing multiple parameters to use the same texture.",
                          "name": "occlusionTexture",
                          "type": "number"
                        },
                        {
                          "description": "The index of the Image used for the metalness texture.  The blue channel of the texture is used for metalness, allowing multiple parameters to use the same texture.",
                          "name": "metalnessTexture",
                          "type": "number"
                        },
                        {
                          "description": "The index of the Image to use for the roughness texture.  The green channel of the texture is used for roughness, allowing multiple parameters to use the same texture.",
                          "name": "roughnessTexture",
                          "type": "number"
                        },
                        {
                          "description": "The index of the Image to use for the clearcoat texture.  The red channel of the texture is used for the clearcoat parameter, allowing multiple parameters to use the same texture.",
                          "name": "clearcoatTexture",
                          "type": "number"
                        },
                        {
                          "description": "The index of the Image to use for the normal map.",
                          "name": "normalTexture",
                          "type": "number"
                        }
                      ],
                      "type": "table"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the number of materials in the model.",
              "key": "ModelData:getMaterialCount",
              "module": "lovr.data",
              "name": "getMaterialCount",
              "related": [
                "ModelData:getMaterialName",
                "ModelData:getMeshMaterial",
                "ModelData:getMaterial",
                "Model:getMaterialCount",
                "ModelData"
              ],
              "summary": "Get the number of materials in the model.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The number of materials in the model.",
                      "name": "count",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the name of a material in the model.",
              "key": "ModelData:getMaterialName",
              "module": "lovr.data",
              "name": "getMaterialName",
              "related": [
                "ModelData:getMaterialCount",
                "ModelData:getMeshMaterial",
                "ModelData:getMaterial",
                "Model:getMaterialName",
                "ModelData"
              ],
              "summary": "Get the name of a material in the model.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of a material.",
                      "name": "index",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The name of the material, or nil if the material does not have a name.",
                      "name": "name",
                      "type": "string"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the number of meshes in the model.",
              "key": "ModelData:getMeshCount",
              "module": "lovr.data",
              "name": "getMeshCount",
              "related": ["ModelData:getNodeMeshes", "ModelData"],
              "summary": "Get the number of meshes in the model.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The number of meshes in the model.",
                      "name": "count",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the draw mode of a mesh.  This controls how its vertices are connected together (points, lines, or triangles).",
              "key": "ModelData:getMeshDrawMode",
              "module": "lovr.data",
              "name": "getMeshDrawMode",
              "related": ["ModelData"],
              "summary": "Get the draw mode of a mesh.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of a mesh.",
                      "name": "mesh",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The draw mode of the mesh.",
                      "name": "mode",
                      "type": "ModelDrawMode"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns one of the vertex indices in a mesh.  If a mesh has vertex indices, they define the order and connectivity of the vertices in the mesh, allowing a vertex to be reused multiple times without duplicating its data.",
              "key": "ModelData:getMeshIndex",
              "module": "lovr.data",
              "name": "getMeshIndex",
              "related": [
                "ModelData:getMeshIndexFormat",
                "ModelData:getMeshIndexCount",
                "ModelData:getMeshVertex",
                "ModelData:getTriangles",
                "ModelData"
              ],
              "summary": "Get one of the vertex indices in a mesh.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of a mesh to get the vertex from.",
                      "name": "mesh",
                      "type": "number"
                    },
                    {
                      "description": "The index of a vertex index in the mesh to retrieve.",
                      "name": "index",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The vertex index.  Like all indices in Lua, this is 1-indexed.",
                      "name": "vertexindex",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the number of vertex indices in a mesh.  Vertex indices allow for vertices to be reused when defining triangles.",
              "key": "ModelData:getMeshIndexCount",
              "module": "lovr.data",
              "name": "getMeshIndexCount",
              "notes": "This may return zero if the mesh does not use indices.",
              "related": ["ModelData"],
              "summary": "Get the number of vertex indices in a mesh.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of a mesh.",
                      "name": "mesh",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The number of vertex indices in the mesh.",
                      "name": "count",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the data format of vertex indices in a mesh.  If a mesh doesn\u0027t use vertex indices, this function returns nil.",
              "key": "ModelData:getMeshIndexFormat",
              "module": "lovr.data",
              "name": "getMeshIndexFormat",
              "related": ["ModelData:getMeshVertexFormat", "ModelData"],
              "summary": "Get the data format of vertex indices in a mesh.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of a mesh.",
                      "name": "mesh",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The data type of each vertex index (always u16 or u32).",
                      "name": "type",
                      "type": "AttributeType"
                    },
                    {
                      "description": "The index of a Blob in the mesh where the binary data is stored.",
                      "name": "blob",
                      "type": "number"
                    },
                    {
                      "description": "A byte offset into the Blob\u0027s data where the index data starts.",
                      "name": "offset",
                      "type": "number"
                    },
                    {
                      "description": "The number of bytes between subsequent vertex indices.  Indices are always tightly packed, so this will always be 2 or 4 depending on the data type.",
                      "name": "stride",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the index of the material applied to a mesh.",
              "key": "ModelData:getMeshMaterial",
              "module": "lovr.data",
              "name": "getMeshMaterial",
              "related": ["ModelData"],
              "summary": "Get the index of the material applied to a mesh.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of a mesh.",
                      "name": "mesh",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The index of the material applied to the mesh, or nil if the mesh does not have a material.",
                      "name": "material",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the data for a single vertex in a mesh.  The data returned depends on the vertex format of a mesh, which is given by `ModelData:getMeshVertexFormat`.",
              "key": "ModelData:getMeshVertex",
              "module": "lovr.data",
              "name": "getMeshVertex",
              "related": [
                "ModelData:getMeshVertexFormat",
                "ModelData:getMeshVertexCount",
                "ModelData:getMeshIndex",
                "ModelData:getTriangles",
                "ModelData"
              ],
              "summary": "Get the data for a single vertex in a mesh.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of a mesh to get the vertex from.",
                      "name": "mesh",
                      "type": "number"
                    },
                    {
                      "description": "The index of a vertex in the mesh to retrieve.",
                      "name": "vertex",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The data for all of the attributes of the vertex.",
                      "name": "...",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the number of vertices in a mesh.",
              "key": "ModelData:getMeshVertexCount",
              "module": "lovr.data",
              "name": "getMeshVertexCount",
              "related": ["ModelData:getMeshIndexCount", "ModelData"],
              "summary": "Get the number of vertices in a mesh.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of a mesh.",
                      "name": "mesh",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The number of vertices in the mesh.",
                      "name": "count",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the vertex format of a mesh.  The vertex format defines the properties associated with each vertex (position, color, etc.), including their types and binary data layout.",
              "key": "ModelData:getMeshVertexFormat",
              "module": "lovr.data",
              "name": "getMeshVertexFormat",
              "notes": "The format is given as a table of vertex attributes.  Each attribute is a table containing the following:\n\n    { name, type, components, blob, offset, stride }\n\n- The `name` will be a `DefaultAttribute`.\n- The `type` will be an `AttributeType`.\n- The `component` count will be 1-4.\n- The `blob` is an index of one of the Blobs in the model (see `ModelData:getBlob`).\n- The `offset` is a byte offset from the start of the Blob where the attribute\u0027s data starts.\n- The `stride` is the number of bytes between consecutive values.",
              "related": ["ModelData:getMeshIndexFormat", "ModelData"],
              "summary": "Get the vertex format of a mesh.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of a mesh.",
                      "name": "mesh",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The vertex format of the mesh.",
                      "name": "format",
                      "type": "table"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns extra information stored in the model file.  Currently this is only implemented for glTF models and returns the JSON string from the glTF or glb file.  The metadata can be used to get application-specific data or add support for glTF extensions not supported by L\u00d6VR.",
              "key": "ModelData:getMetadata",
              "module": "lovr.data",
              "name": "getMetadata",
              "related": ["Model:getMetadata", "ModelData"],
              "summary": "Get extra information from the model file.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The metadata from the model file.",
                      "name": "metadata",
                      "type": "string"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Given a parent node, this function returns a table with the indices of its children.",
              "key": "ModelData:getNodeChildren",
              "module": "lovr.data",
              "name": "getNodeChildren",
              "notes": "If the node does not have any children, this function returns an empty table.",
              "related": [
                "ModelData:getNodeParent",
                "ModelData:getRootNode",
                "Model:getNodeChildren",
                "ModelData"
              ],
              "summary": "Get the children of a node.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of the parent node.",
                      "name": "index",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "A table containing a node index for each child of the node.",
                      "name": "children",
                      "type": "table"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The name of the parent node.",
                      "name": "name",
                      "type": "string"
                    }
                  ],
                  "returns": [
                    {
                      "description": "A table containing a node index for each child of the node.",
                      "name": "children",
                      "type": "table"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the number of nodes in the model.",
              "key": "ModelData:getNodeCount",
              "module": "lovr.data",
              "name": "getNodeCount",
              "related": ["Model:getNodeCount", "ModelData"],
              "summary": "Get the number of nodes in the model.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The number of nodes in the model.",
                      "name": "count",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns a table of mesh indices attached to a node.  Meshes define the geometry and materials of a model, as opposed to the nodes which define the transforms and hierarchy.  A node can have multiple meshes, and meshes can be reused in multiple nodes.",
              "key": "ModelData:getNodeMeshes",
              "module": "lovr.data",
              "name": "getNodeMeshes",
              "related": ["ModelData:getMeshCount", "ModelData"],
              "summary": "Get the indices of meshes attached to a node.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of the node.",
                      "name": "index",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "A table with the node\u0027s mesh indices.",
                      "name": "meshes",
                      "type": "table"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The name of the node.",
                      "name": "name",
                      "type": "string"
                    }
                  ],
                  "returns": [
                    {
                      "description": "A table with the node\u0027s mesh indices.",
                      "name": "meshes",
                      "type": "table"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the name of a node.",
              "key": "ModelData:getNodeName",
              "module": "lovr.data",
              "name": "getNodeName",
              "notes": "If the node does not have a name, this function returns `nil`.",
              "related": ["Model:getNodeName", "ModelData"],
              "summary": "Get the name of a node.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of the node.",
                      "name": "index",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The name of the node.",
                      "name": "name",
                      "type": "string"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns local orientation of a node, relative to its parent.",
              "key": "ModelData:getNodeOrientation",
              "module": "lovr.data",
              "name": "getNodeOrientation",
              "related": [
                "ModelData:getNodePosition",
                "ModelData:getNodeScale",
                "ModelData:getNodePose",
                "ModelData:getNodeTransform",
                "ModelData"
              ],
              "summary": "Get the local orientation of a node.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of the node.",
                      "name": "index",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The number of radians the node is rotated around its axis of rotation.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The name of the node.",
                      "name": "name",
                      "type": "string"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The number of radians the node is rotated around its axis of rotation.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Given a child node, this function returns the index of its parent.",
              "key": "ModelData:getNodeParent",
              "module": "lovr.data",
              "name": "getNodeParent",
              "related": [
                "ModelData:getNodeChildren",
                "ModelData:getRootNode",
                "Model:getNodeParent",
                "ModelData"
              ],
              "summary": "Get the parent of a node.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of the child node.",
                      "name": "index",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The index of the parent.",
                      "name": "parent",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The name of the child node.",
                      "name": "name",
                      "type": "string"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The index of the parent.",
                      "name": "parent",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns local pose (position and orientation) of a node, relative to its parent.",
              "key": "ModelData:getNodePose",
              "module": "lovr.data",
              "name": "getNodePose",
              "related": [
                "ModelData:getNodePosition",
                "ModelData:getNodeOrientation",
                "ModelData:getNodeScale",
                "ModelData:getNodeTransform",
                "ModelData"
              ],
              "summary": "Get the local pose of a node.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of the node.",
                      "name": "index",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The x coordinate.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z coordinate.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The number of radians the node is rotated around its axis of rotation.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The name of the node.",
                      "name": "name",
                      "type": "string"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The x coordinate.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z coordinate.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The number of radians the node is rotated around its axis of rotation.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns local position of a node, relative to its parent.",
              "key": "ModelData:getNodePosition",
              "module": "lovr.data",
              "name": "getNodePosition",
              "related": [
                "ModelData:getNodeOrientation",
                "ModelData:getNodeScale",
                "ModelData:getNodePose",
                "ModelData:getNodeTransform",
                "ModelData"
              ],
              "summary": "Get the local position of a node.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of the node.",
                      "name": "index",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The x coordinate.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z coordinate.",
                      "name": "z",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The name of the node.",
                      "name": "name",
                      "type": "string"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The x coordinate.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z coordinate.",
                      "name": "z",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns local scale of a node, relative to its parent.",
              "key": "ModelData:getNodeScale",
              "module": "lovr.data",
              "name": "getNodeScale",
              "related": [
                "ModelData:getNodePosition",
                "ModelData:getNodeOrientation",
                "ModelData:getNodePose",
                "ModelData:getNodeTransform",
                "ModelData"
              ],
              "summary": "Get the local scale of a node.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of the node.",
                      "name": "index",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The x scale.",
                      "name": "sx",
                      "type": "number"
                    },
                    {
                      "description": "The y scale.",
                      "name": "sy",
                      "type": "number"
                    },
                    {
                      "description": "The z scale.",
                      "name": "sz",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The name of the node.",
                      "name": "name",
                      "type": "string"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The x scale.",
                      "name": "sx",
                      "type": "number"
                    },
                    {
                      "description": "The y scale.",
                      "name": "sy",
                      "type": "number"
                    },
                    {
                      "description": "The z scale.",
                      "name": "sz",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the index of the skin used by a node.  Skins are collections of joints used for skeletal animation.  A model can have multiple skins, and each node can use at most one skin to drive the animation of its meshes.",
              "key": "ModelData:getNodeSkin",
              "module": "lovr.data",
              "name": "getNodeSkin",
              "related": ["ModelData:getSkinCount", "ModelData"],
              "summary": "Get the index of the skin used by a node.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of the node.",
                      "name": "index",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The index of the node\u0027s skin, or nil if the node isn\u0027t skeletally animated.",
                      "name": "skin",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The name of the node.",
                      "name": "name",
                      "type": "string"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The index of the node\u0027s skin, or nil if the node isn\u0027t skeletally animated.",
                      "name": "skin",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns local transform (position, orientation, and scale) of a node, relative to its parent.",
              "key": "ModelData:getNodeTransform",
              "module": "lovr.data",
              "name": "getNodeTransform",
              "notes": "For best results when animating, it\u0027s recommended to keep the 3 components of the scale the same.",
              "related": [
                "ModelData:getNodePosition",
                "ModelData:getNodeOrientation",
                "ModelData:getNodeScale",
                "ModelData:getNodePose",
                "ModelData"
              ],
              "summary": "Get the local transform of a node.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of the node.",
                      "name": "index",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The x coordinate.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z coordinate.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The x scale.",
                      "name": "sx",
                      "type": "number"
                    },
                    {
                      "description": "The y scale.",
                      "name": "sy",
                      "type": "number"
                    },
                    {
                      "description": "The z scale.",
                      "name": "sz",
                      "type": "number"
                    },
                    {
                      "description": "The number of radians the node is rotated around its axis of rotation.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The name of the node.",
                      "name": "name",
                      "type": "string"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The x coordinate.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z coordinate.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The x scale.",
                      "name": "sx",
                      "type": "number"
                    },
                    {
                      "description": "The y scale.",
                      "name": "sy",
                      "type": "number"
                    },
                    {
                      "description": "The z scale.",
                      "name": "sz",
                      "type": "number"
                    },
                    {
                      "description": "The number of radians the node is rotated around its axis of rotation.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the index of the model\u0027s root node.",
              "key": "ModelData:getRootNode",
              "module": "lovr.data",
              "name": "getRootNode",
              "related": [
                "ModelData:getNodeCount",
                "ModelData:getNodeParent",
                "Model:getRootNode",
                "ModelData"
              ],
              "summary": "Get the index of the root node.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The index of the root node.",
                      "name": "root",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the number of skins in the model.  A skin is a collection of joints targeted by an animation.",
              "key": "ModelData:getSkinCount",
              "module": "lovr.data",
              "name": "getSkinCount",
              "notes": "There is currently a maximum of 256 skins.",
              "related": ["Model:hasJoints", "ModelData"],
              "summary": "Get the number of skins in the model.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The number of skins in the model.",
                      "name": "count",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the inverse bind matrix for a joint in the skin.",
              "key": "ModelData:getSkinInverseBindMatrix",
              "module": "lovr.data",
              "name": "getSkinInverseBindMatrix",
              "related": ["ModelData"],
              "summary": "Get the inverse bind matrix for a joint in the skin.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of a skin.",
                      "name": "skin",
                      "type": "number"
                    },
                    {
                      "description": "The index of a joint in the skin.",
                      "name": "joint",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The 16 components of the 4x4 inverse bind matrix, in column-major order.",
                      "name": "...",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns a table with the node indices of the joints in a skin.",
              "key": "ModelData:getSkinJoints",
              "module": "lovr.data",
              "name": "getSkinJoints",
              "related": ["ModelData"],
              "summary": "Get the joints in a skin.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of a skin.",
                      "name": "skin",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The joints in the skin.",
                      "name": "joints",
                      "type": "table"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the total number of triangles in the model.  This count includes meshes that are attached to multiple nodes, and the count corresponds to the triangles returned by `ModelData:getTriangles`.",
              "key": "ModelData:getTriangleCount",
              "module": "lovr.data",
              "name": "getTriangleCount",
              "related": [
                "ModelData:getTriangles",
                "ModelData:getVertexCount",
                "Model:getTriangleCount",
                "ModelData"
              ],
              "summary": "Get the total number of triangles in the model.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The total number of triangles in the model.",
                      "name": "count",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the data for all triangles in the model.  There are a few differences between this and the mesh-specific functions like `ModelData:getMeshVertex` and `ModelData:getMeshIndex`:\n\n- Only vertex positions are returned, not other vertex attributes.\n- Positions are relative to the origin of the whole model, instead of local to a node.\n- If a mesh is attached to more than one node, its vertices will be in the table multiple times.\n- Vertex indices will be relative to the whole triangle list instead of a mesh.",
              "key": "ModelData:getTriangles",
              "module": "lovr.data",
              "name": "getTriangles",
              "notes": "After this function is called on a ModelData once, the result is cached.",
              "related": [
                "ModelData:getTriangleCount",
                "ModelData:getVertexCount",
                "Model:getTriangles",
                "ModelData"
              ],
              "summary": "Get all the triangles in the model.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The triangle vertex positions, returned as a flat (non-nested) table of numbers.  The position of each vertex is given as an x, y, and z coordinate.",
                      "name": "vertices",
                      "type": "table"
                    },
                    {
                      "description": "A list of numbers representing how to connect the vertices into triangles.  Each number is a 1-based index into the `vertices` table, and every 3 indices form a triangle.",
                      "name": "indices",
                      "type": "table"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the total vertex count of a model.  This count includes meshes that are attached to multiple nodes, and the count corresponds to the vertices returned by `ModelData:getTriangles`.",
              "key": "ModelData:getVertexCount",
              "module": "lovr.data",
              "name": "getVertexCount",
              "related": [
                "ModelData:getTriangles",
                "ModelData:getTriangleCount",
                "Model:getVertexCount",
                "ModelData"
              ],
              "summary": "Get the total vertex count of the model.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The total number of vertices in the model.",
                      "name": "count",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the width of the model, computed from its axis-aligned bounding box.",
              "key": "ModelData:getWidth",
              "module": "lovr.data",
              "name": "getWidth",
              "related": [
                "ModelData:getHeight",
                "ModelData:getDepth",
                "ModelData:getDimensions",
                "ModelData:getCenter",
                "ModelData:getBoundingBox",
                "Model:getWidth",
                "ModelData"
              ],
              "summary": "Get the width of the model.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The width of the model.",
                      "name": "width",
                      "type": "number"
                    }
                  ]
                }
              ]
            }
          ],
          "module": "lovr.data",
          "name": "ModelData",
          "related": ["lovr.data"],
          "summary": "An object that loads and stores data for 3D models."
        },
        {
          "constructors": ["lovr.data.newRasterizer"],
          "description": "A Rasterizer is an object that parses a TTF file, decoding and rendering glyphs from it.\n\nUsually you can just use `Font` objects.",
          "key": "Rasterizer",
          "methods": [
            {
              "description": "Returns the advance metric for a glyph, in pixels.  The advance is the horizontal distance to advance the cursor after rendering the glyph.",
              "key": "Rasterizer:getAdvance",
              "module": "lovr.data",
              "name": "getAdvance",
              "related": ["Rasterizer"],
              "summary": "Get the advance of a glyph.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "A character.",
                      "name": "character",
                      "type": "string"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The advance of the glyph, in pixels.",
                      "name": "advance",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A codepoint.",
                      "name": "codepoint",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The advance of the glyph, in pixels.",
                      "name": "advance",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the ascent metric of the font, in pixels.  The ascent represents how far any glyph of the font ascends above the baseline.",
              "key": "Rasterizer:getAscent",
              "module": "lovr.data",
              "name": "getAscent",
              "related": [
                "Rasterizer:getDescent",
                "Font:getAscent",
                "Rasterizer"
              ],
              "summary": "Get the ascent of the font.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The ascent of the font, in pixels.",
                      "name": "ascent",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the bearing metric for a glyph, in pixels.  The bearing is the horizontal distance from the cursor to the edge of the glyph.",
              "key": "Rasterizer:getBearing",
              "module": "lovr.data",
              "name": "getBearing",
              "related": ["Rasterizer"],
              "summary": "Get the bearing of a glyph.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "A character.",
                      "name": "character",
                      "type": "string"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The bearing of the glyph, in pixels.",
                      "name": "bearing",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A codepoint.",
                      "name": "codepoint",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The bearing of the glyph, in pixels.",
                      "name": "bearing",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the bounding box of a glyph, or the bounding box surrounding all glyphs.  Note that font coordinates use a cartesian \"y up\" coordinate system.",
              "key": "Rasterizer:getBoundingBox",
              "module": "lovr.data",
              "name": "getBoundingBox",
              "related": [
                "Rasterizer:getWidth",
                "Rasterizer:getHeight",
                "Rasterizer:getDimensions",
                "Rasterizer"
              ],
              "summary": "Get the bounding box of a glyph, or the font.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "A character.",
                      "name": "character",
                      "type": "string"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The left edge of the bounding box, in pixels.",
                      "name": "x1",
                      "type": "number"
                    },
                    {
                      "description": "The bottom edge of the bounding box, in pixels.",
                      "name": "y1",
                      "type": "number"
                    },
                    {
                      "description": "The right edge of the bounding box, in pixels.",
                      "name": "x2",
                      "type": "number"
                    },
                    {
                      "description": "The top edge of the bounding box, in pixels.",
                      "name": "y2",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A codepoint.",
                      "name": "codepoint",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The left edge of the bounding box, in pixels.",
                      "name": "x1",
                      "type": "number"
                    },
                    {
                      "description": "The bottom edge of the bounding box, in pixels.",
                      "name": "y1",
                      "type": "number"
                    },
                    {
                      "description": "The right edge of the bounding box, in pixels.",
                      "name": "x2",
                      "type": "number"
                    },
                    {
                      "description": "The top edge of the bounding box, in pixels.",
                      "name": "y2",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The left edge of the bounding box, in pixels.",
                      "name": "x1",
                      "type": "number"
                    },
                    {
                      "description": "The bottom edge of the bounding box, in pixels.",
                      "name": "y1",
                      "type": "number"
                    },
                    {
                      "description": "The right edge of the bounding box, in pixels.",
                      "name": "x2",
                      "type": "number"
                    },
                    {
                      "description": "The top edge of the bounding box, in pixels.",
                      "name": "y2",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the bezier curve control points defining the shape of a glyph.",
              "key": "Rasterizer:getCurves",
              "module": "lovr.data",
              "name": "getCurves",
              "related": ["Curve", "Rasterizer:newImage", "Rasterizer"],
              "summary": "Get the bezier curves defining a glyph.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "A character.",
                      "name": "character",
                      "type": "string"
                    },
                    {
                      "description": "Whether the control points should be 3D or 2D.",
                      "name": "three",
                      "type": "boolean"
                    }
                  ],
                  "returns": [
                    {
                      "description": "A table of curves.  Each curve is a table of numbers representing the control points (2 for a line, 3 for a quadratic curve, etc.).",
                      "name": "curves",
                      "type": "table"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A codepoint.",
                      "name": "codepoint",
                      "type": "number"
                    },
                    {
                      "description": "Whether the control points should be 3D or 2D.",
                      "name": "three",
                      "type": "boolean"
                    }
                  ],
                  "returns": [
                    {
                      "description": "A table of curves.  Each curve is a table of numbers representing the control points (2 for a line, 3 for a quadratic curve, etc.).",
                      "name": "curves",
                      "type": "table"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the descent metric of the font, in pixels.  The descent represents how far any glyph of the font descends below the baseline.",
              "key": "Rasterizer:getDescent",
              "module": "lovr.data",
              "name": "getDescent",
              "related": [
                "Rasterizer:getAscent",
                "Font:getDescent",
                "Rasterizer"
              ],
              "summary": "Get the descent of the font.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The descent of the font, in pixels.",
                      "name": "descent",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the dimensions of a glyph, or the dimensions of any glyph.",
              "key": "Rasterizer:getDimensions",
              "module": "lovr.data",
              "name": "getDimensions",
              "related": [
                "Rasterizer:getWidth",
                "Rasterizer:getHeight",
                "Rasterizer:getBoundingBox",
                "Rasterizer"
              ],
              "summary": "Get the dimensions of a glyph, or the font.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "A character.",
                      "name": "character",
                      "type": "string"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The width, in pixels.",
                      "name": "width",
                      "type": "number"
                    },
                    {
                      "description": "The height, in pixels.",
                      "name": "height",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A codepoint.",
                      "name": "codepoint",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The width, in pixels.",
                      "name": "width",
                      "type": "number"
                    },
                    {
                      "description": "The height, in pixels.",
                      "name": "height",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The width, in pixels.",
                      "name": "width",
                      "type": "number"
                    },
                    {
                      "description": "The height, in pixels.",
                      "name": "height",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the size of the font, in pixels.  This is the size the rasterizer was created with, and defines the size of images it rasterizes.",
              "key": "Rasterizer:getFontSize",
              "module": "lovr.data",
              "name": "getFontSize",
              "related": ["Rasterizer:getHeight", "Rasterizer"],
              "summary": "Get the size of the font.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The font size, in pixels.",
                      "name": "size",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the number of glyphs stored in the font file.",
              "key": "Rasterizer:getGlyphCount",
              "module": "lovr.data",
              "name": "getGlyphCount",
              "related": ["Rasterizer:hasGlyphs", "Rasterizer"],
              "summary": "Get the number of glyphs stored in the font file.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The number of glyphs stored in the font file.",
                      "name": "count",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the height of a glyph, or the maximum height of any glyph.",
              "key": "Rasterizer:getHeight",
              "module": "lovr.data",
              "name": "getHeight",
              "related": [
                "Rasterizer:getWidth",
                "Rasterizer:getDimensions",
                "Rasterizer:getBoundingBox",
                "Rasterizer"
              ],
              "summary": "Get the height of a glyph, or the font.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "A character.",
                      "name": "character",
                      "type": "string"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The height, in pixels.",
                      "name": "height",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A codepoint.",
                      "name": "codepoint",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The height, in pixels.",
                      "name": "height",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The height, in pixels.",
                      "name": "height",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the kerning between 2 glyphs, in pixels.  Kerning is a slight horizontal adjustment between 2 glyphs to improve the visual appearance.  It will often be negative.",
              "key": "Rasterizer:getKerning",
              "module": "lovr.data",
              "name": "getKerning",
              "related": ["Font:getKerning", "Rasterizer"],
              "summary": "Get the kerning between two glyphs.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The first character.",
                      "name": "first",
                      "type": "string"
                    },
                    {
                      "description": "The second character.",
                      "name": "second",
                      "type": "string"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The kerning between the two glyphs.",
                      "name": "keming",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The first codepoint.",
                      "name": "firstCodepoint",
                      "type": "number"
                    },
                    {
                      "description": "The second character.",
                      "name": "second",
                      "type": "string"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The kerning between the two glyphs.",
                      "name": "keming",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The first character.",
                      "name": "first",
                      "type": "string"
                    },
                    {
                      "description": "The second codepoint.",
                      "name": "secondCodepoint",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The kerning between the two glyphs.",
                      "name": "keming",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The first codepoint.",
                      "name": "firstCodepoint",
                      "type": "number"
                    },
                    {
                      "description": "The second codepoint.",
                      "name": "secondCodepoint",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The kerning between the two glyphs.",
                      "name": "keming",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the leading metric of the font, in pixels.  This is the full amount of space between lines.",
              "key": "Rasterizer:getLeading",
              "module": "lovr.data",
              "name": "getLeading",
              "related": [
                "Rasterizer:getAscent",
                "Rasterizer:getDescent",
                "Rasterizer"
              ],
              "summary": "Get the leading of the font.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The font leading, in pixels.",
                      "name": "leading",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the width of a glyph, or the maximum width of any glyph.",
              "key": "Rasterizer:getWidth",
              "module": "lovr.data",
              "name": "getWidth",
              "related": [
                "Rasterizer:getHeight",
                "Rasterizer:getDimensions",
                "Rasterizer:getBoundingBox",
                "Rasterizer"
              ],
              "summary": "Get the width of a glyph, or the font.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "A character.",
                      "name": "character",
                      "type": "string"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The width, in pixels.",
                      "name": "width",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A codepoint.",
                      "name": "codepoint",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The width, in pixels.",
                      "name": "width",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The width, in pixels.",
                      "name": "width",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns whether the Rasterizer can rasterize a set of glyphs.",
              "key": "Rasterizer:hasGlyphs",
              "module": "lovr.data",
              "name": "hasGlyphs",
              "related": ["Rasterizer:getGlyphCount", "Rasterizer"],
              "summary": "Get whether the Rasterizer can rasterize a set of glyphs.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "Strings (sets of characters) or numbers (character codes) to check for.",
                      "name": "...",
                      "type": "*"
                    }
                  ],
                  "returns": [
                    {
                      "description": "true if the Rasterizer can rasterize all of the supplied characters, false otherwise.",
                      "name": "hasGlyphs",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns an `Image` containing a rasterized glyph.",
              "key": "Rasterizer:newImage",
              "module": "lovr.data",
              "name": "newImage",
              "related": ["Rasterizer:getCurves", "Rasterizer"],
              "summary": "Get an Image of a rasterized glyph.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "A character.",
                      "name": "character",
                      "type": "string"
                    },
                    {
                      "default": "4.0",
                      "description": "The width of the distance field, for signed distance field rasterization.",
                      "name": "spread",
                      "type": "number"
                    },
                    {
                      "default": "spread \/ 2",
                      "description": "The number of pixels of padding to add at the edges of the image.",
                      "name": "padding",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The glyph image.  It will be in the `rgba32f` format.",
                      "name": "image",
                      "type": "Image"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A codepoint.",
                      "name": "codepoint",
                      "type": "number"
                    },
                    {
                      "default": "4.0",
                      "description": "The width of the distance field, for signed distance field rasterization.",
                      "name": "spread",
                      "type": "number"
                    },
                    {
                      "default": "spread \/ 2",
                      "description": "The number of pixels of padding to add at the edges of the image.",
                      "name": "padding",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The glyph image.  It will be in the `rgba32f` format.",
                      "name": "image",
                      "type": "Image"
                    }
                  ]
                }
              ]
            }
          ],
          "module": "lovr.data",
          "name": "Rasterizer",
          "related": ["lovr.data"],
          "summary": "An object that rasterizes glyphs from font files."
        },
        {
          "constructors": ["lovr.data.newSound"],
          "description": "A Sound stores the data for a sound.  The supported sound formats are OGG, WAV, and MP3.  Sounds cannot be played directly.  Instead, there are `Source` objects in `lovr.audio` that are used for audio playback.  All Source objects are backed by one of these Sounds, and multiple Sources can share a single Sound to reduce memory usage.\n\nMetadata\n---\n\nSounds hold a fixed number of frames.  Each frame contains one audio sample for each channel. The `SampleFormat` of the Sound is the data type used for each sample (floating point, integer, etc.).  The Sound has a `ChannelLayout`, representing the number of audio channels and how they map to speakers (mono, stereo, etc.).  The sample rate of the Sound indicates how many frames should be played per second.  The duration of the sound (in seconds) is the number of frames divided by the sample rate.\n\nCompression\n---\n\nSounds can be compressed.  Compressed sounds are stored compressed in memory and are decoded as they are played.  This uses a lot less memory but increases CPU usage during playback.  OGG and MP3 are compressed audio formats.  When creating a sound from a compressed format, there is an option to immediately decode it, storing it uncompressed in memory.  It can be a good idea to decode short sound effects, since they won\u0027t use very much memory even when uncompressed and it will improve CPU usage.  Compressed sounds can not be written to using `Sound:setFrames`.\n\nStreams\n---\n\nSounds can be created as a stream by passing `\u0027stream\u0027` as their contents when creating them. Audio frames can be written to the end of the stream, and read from the beginning.  This works well for situations where data is being generated in real time or streamed in from some other data source.\n\nSources can be backed by a stream and they\u0027ll just play whatever audio is pushed to the stream. The audio module also lets you use a stream as a \"sink\" for an audio device.  For playback devices, this works like loopback, so the mixed audio from all playing Sources will get written to the stream.  For capture devices, all the microphone input will get written to the stream. Conversion between sample formats, channel layouts, and sample rates will happen automatically.\n\nKeep in mind that streams can still only hold a fixed number of frames.  If too much data is written before it is read, older frames will start to get overwritten.  Similary, it\u0027s possible to read too much data without writing fast enough.\n\nAmbisonics\n---\n\nAmbisonic sounds can be imported from WAVs, but can not yet be played.  Sounds with a `ChannelLayout` of `ambisonic` are stored as first-order full-sphere ambisonics using the AmbiX format (ACN channel ordering and SN3D channel normalization).  The AMB format is supported for import and will automatically get converted to AmbiX.  See `lovr.data.newSound` for more info.",
          "key": "Sound",
          "methods": [
            {
              "description": "Returns a Blob containing the raw bytes of the Sound.",
              "key": "Sound:getBlob",
              "module": "lovr.data",
              "name": "getBlob",
              "notes": "Samples for each channel are stored interleaved.  The data type of each sample is given by `Sound:getFormat`.",
              "related": ["Blob:getPointer", "Image:getBlob", "Sound"],
              "summary": "Get the bytes backing this Sound as a Blob.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The Blob instance containing the bytes for the `Sound`.",
                      "name": "blob",
                      "type": "Blob"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the byte stride of the Sound.  This is the size of each frame, in bytes.  For example, a stereo sound with a 32-bit floating point format would have a stride of 8 (4 bytes per sample, and 2 samples per frame).",
              "key": "Sound:getByteStride",
              "module": "lovr.data",
              "name": "getByteStride",
              "related": ["Sound:getChannelCount", "Sound:getFormat", "Sound"],
              "summary": "Get the byte stride of the Sound.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The size of a frame, in bytes.",
                      "name": "stride",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the number of frames that can be written to the Sound.  For stream sounds, this is the number of frames that can be written without overwriting existing data.  For normal sounds, this returns the same value as `Sound:getFrameCount`.",
              "key": "Sound:getCapacity",
              "module": "lovr.data",
              "name": "getCapacity",
              "related": [
                "Sound:getFrameCount",
                "Sound:getSampleCount",
                "Source:getDuration",
                "Sound"
              ],
              "summary": "Get the number of frames that can be written to the Sound.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The number of frames that can be written to the Sound.",
                      "name": "capacity",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the number of channels in the Sound.  Mono sounds have 1 channel, stereo sounds have 2 channels, and ambisonic sounds have 4 channels.",
              "key": "Sound:getChannelCount",
              "module": "lovr.data",
              "name": "getChannelCount",
              "related": [
                "Sound:getChannelLayout",
                "Sound:getByteStride",
                "Sound"
              ],
              "summary": "Get the number of channels in the Sound.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The number of channels in the sound.",
                      "name": "channels",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the channel layout of the Sound.",
              "key": "Sound:getChannelLayout",
              "module": "lovr.data",
              "name": "getChannelLayout",
              "related": [
                "Sound:getChannelCount",
                "Sound:getByteStride",
                "Sound"
              ],
              "summary": "Get the channel layout of the Sound.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The channel layout.",
                      "name": "channels",
                      "type": "ChannelLayout"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the duration of the Sound, in seconds.",
              "key": "Sound:getDuration",
              "module": "lovr.data",
              "name": "getDuration",
              "notes": "This can be computed as `(frameCount \/ sampleRate)`.",
              "related": [
                "Sound:getFrameCount",
                "Sound:getSampleCount",
                "Sound:getSampleRate",
                "Source:getDuration",
                "Sound"
              ],
              "summary": "Get the duration of the Sound.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The duration of the Sound, in seconds.",
                      "name": "duration",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the sample format of the Sound.",
              "key": "Sound:getFormat",
              "module": "lovr.data",
              "name": "getFormat",
              "related": [
                "Sound:getChannelLayout",
                "Sound:getByteStride",
                "Sound:getSampleRate",
                "Sound"
              ],
              "summary": "Get the sample format of the Sound.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The data type of each sample.",
                      "name": "format",
                      "type": "SampleFormat"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the number of frames in the Sound.  A frame stores one sample for each channel.",
              "key": "Sound:getFrameCount",
              "module": "lovr.data",
              "name": "getFrameCount",
              "notes": "For streams, this returns the number of frames in the stream\u0027s buffer.",
              "related": [
                "Sound:getDuration",
                "Sound:getSampleCount",
                "Sound:getChannelCount",
                "Sound"
              ],
              "summary": "Get the number of frames in the Sound.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The number of frames in the Sound.",
                      "name": "frames",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Reads frames from the Sound into a table, Blob, or another Sound.",
              "key": "Sound:getFrames",
              "module": "lovr.data",
              "name": "getFrames",
              "related": ["Sound:setFrames", "Sound"],
              "summary": "Read frames from the Sound.",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "nil",
                      "description": "The number of frames to read.  If nil, reads as many frames as possible.\n\nCompressed sounds will automatically be decoded.\n\nReading from a stream will ignore the source offset and read the oldest frames.",
                      "name": "count",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "A frame offset to apply to the sound when reading frames.",
                      "name": "srcOffset",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "A table containing audio frames.",
                      "name": "t",
                      "type": "table"
                    },
                    {
                      "description": "The number of frames read.",
                      "name": "count",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "An existing table to read frames into.",
                      "name": "t",
                      "type": "table"
                    },
                    {
                      "default": "nil",
                      "description": "The number of frames to read.  If nil, reads as many frames as possible.\n\nCompressed sounds will automatically be decoded.\n\nReading from a stream will ignore the source offset and read the oldest frames.",
                      "name": "count",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "A frame offset to apply to the sound when reading frames.",
                      "name": "srcOffset",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "An offset to apply to the destination when writing frames (indices for tables, bytes for Blobs, frames for Sounds).",
                      "name": "dstOffset",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "A table containing audio frames.",
                      "name": "t",
                      "type": "table"
                    },
                    {
                      "description": "The number of frames read.",
                      "name": "count",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A Blob to read frames into.",
                      "name": "blob",
                      "type": "Blob"
                    },
                    {
                      "default": "nil",
                      "description": "The number of frames to read.  If nil, reads as many frames as possible.\n\nCompressed sounds will automatically be decoded.\n\nReading from a stream will ignore the source offset and read the oldest frames.",
                      "name": "count",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "A frame offset to apply to the sound when reading frames.",
                      "name": "srcOffset",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "An offset to apply to the destination when writing frames (indices for tables, bytes for Blobs, frames for Sounds).",
                      "name": "dstOffset",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The number of frames read.",
                      "name": "count",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "Another Sound to copy frames into.",
                      "name": "sound",
                      "type": "Sound"
                    },
                    {
                      "default": "nil",
                      "description": "The number of frames to read.  If nil, reads as many frames as possible.\n\nCompressed sounds will automatically be decoded.\n\nReading from a stream will ignore the source offset and read the oldest frames.",
                      "name": "count",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "A frame offset to apply to the sound when reading frames.",
                      "name": "srcOffset",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "An offset to apply to the destination when writing frames (indices for tables, bytes for Blobs, frames for Sounds).",
                      "name": "dstOffset",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The number of frames read.",
                      "name": "count",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the total number of samples in the Sound.",
              "key": "Sound:getSampleCount",
              "module": "lovr.data",
              "name": "getSampleCount",
              "notes": "For streams, this returns the number of samples in the stream\u0027s buffer.",
              "related": [
                "Sound:getDuration",
                "Sound:getFrameCount",
                "Sound:getChannelCount",
                "Sound"
              ],
              "summary": "Get the number of samples in the Sound.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The total number of samples in the Sound.",
                      "name": "samples",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the sample rate of the Sound, in Hz.  This is the number of frames that are played every second.  It\u0027s usually a high number like 48000.",
              "key": "Sound:getSampleRate",
              "module": "lovr.data",
              "name": "getSampleRate",
              "related": ["Sound"],
              "summary": "Get the sample rate of the Sound.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The number of frames per second in the Sound.",
                      "name": "frequency",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns whether the Sound is compressed.  Compressed sounds are loaded from compressed audio formats like MP3 and OGG.  They use a lot less memory but require some extra CPU work during playback.  Compressed sounds can not be modified using `Sound:setFrames`.",
              "key": "Sound:isCompressed",
              "module": "lovr.data",
              "name": "isCompressed",
              "related": ["Sound:isStream", "lovr.data.newSound", "Sound"],
              "summary": "Check if the Sound is compressed.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "Whether the Sound is compressed.",
                      "name": "compressed",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns whether the Sound is a stream.",
              "key": "Sound:isStream",
              "module": "lovr.data",
              "name": "isStream",
              "related": ["Sound:isCompressed", "lovr.data.newSound", "Sound"],
              "summary": "Check if the Sound is a stream.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "Whether the Sound is a stream.",
                      "name": "stream",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Writes frames to the Sound.",
              "examples": [
                {
                  "code": "function lovr.load()\n  local length \u003d 1\n  local rate \u003d 48000\n  local frames \u003d length * rate\n  local frequency \u003d 440\n  local volume \u003d 1.0\n\n  sound \u003d lovr.data.newSound(frames, \u0027f32\u0027, \u0027stereo\u0027, rate)\n\n  local data \u003d {}\n  for i \u003d 1, frames do\n    local amplitude \u003d math.sin((i - 1) * frequency \/ rate * (2 * math.pi)) * volume\n    data[2 * i - 1] \u003d amplitude\n    data[2 * i - 0] \u003d amplitude\n  end\n\n  sound:setFrames(data)\n\n  source \u003d lovr.audio.newSource(sound)\n  source:setLooping(true)\n  source:play()\nend",
                  "description": "Generate a sine wave."
                }
              ],
              "key": "Sound:setFrames",
              "module": "lovr.data",
              "name": "setFrames",
              "related": ["Sound:getFrames", "Sound"],
              "summary": "Write frames to the Sound.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "A table containing frames to write.",
                      "name": "t",
                      "type": "table"
                    },
                    {
                      "default": "nil",
                      "description": "How many frames to write.  If nil, writes as many as possible.",
                      "name": "count",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "A frame offset to apply when writing the frames.",
                      "name": "dstOffset",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "A frame, byte, or index offset to apply when reading frames from the source.",
                      "name": "srcOffset",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The number of frames written.",
                      "name": "count",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A Blob containing frames to write.",
                      "name": "blob",
                      "type": "Blob"
                    },
                    {
                      "default": "nil",
                      "description": "How many frames to write.  If nil, writes as many as possible.",
                      "name": "count",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "A frame offset to apply when writing the frames.",
                      "name": "dstOffset",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "A frame, byte, or index offset to apply when reading frames from the source.",
                      "name": "srcOffset",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The number of frames written.",
                      "name": "count",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "Another Sound to copy frames from.",
                      "name": "sound",
                      "type": "Sound"
                    },
                    {
                      "default": "nil",
                      "description": "How many frames to write.  If nil, writes as many as possible.",
                      "name": "count",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "A frame offset to apply when writing the frames.",
                      "name": "dstOffset",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "A frame, byte, or index offset to apply when reading frames from the source.",
                      "name": "srcOffset",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The number of frames written.",
                      "name": "count",
                      "type": "number"
                    }
                  ]
                }
              ]
            }
          ],
          "module": "lovr.data",
          "name": "Sound",
          "related": ["lovr.data"],
          "summary": "An object that holds raw audio samples."
        }
      ],
      "summary": "Exposes low level functions for working with data.",
      "tag": "modules"
    },
    {
      "description": "The `lovr.event` module handles events from the operating system.\n\nDue to its low-level nature, it\u0027s rare to use `lovr.event` in simple projects.",
      "enums": [
        {
          "description": "This enum is used to distinguish whether a display is the headset display or the desktop window.",
          "key": "DisplayType",
          "module": "lovr.event",
          "name": "DisplayType",
          "related": ["lovr.focus", "lovr.visible", "lovr.event"],
          "summary": "Distinguishes between the headset and window displays.",
          "values": [
            { "description": "The headset.", "name": "headset" },
            { "description": "The desktop window.", "name": "window" }
          ]
        },
        {
          "description": "Keys that can be pressed on a keyboard.  Notably, numpad keys are missing right now.",
          "key": "KeyCode",
          "module": "lovr.event",
          "name": "KeyCode",
          "related": ["lovr.keypressed", "lovr.keyreleased", "lovr.event"],
          "summary": "Keys that can be pressed.",
          "values": [
            { "description": "The A key.", "name": "a" },
            { "description": "The B key.", "name": "b" },
            { "description": "The C key.", "name": "c" },
            { "description": "The D key.", "name": "d" },
            { "description": "The E key.", "name": "e" },
            { "description": "The F key.", "name": "f" },
            { "description": "The G key.", "name": "g" },
            { "description": "The H key.", "name": "h" },
            { "description": "The I key.", "name": "i" },
            { "description": "The J key.", "name": "j" },
            { "description": "The K key.", "name": "k" },
            { "description": "The L key.", "name": "l" },
            { "description": "The M key.", "name": "m" },
            { "description": "The N key.", "name": "n" },
            { "description": "The O key.", "name": "o" },
            { "description": "The P key.", "name": "p" },
            { "description": "The Q key.", "name": "q" },
            { "description": "The R key.", "name": "r" },
            { "description": "The S key.", "name": "s" },
            { "description": "The T key.", "name": "t" },
            { "description": "The U key.", "name": "u" },
            { "description": "The V key.", "name": "v" },
            { "description": "The W key.", "name": "w" },
            { "description": "The X key.", "name": "x" },
            { "description": "The Y key.", "name": "y" },
            { "description": "The Z key.", "name": "z" },
            { "description": "The 0 key.", "name": "0" },
            { "description": "The 1 key.", "name": "1" },
            { "description": "The 2 key.", "name": "2" },
            { "description": "The 3 key.", "name": "3" },
            { "description": "The 4 key.", "name": "4" },
            { "description": "The 5 key.", "name": "5" },
            { "description": "The 6 key.", "name": "6" },
            { "description": "The 7 key.", "name": "7" },
            { "description": "The 8 key.", "name": "8" },
            { "description": "The 9 key.", "name": "9" },
            { "description": "The space bar.", "name": "space" },
            { "description": "The enter key.", "name": "return" },
            { "description": "The tab key.", "name": "tab" },
            { "description": "The escape key.", "name": "escape" },
            { "description": "The backspace key.", "name": "backspace" },
            { "description": "The up arrow key.", "name": "up" },
            { "description": "The down arrow key.", "name": "down" },
            { "description": "The left arrow key.", "name": "left" },
            { "description": "The right arrow key.", "name": "right" },
            { "description": "The home key.", "name": "home" },
            { "description": "The end key.", "name": "end" },
            { "description": "The page up key.", "name": "pageup" },
            { "description": "The page down key.", "name": "pagedown" },
            { "description": "The insert key.", "name": "insert" },
            { "description": "The delete key.", "name": "delete" },
            { "description": "The F1 key.", "name": "f1" },
            { "description": "The F2 key.", "name": "f2" },
            { "description": "The F3 key.", "name": "f3" },
            { "description": "The F4 key.", "name": "f4" },
            { "description": "The F5 key.", "name": "f5" },
            { "description": "The F6 key.", "name": "f6" },
            { "description": "The F7 key.", "name": "f7" },
            { "description": "The F8 key.", "name": "f8" },
            { "description": "The F9 key.", "name": "f9" },
            { "description": "The F10 key.", "name": "f10" },
            { "description": "The F11 key.", "name": "f11" },
            { "description": "The F12 key.", "name": "f12" },
            {
              "description": "The backtick\/backquote\/grave accent key.",
              "name": "`"
            },
            { "description": "The dash\/hyphen\/minus key.", "name": "-" },
            { "description": "The equal sign key.", "name": "\u003d" },
            { "description": "The left bracket key.", "name": "[" },
            { "description": "The right bracket key.", "name": "]" },
            { "description": "The backslash key.", "name": "\\" },
            { "description": "The semicolon key.", "name": ";" },
            { "description": "The single quote key.", "name": "\u0027" },
            { "description": "The comma key.", "name": "," },
            { "description": "The period key.", "name": "." },
            { "description": "The slash key.", "name": "\/" },
            { "description": "The 0 numpad key.", "name": "kp0" },
            { "description": "The 1 numpad key.", "name": "kp1" },
            { "description": "The 2 numpad key.", "name": "kp2" },
            { "description": "The 3 numpad key.", "name": "kp3" },
            { "description": "The 4 numpad key.", "name": "kp4" },
            { "description": "The 5 numpad key.", "name": "kp5" },
            { "description": "The 6 numpad key.", "name": "kp6" },
            { "description": "The 7 numpad key.", "name": "kp7" },
            { "description": "The 8 numpad key.", "name": "kp8" },
            { "description": "The 9 numpad key.", "name": "kp9" },
            { "description": "The . numpad key.", "name": "kp." },
            { "description": "The \/ numpad key.", "name": "kp\/" },
            { "description": "The * numpad key.", "name": "kp*" },
            { "description": "The - numpad key.", "name": "kp-" },
            { "description": "The + numpad key.", "name": "kp+" },
            { "description": "The enter numpad key.", "name": "kpenter" },
            { "description": "The equals numpad key.", "name": "kp\u003d" },
            { "description": "The left control key.", "name": "lctrl" },
            { "description": "The left shift key.", "name": "lshift" },
            { "description": "The left alt key.", "name": "lalt" },
            {
              "description": "The left OS key (windows, command, super).",
              "name": "lgui"
            },
            { "description": "The right control key.", "name": "rctrl" },
            { "description": "The right shift key.", "name": "rshift" },
            { "description": "The right alt key.", "name": "ralt" },
            {
              "description": "The right OS key (windows, command, super).",
              "name": "rgui"
            },
            { "description": "The caps lock key.", "name": "capslock" },
            { "description": "The scroll lock key.", "name": "scrolllock" },
            { "description": "The numlock key.", "name": "numlock" }
          ]
        }
      ],
      "examples": [
        {
          "code": "function lovr.load()\n  lovr.handlers[\u0027customevent\u0027] \u003d function(a, b, c)\n    print(\u0027custom event handled with args:\u0027, a, b, c)\n  end\n\n  lovr.event.push(\u0027customevent\u0027, 1, 2, 3)\nend",
          "description": "Adding a custom event."
        }
      ],
      "functions": [
        {
          "description": "Clears the event queue, removing any unprocessed events.",
          "key": "lovr.event.clear",
          "module": "lovr.event",
          "name": "clear",
          "related": ["lovr.event"],
          "summary": "Clear the event queue.",
          "variants": [{ "arguments": {}, "returns": {} }]
        },
        {
          "description": "This function returns a Lua iterator for all of the unprocessed items in the event queue.  Each event consists of a name as a string, followed by event-specific arguments.  This function is called in the default implementation of `lovr.run`, so it is normally not necessary to poll for events yourself.",
          "key": "lovr.event.poll",
          "module": "lovr.event",
          "name": "poll",
          "related": ["lovr.event"],
          "summary": "Iterate over unprocessed events in the queue.",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "arguments": {},
                  "description": "The iterator function, usable in a for loop.",
                  "name": "iterator",
                  "returns": {},
                  "type": "function"
                }
              ]
            }
          ]
        },
        {
          "description": "Pushes an event onto the event queue.  It will be processed the next time `lovr.event.poll` is called.  For an event to be processed properly, there needs to be a function in the `lovr.handlers` table with a key that\u0027s the same as the event name.",
          "key": "lovr.event.push",
          "module": "lovr.event",
          "name": "push",
          "notes": "Only nil, booleans, numbers, strings, and L\u00d6VR objects are supported types for event data.",
          "related": ["lovr.event.poll", "lovr.event.quit", "lovr.event"],
          "summary": "Manually push an event onto the queue.",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The name of the event.",
                  "name": "name",
                  "type": "string"
                },
                {
                  "description": "The arguments for the event.  Currently, up to 4 are supported.",
                  "name": "...",
                  "type": "*"
                }
              ],
              "returns": {}
            }
          ]
        },
        {
          "description": "Pushes an event to quit.  An optional number can be passed to set the exit code for the application.  An exit code of zero indicates normal termination, whereas a nonzero exit code indicates that an error occurred.",
          "key": "lovr.event.quit",
          "module": "lovr.event",
          "name": "quit",
          "notes": "This function is equivalent to calling `lovr.event.push(\u0027quit\u0027, \u003cargs\u003e)`.\n\nThe event won\u0027t be processed until the next time `lovr.event.poll` is called.\n\nThe `lovr.quit` callback will be called when the event is processed, which can be used to do any cleanup work.  The callback can also return `false` to abort the quitting process.",
          "related": [
            "lovr.quit",
            "lovr.event.poll",
            "lovr.event.restart",
            "lovr.event"
          ],
          "summary": "Quit the application.",
          "variants": [
            {
              "arguments": [
                {
                  "default": "0",
                  "description": "The exit code of the program.",
                  "name": "code",
                  "type": "number"
                }
              ],
              "returns": {}
            }
          ]
        },
        {
          "description": "Pushes an event to restart the framework.",
          "key": "lovr.event.restart",
          "module": "lovr.event",
          "name": "restart",
          "notes": "The event won\u0027t be processed until the next time `lovr.event.poll` is called.\n\nThe `lovr.restart` callback can be used to persist a value between restarts.",
          "related": [
            "lovr.restart",
            "lovr.event.poll",
            "lovr.event.quit",
            "lovr.event"
          ],
          "summary": "Restart the application.",
          "variants": [{ "arguments": {}, "returns": {} }]
        }
      ],
      "key": "lovr.event",
      "name": "event",
      "notes": "You can define your own custom events by adding a function to the `lovr.handlers` table with a key of the name of the event you want to add.  Then, push the event using `lovr.event.push`.",
      "objects": {},
      "summary": "Handles events from the operating system.",
      "tag": "modules"
    },
    {
      "description": "The `lovr.filesystem` module provides access to the filesystem.\n\nAll files written will go in a special folder called the \"save directory\".  The location of the save directory is platform-specific:\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003ctd\u003eWindows\u003c\/td\u003e\n    \u003ctd\u003e\u003ccode\u003eC:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Roaming\\LOVR\\\u0026lt;identity\u0026gt;\u003c\/code\u003e\u003c\/td\u003e\n  \u003c\/tr\u003e\n  \u003ctr\u003e\n    \u003ctd\u003emacOS\u003c\/td\u003e\n    \u003ctd\u003e\u003ccode\u003e\/Users\/\u0026lt;user\u0026gt;\/Library\/Application Support\/LOVR\/\u0026lt;identity\u0026gt;\u003c\/code\u003e\u003c\/td\u003e\n  \u003c\/tr\u003e\n  \u003ctr\u003e\n    \u003ctd\u003eLinux\u003c\/td\u003e\n    \u003ctd\u003e\u003ccode\u003e\/home\/\u0026lt;user\u0026gt;\/.local\/share\/LOVR\/\u0026lt;identity\u0026gt;\u003c\/code\u003e\u003c\/td\u003e\n  \u003c\/tr\u003e\n  \u003ctr\u003e\n    \u003ctd\u003eAndroid\u003c\/td\u003e\n    \u003ctd\u003e\u003ccode\u003e\/sdcard\/Android\/data\/\u0026lt;identity\u0026gt;\/files\u003c\/code\u003e\u003c\/td\u003e\n  \u003c\/tr\u003e \u003c\/table\u003e\n\n`\u003cidentity\u003e` is a unique identifier for the project, and can be set in `lovr.conf`.  On Android, the identity can not be changed and will always be the package id (e.g. `org.lovr.app`).\n\nWhen files are read, they will be searched for in multiple places.  By default, the save directory is checked first, then the project source (folder or zip).  That way, when data is written to a file, any future reads will see the new data.  The `t.saveprecedence` conf setting can be used to change this precedence.\n\nConceptually, `lovr.filesystem` uses a \"virtual filesystem\", which is an ordered list of folders and zip files that are merged into a single filesystem hierarchy.  Folders and archives in the list can be added and removed with `lovr.filesystem.mount` and `lovr.filesystem.unmount`.\n\nL\u00d6VR extends Lua\u0027s `require` function to look for modules in the virtual filesystem.  The search patterns can be changed with `lovr.filesystem.setRequirePath`, similar to `package.path`.",
      "enums": [
        {
          "description": "The different actions that can be taken on files, reported by `lovr.filechanged` when filesystem watching is active.",
          "key": "FileAction",
          "module": "lovr.filesystem",
          "name": "FileAction",
          "related": ["lovr.filesystem"],
          "summary": "Different actions that can be taken on files.",
          "values": [
            { "description": "The file was created.", "name": "create" },
            { "description": "The file was deleted.", "name": "delete" },
            {
              "description": "The file\u0027s contents were modified.",
              "name": "modify"
            },
            { "description": "The file was renamed.", "name": "rename" }
          ]
        },
        {
          "description": "Different ways to open a `File` with `lovr.filesystem.newFile`.",
          "key": "OpenMode",
          "module": "lovr.filesystem",
          "name": "OpenMode",
          "related": ["lovr.filesystem"],
          "summary": "Different ways to open a file.",
          "values": [
            { "description": "Open the file for reading.", "name": "r" },
            {
              "description": "Open the file for writing (overwrites existing data).",
              "name": "w"
            },
            { "description": "Open the file for appending.", "name": "a" }
          ]
        }
      ],
      "functions": [
        {
          "description": "Appends content to the end of a file.",
          "key": "lovr.filesystem.append",
          "module": "lovr.filesystem",
          "name": "append",
          "notes": "If the file does not exist, it is created.",
          "related": ["lovr.filesystem"],
          "summary": "Append content to the end of a file.",
          "tag": "filesystem-files",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The file to append to.",
                  "name": "filename",
                  "type": "string"
                },
                {
                  "description": "A string to write to the end of the file.",
                  "name": "content",
                  "type": "string"
                }
              ],
              "returns": [
                {
                  "description": "The number of bytes actually appended to the file.",
                  "name": "bytes",
                  "type": "number"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The file to append to.",
                  "name": "filename",
                  "type": "string"
                },
                {
                  "description": "A Blob containing data to append to the file.",
                  "name": "blob",
                  "type": "Blob"
                }
              ],
              "returns": [
                {
                  "description": "The number of bytes actually appended to the file.",
                  "name": "bytes",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Creates a directory in the save directory.  Any parent directories that don\u0027t exist will also be created.",
          "key": "lovr.filesystem.createDirectory",
          "module": "lovr.filesystem",
          "name": "createDirectory",
          "related": ["lovr.filesystem"],
          "summary": "Create a directory.",
          "tag": "filesystem-files",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The directory to create, recursively.",
                  "name": "path",
                  "type": "string"
                }
              ],
              "returns": [
                {
                  "description": "Whether the directory was created.",
                  "name": "success",
                  "type": "boolean"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the application data directory.  This will be something like:\n\n- `C:\\Users\\user\\AppData\\Roaming` on Windows.\n- `\/home\/user\/.config` on Linux.\n- `\/Users\/user\/Library\/Application Support` on macOS.",
          "key": "lovr.filesystem.getAppdataDirectory",
          "module": "lovr.filesystem",
          "name": "getAppdataDirectory",
          "related": ["lovr.filesystem"],
          "summary": "Get the application data directory.",
          "tag": "filesystem-paths",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The absolute path to the appdata directory.",
                  "name": "path",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns a sorted table containing all files and folders in a single directory.",
          "key": "lovr.filesystem.getDirectoryItems",
          "module": "lovr.filesystem",
          "name": "getDirectoryItems",
          "notes": "This function calls `table.sort` to sort the results, so if `table.sort` is not available in the global scope the results are not guaranteed to be sorted.",
          "related": ["lovr.filesystem"],
          "summary": "Get a list of files in a directory.",
          "tag": "filesystem-files",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The directory.",
                  "name": "path",
                  "type": "string"
                }
              ],
              "returns": [
                {
                  "description": "A table with a string for each file and subfolder in the directory.",
                  "name": "items",
                  "type": "table"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the absolute path of the L\u00d6VR executable.",
          "key": "lovr.filesystem.getExecutablePath",
          "module": "lovr.filesystem",
          "name": "getExecutablePath",
          "related": ["lovr.filesystem"],
          "summary": "Get the path of the L\u00d6VR executable.",
          "tag": "filesystem-paths",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The absolute path of the L\u00d6VR executable, or `nil` if it is unknown.",
                  "name": "path",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the identity of the game, which is used as the name of the save directory.  The default is `default`.  It can be changed using `t.identity` in `lovr.conf`.",
          "key": "lovr.filesystem.getIdentity",
          "module": "lovr.filesystem",
          "name": "getIdentity",
          "notes": "On Android, this is always the package id (like `org.lovr.app`).",
          "related": ["lovr.filesystem.setIdentity", "lovr.filesystem"],
          "summary": "Get the name of the save directory.",
          "tag": "filesystem-virtual",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The name of the save directory, or `nil` if it isn\u0027t set.",
                  "name": "identity",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns when a file was last modified, since some arbitrary time in the past.",
          "key": "lovr.filesystem.getLastModified",
          "module": "lovr.filesystem",
          "name": "getLastModified",
          "related": ["lovr.filesystem"],
          "summary": "Get the modification time of a file.",
          "tag": "filesystem-files",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The file to check.",
                  "name": "path",
                  "type": "string"
                }
              ],
              "returns": [
                {
                  "description": "The modification time of the file, in seconds, or `nil` if it\u0027s unknown.",
                  "name": "time",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Get the absolute path of the mounted archive containing a path in the virtual filesystem.  This can be used to determine if a file is in the game\u0027s source directory or the save directory.",
          "key": "lovr.filesystem.getRealDirectory",
          "module": "lovr.filesystem",
          "name": "getRealDirectory",
          "related": ["lovr.filesystem"],
          "summary": "Get the absolute path to a file.",
          "tag": "filesystem-virtual",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The path to check.",
                  "name": "path",
                  "type": "string"
                }
              ],
              "returns": [
                {
                  "description": "The absolute path of the mounted archive containing `path`.",
                  "name": "realpath",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the require path.  The require path is a semicolon-separated list of patterns that L\u00d6VR will use to search for files when they are `require`d.  Any question marks in the pattern will be replaced with the module that is being required.  It is similar to Lua\\\u0027s `package.path` variable, but the main difference is that the patterns are relative to the virtual filesystem.",
          "key": "lovr.filesystem.getRequirePath",
          "module": "lovr.filesystem",
          "name": "getRequirePath",
          "notes": "The default reqiure path is \u0027?.lua;?\/init.lua\u0027.",
          "related": ["lovr.filesystem.setRequirePath", "lovr.filesystem"],
          "summary": "Get the require path.",
          "tag": "filesystem-lua",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The semicolon separated list of search patterns.",
                  "name": "path",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the absolute path to the save directory.",
          "key": "lovr.filesystem.getSaveDirectory",
          "module": "lovr.filesystem",
          "name": "getSaveDirectory",
          "notes": "The save directory takes the following form:\n\n    \u003cappdata\u003e\/LOVR\/\u003cidentity\u003e\n\nWhere `\u003cappdata\u003e` is `lovr.filesystem.getAppdataDirectory` and `\u003cidentity\u003e` is `lovr.filesystem.getIdentity` and can be customized using `lovr.conf`.",
          "related": [
            "lovr.filesystem.getIdentity",
            "lovr.filesystem.getAppdataDirectory",
            "lovr.filesystem"
          ],
          "summary": "Get the location of the save directory.",
          "tag": "filesystem-paths",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The absolute path to the save directory.",
                  "name": "path",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the size of a file, in bytes.",
          "key": "lovr.filesystem.getSize",
          "module": "lovr.filesystem",
          "name": "getSize",
          "notes": "If the file does not exist, an error is thrown.",
          "related": ["File:getSize", "lovr.filesystem"],
          "summary": "Get the size of a file.",
          "tag": "filesystem-files",
          "variants": [
            {
              "arguments": [
                { "description": "The file.", "name": "file", "type": "string" }
              ],
              "returns": [
                {
                  "description": "The size of the file, in bytes.",
                  "name": "size",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Get the absolute path of the project\u0027s source directory or archive.",
          "key": "lovr.filesystem.getSource",
          "module": "lovr.filesystem",
          "name": "getSource",
          "related": ["lovr.filesystem"],
          "summary": "Get the location of the project source.",
          "tag": "filesystem-paths",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The absolute path of the project\u0027s source, or `nil` if it\u0027s unknown.",
                  "name": "path",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the absolute path of the user\u0027s home directory.",
          "key": "lovr.filesystem.getUserDirectory",
          "module": "lovr.filesystem",
          "name": "getUserDirectory",
          "related": ["lovr.filesystem"],
          "summary": "Get the location of the user\u0027s home directory.",
          "tag": "filesystem-paths",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The absolute path of the user\u0027s home directory.",
                  "name": "path",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the absolute path of the working directory.  Usually this is where the executable was started from.",
          "key": "lovr.filesystem.getWorkingDirectory",
          "module": "lovr.filesystem",
          "name": "getWorkingDirectory",
          "related": ["lovr.filesystem"],
          "summary": "Get the current working directory.",
          "tag": "filesystem-paths",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The current working directory, or `nil` if it\u0027s unknown.",
                  "name": "path",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "description": "Check if a path exists and is a directory.",
          "key": "lovr.filesystem.isDirectory",
          "module": "lovr.filesystem",
          "name": "isDirectory",
          "related": ["lovr.filesystem.isFile", "lovr.filesystem"],
          "summary": "Check whether a path is a directory.",
          "tag": "filesystem-files",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The path to check.",
                  "name": "path",
                  "type": "string"
                }
              ],
              "returns": [
                {
                  "description": "Whether or not the path is a directory.",
                  "name": "isDirectory",
                  "type": "boolean"
                }
              ]
            }
          ]
        },
        {
          "description": "Check if a path exists and is a file.",
          "key": "lovr.filesystem.isFile",
          "module": "lovr.filesystem",
          "name": "isFile",
          "related": ["lovr.filesystem.isDirectory", "lovr.filesystem"],
          "summary": "Check whether a path is a file.",
          "tag": "filesystem-files",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The path to check.",
                  "name": "path",
                  "type": "string"
                }
              ],
              "returns": [
                {
                  "description": "Whether or not the path is a file.",
                  "name": "isFile",
                  "type": "boolean"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns whether the current project source is fused to the executable.",
          "key": "lovr.filesystem.isFused",
          "module": "lovr.filesystem",
          "name": "isFused",
          "related": ["lovr.filesystem"],
          "summary": "Check if the project is fused.",
          "tag": "filesystem-virtual",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "Whether or not the project is fused.",
                  "name": "fused",
                  "type": "boolean"
                }
              ]
            }
          ]
        },
        {
          "description": "Load a file containing Lua code, returning a Lua chunk that can be run.",
          "examples": [
            {
              "code": "local success, chunk \u003d pcall(lovr.filesystem.load, filename)\nif not success then\n  print(\u0027Oh no! There was an error: \u0027 .. tostring(chunk))\nelse\n  local success, result \u003d pcall(chunk)\n  print(success, result)\nend",
              "description": "Safely loading code:"
            }
          ],
          "key": "lovr.filesystem.load",
          "module": "lovr.filesystem",
          "name": "load",
          "notes": "An error is thrown if the file contains syntax errors.",
          "related": ["lovr.filesystem"],
          "summary": "Load a file as Lua code.",
          "tag": "filesystem-lua",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The file to load.",
                  "name": "filename",
                  "type": "string"
                },
                {
                  "default": "\u0027bt\u0027",
                  "description": "The type of code that can be loaded.  `t` allows text, `b` allows binary, and `bt` allows both.",
                  "name": "mode",
                  "type": "string"
                }
              ],
              "returns": [
                {
                  "description": "The runnable chunk.",
                  "name": "chunk",
                  "type": "function"
                }
              ]
            }
          ]
        },
        {
          "description": "Mounts a directory or `.zip` archive, adding it to the virtual filesystem.  This allows you to read files from it.",
          "examples": [
            {
              "code": "lovr.filesystem.mount(\u0027data.zip\u0027, \u0027assets\u0027)\nprint(lovr.filesystem.isFile(\u0027assets\/images\/background.png\u0027)) -- true",
              "description": "Mount `data.zip` with a file `images\/background.png`:"
            }
          ],
          "key": "lovr.filesystem.mount",
          "module": "lovr.filesystem",
          "name": "mount",
          "notes": "The `append` option lets you control the priority of the archive\u0027s files in the event of naming collisions.\n\nThis function is not thread safe.  Mounting or unmounting an archive while other threads call lovr.filesystem functions is not supported.",
          "related": ["lovr.filesystem.unmount", "lovr.filesystem"],
          "summary": "Mount a directory or archive.",
          "tag": "filesystem-virtual",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The path to mount.",
                  "name": "path",
                  "type": "string"
                },
                {
                  "default": "\u0027\/\u0027",
                  "description": "The path in the virtual filesystem to mount to.",
                  "name": "mountpoint",
                  "type": "string"
                },
                {
                  "default": "false",
                  "description": "Whether the archive will be added to the end or the beginning of the search path.",
                  "name": "append",
                  "type": "boolean"
                },
                {
                  "default": "nil",
                  "description": "A subdirectory inside the archive to use as the root.  If `nil`, the actual root of the archive is used.",
                  "name": "root",
                  "type": "string"
                }
              ],
              "returns": [
                {
                  "description": "Whether the archive was successfully mounted.",
                  "name": "success",
                  "type": "boolean"
                }
              ]
            }
          ]
        },
        {
          "description": "Creates a new Blob that contains the contents of a file.",
          "key": "lovr.filesystem.newBlob",
          "module": "lovr.filesystem",
          "name": "newBlob",
          "related": ["lovr.data.newBlob", "Blob", "lovr.filesystem"],
          "summary": "Create a new Blob from a file.",
          "tag": "filesystem-files",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The file to load.",
                  "name": "filename",
                  "type": "string"
                }
              ],
              "returns": [
                {
                  "description": "The new Blob.",
                  "name": "blob",
                  "type": "Blob"
                }
              ]
            }
          ]
        },
        {
          "description": "Opens a file, returning a `File` object that can be used to read\/write the file contents.\n\nNormally you can just use `lovr.filesystem.read`, `lovr.filesystem.write`, etc.  However, those methods open and close the file each time they are called.  So, when performing multiple operations on a file, creating a File object and keeping it open will have less overhead.",
          "examples": [
            {
              "code": "function lovr.load()\n  local file \u003d lovr.filesystem.newFile(\u0027asdf.txt\u0027, \u0027w\u0027)\n  file:write(\u0027asdf\u0027)\n  file:release()\nend"
            }
          ],
          "key": "lovr.filesystem.newFile",
          "module": "lovr.filesystem",
          "name": "newFile",
          "related": [
            "lovr.filesystem.read",
            "lovr.filesystem.write",
            "lovr.filesystem.append",
            "lovr.filesystem"
          ],
          "summary": "Open a file, returning a `File` object.",
          "tag": "filesystem-files",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The path of the file to open.",
                  "name": "path",
                  "type": "string"
                },
                {
                  "description": "The mode to open the file in (`r`, `w`, or `a`).",
                  "name": "mode",
                  "type": "OpenMode"
                }
              ],
              "returns": [
                {
                  "description": "A new file object, or nil if an error occurred.",
                  "name": "file",
                  "type": "File"
                },
                {
                  "description": "The error message, if an error occurred.",
                  "name": "error",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "description": "Read the contents of a file.",
          "key": "lovr.filesystem.read",
          "module": "lovr.filesystem",
          "name": "read",
          "notes": "If the file does not exist or cannot be read, nil is returned.",
          "related": ["lovr.filesystem"],
          "summary": "Read a file.",
          "tag": "filesystem-files",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The name of the file to read.",
                  "name": "filename",
                  "type": "string"
                },
                {
                  "default": "-1",
                  "description": "The number of bytes to read (if -1, all bytes will be read).",
                  "name": "bytes",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "The contents of the file.",
                  "name": "contents",
                  "type": "string"
                },
                {
                  "description": "The number of bytes read from the file.",
                  "name": "bytes",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Remove a file or directory in the save directory.",
          "key": "lovr.filesystem.remove",
          "module": "lovr.filesystem",
          "name": "remove",
          "notes": "A directory can only be removed if it is empty.\n\nTo recursively remove a folder, use this function with `lovr.filesystem.getDirectoryItems`.",
          "related": ["lovr.filesystem"],
          "summary": "Remove a file or directory.",
          "tag": "filesystem-files",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The file or directory to remove.",
                  "name": "path",
                  "type": "string"
                }
              ],
              "returns": [
                {
                  "description": "Whether the path was removed.",
                  "name": "success",
                  "type": "boolean"
                }
              ]
            }
          ]
        },
        {
          "description": "Set the name of the save directory.  This function can only be called once and is called automatically at startup, so this function normally isn\u0027t called manually.  However, the identity can be changed by setting the `t.identity` option in `lovr.conf`.",
          "key": "lovr.filesystem.setIdentity",
          "module": "lovr.filesystem",
          "name": "setIdentity",
          "related": [
            "lovr.conf",
            "lovr.filesystem.getSaveDirectory",
            "lovr.filesystem.getIdentity",
            "lovr.filesystem"
          ],
          "summary": "Set the name of the save directory.",
          "tag": "filesystem-virtual",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The name of the save directory.",
                  "name": "identity",
                  "type": "string"
                }
              ],
              "returns": {}
            }
          ]
        },
        {
          "description": "Sets the require path.  The require path is a semicolon-separated list of patterns that L\u00d6VR will use to search for files when they are `require`d.  Any question marks in the pattern will be replaced with the module that is being required.  It is similar to Lua\\\u0027s `package.path` variable, except the patterns will be checked using `lovr.filesystem` APIs. This allows `require` to work even when the project is packaged into a zip archive, or when the project is launched from a different directory.",
          "key": "lovr.filesystem.setRequirePath",
          "module": "lovr.filesystem",
          "name": "setRequirePath",
          "notes": "The default reqiure path is \u0027?.lua;?\/init.lua\u0027.",
          "related": ["lovr.filesystem.getRequirePath", "lovr.filesystem"],
          "summary": "Set the require path.",
          "tag": "filesystem-lua",
          "variants": [
            {
              "arguments": [
                {
                  "default": "nil",
                  "description": "An optional semicolon separated list of search patterns.",
                  "name": "path",
                  "type": "string"
                }
              ],
              "returns": {}
            }
          ]
        },
        {
          "description": "Unmounts a directory or archive previously mounted with `lovr.filesystem.mount`.",
          "key": "lovr.filesystem.unmount",
          "module": "lovr.filesystem",
          "name": "unmount",
          "notes": "This function is not thread safe.  Mounting or unmounting an archive while other threads call lovr.filesystem functions is not supported.",
          "related": ["lovr.filesystem.mount", "lovr.filesystem"],
          "summary": "Unmount a mounted archive.",
          "tag": "filesystem-virtual",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The path to unmount.",
                  "name": "path",
                  "type": "string"
                }
              ],
              "returns": [
                {
                  "description": "Whether the archive was unmounted.",
                  "name": "success",
                  "type": "boolean"
                }
              ]
            }
          ]
        },
        {
          "description": "Stops watching files.",
          "key": "lovr.filesystem.unwatch",
          "module": "lovr.filesystem",
          "name": "unwatch",
          "related": [
            "lovr.filesystem.watch",
            "lovr.filechanged",
            "lovr.filesystem"
          ],
          "summary": "Stop watching files.",
          "tag": "filesystem-files",
          "variants": [{ "arguments": {}, "returns": {} }]
        },
        {
          "description": "Starts watching the filesystem for changes.  File events will be reported by the `lovr.filechanged` callback.\n\nCurrently, on PC, only files in the source directory will be watched.  On Android, files in the save directory will be watched instead, so that pushing new files with `adb` can be detected.",
          "key": "lovr.filesystem.watch",
          "module": "lovr.filesystem",
          "name": "watch",
          "related": [
            "lovr.filesystem.unwatch",
            "lovr.filechanged",
            "lovr.filesystem"
          ],
          "summary": "Start watching the filesystem for changes.",
          "tag": "filesystem-files",
          "variants": [{ "arguments": {}, "returns": {} }]
        },
        {
          "description": "Write to a file in the save directory.",
          "key": "lovr.filesystem.write",
          "module": "lovr.filesystem",
          "name": "write",
          "notes": "If the file does not exist, it is created.\n\nIf the file already has data in it, it will be replaced with the new content.\n\nIf the path contains subdirectories, all of the parent directories need to exist first or the write will fail.  Use `lovr.filesystem.createDirectory` to make sure they\u0027re created first.",
          "related": [
            "lovr.filesystem.append",
            "lovr.filesystem.getSaveDirectory",
            "lovr.filesystem.read",
            "lovr.filesystem"
          ],
          "summary": "Write to a file.",
          "tag": "filesystem-files",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The file to write to.",
                  "name": "filename",
                  "type": "string"
                },
                {
                  "description": "A string to write to the file.",
                  "name": "content",
                  "type": "string"
                }
              ],
              "returns": [
                {
                  "description": "Whether the write was successful.",
                  "name": "success",
                  "type": "boolean"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The file to write to.",
                  "name": "filename",
                  "type": "string"
                },
                {
                  "description": "A Blob containing data to write to the file.",
                  "name": "blob",
                  "type": "Blob"
                }
              ],
              "returns": [
                {
                  "description": "Whether the write was successful.",
                  "name": "success",
                  "type": "boolean"
                }
              ]
            }
          ]
        }
      ],
      "key": "lovr.filesystem",
      "name": "filesystem",
      "objects": [
        {
          "constructors": ["lovr.filesystem.newFile"],
          "description": "A File is an object that provides read or write access to a file on the filesystem.",
          "key": "File",
          "methods": [
            {
              "description": "Returns the mode the file was opened in.",
              "key": "File:getMode",
              "module": "lovr.filesystem",
              "name": "getMode",
              "related": ["File:getPath", "File"],
              "summary": "Get the mode the file was opened in.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The mode the file was opened in (`r`, `w`, or `a`).",
                      "name": "mode",
                      "type": "OpenMode"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the file\u0027s path.",
              "key": "File:getPath",
              "module": "lovr.filesystem",
              "name": "getPath",
              "related": ["File"],
              "summary": "Get the file\u0027s path.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The file path.",
                      "name": "path",
                      "type": "string"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the size of the file, in bytes.",
              "key": "File:getSize",
              "module": "lovr.filesystem",
              "name": "getSize",
              "related": ["lovr.filesystem.getSize", "File"],
              "summary": "Get the size of the File.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The size of the file, in bytes, or nil if an error occurred.",
                      "name": "size",
                      "type": "number"
                    },
                    {
                      "description": "The error message, if an error occurred.",
                      "name": "error",
                      "type": "string"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns whether the end of file has been reached.  When true, `File:read` will no longer return data.",
              "key": "File:isEOF",
              "module": "lovr.filesystem",
              "name": "isEOF",
              "related": ["File:seek", "File:tell", "File:getSize", "File"],
              "summary": "Check if the end of the file has been reached.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "Whether the end of the file has been reached.",
                      "name": "eof",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Reads data from the file.",
              "key": "File:read",
              "module": "lovr.filesystem",
              "name": "read",
              "notes": "The file must have been opened for reading.\n\nThe maximum number of bytes that can be read at a time is 2^53 - 1.",
              "related": [
                "File:write",
                "lovr.filesystem.read",
                "lovr.filesystem.newBlob",
                "File"
              ],
              "summary": "Read data from the file.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The number of bytes to read from the file, or `nil` to read the rest of the file.",
                      "name": "bytes",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The data that was read, or nil if an error occurred.",
                      "name": "data",
                      "type": "string"
                    },
                    {
                      "description": "The number of bytes that were read, or the error message if an error occurred.",
                      "name": "size",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Seeks to a new position in the file.  `File:read` and `File:write` will read\/write relative to this position.",
              "key": "File:seek",
              "module": "lovr.filesystem",
              "name": "seek",
              "related": ["File:tell", "File:getSize", "File"],
              "summary": "Seek to a position in the file.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The new file offset, in bytes.",
                      "name": "offset",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Returns the seek position of the file, which is where `File:read` and `File:write will read\/write from.",
              "key": "File:tell",
              "module": "lovr.filesystem",
              "name": "tell",
              "related": ["File:seek", "File"],
              "summary": "Get the seek position of the file.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The file offset, in bytes.",
                      "name": "offset",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Writes data to the file.",
              "key": "File:write",
              "module": "lovr.filesystem",
              "name": "write",
              "notes": "The maximum number of bytes that can be written at a time is 2^53 - 1.\n\nUse `File:seek` to control where the data is written.",
              "related": [
                "File:read",
                "lovr.filesystem.write",
                "lovr.filesystem.append",
                "File"
              ],
              "summary": "Write data to the file.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "A string to write to the file.",
                      "name": "string",
                      "type": "string"
                    },
                    {
                      "default": "nil",
                      "description": "The number of bytes to write, or nil to write all of the data from the string\/Blob.",
                      "name": "size",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "Whether the data was successfully written.",
                      "name": "success",
                      "type": "boolean"
                    },
                    {
                      "description": "The error message.",
                      "name": "message",
                      "type": "string"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The Blob containing data to write to the file.",
                      "name": "blob",
                      "type": "Blob"
                    },
                    {
                      "default": "nil",
                      "description": "The number of bytes to write, or nil to write all of the data from the string\/Blob.",
                      "name": "size",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "Whether the data was successfully written.",
                      "name": "success",
                      "type": "boolean"
                    },
                    {
                      "description": "The error message.",
                      "name": "message",
                      "type": "string"
                    }
                  ]
                }
              ]
            }
          ],
          "module": "lovr.filesystem",
          "name": "File",
          "related": ["lovr.filesystem"],
          "summary": "Represents an open file handle."
        }
      ],
      "sections": [
        {
          "description": "Operations for reading\/writing files and querying their metadata.",
          "name": "Files",
          "tag": "filesystem-files"
        },
        { "name": "Virtual Filesystem", "tag": "filesystem-virtual" },
        {
          "description": "Useful system paths.",
          "name": "Paths",
          "tag": "filesystem-paths"
        },
        { "name": "Lua", "tag": "filesystem-lua" }
      ],
      "summary": "Provides access to the filesystem.",
      "tag": "modules"
    },
    {
      "description": "The graphics module renders graphics and performs computation using the GPU.\n\nMost of the graphics functions are on the `Pass` object.",
      "enums": [
        {
          "description": "Controls whether premultiplied alpha is enabled.",
          "key": "BlendAlphaMode",
          "module": "lovr.graphics",
          "name": "BlendAlphaMode",
          "notes": "The premultiplied mode should be used if pixels being drawn have already been blended, or \"pre-multiplied\", by the alpha channel.  This happens when rendering to a texture that contains pixels with transparent alpha values, since the stored color values have already been faded by alpha and don\u0027t need to be faded a second time with the alphamultiply blend mode.",
          "related": ["BlendMode", "Pass:setBlendMode", "lovr.graphics"],
          "summary": "Whether premultiplied alpha is enabled.",
          "values": [
            {
              "description": "Color channel values are multiplied by the alpha channel during blending.",
              "name": "alphamultiply"
            },
            {
              "description": "Color channel values are not multiplied by the alpha.  Instead, it\u0027s assumed that the colors have already been multiplied by the alpha.  This should be used if the pixels being drawn have already been blended, or \"pre-multiplied\".",
              "name": "premultiplied"
            }
          ]
        },
        {
          "description": "Different ways pixels can blend with the pixels behind them.",
          "key": "BlendMode",
          "module": "lovr.graphics",
          "name": "BlendMode",
          "related": ["BlendAlphaMode", "Pass:setBlendMode", "lovr.graphics"],
          "summary": "Blend modes.",
          "values": [
            {
              "description": "Colors will be mixed based on alpha.",
              "name": "alpha"
            },
            {
              "description": "Colors will be added to the existing color, alpha will not be changed.",
              "name": "add"
            },
            {
              "description": "Colors will be subtracted from the existing color, alpha will not be changed.",
              "name": "subtract"
            },
            {
              "description": "All color channels will be multiplied together, producing a darkening effect.",
              "name": "multiply"
            },
            {
              "description": "The maximum value of each color channel will be used.",
              "name": "lighten"
            },
            {
              "description": "The minimum value of each color channel will be used.",
              "name": "darken"
            },
            {
              "description": "The opposite of multiply: the pixel colors are inverted, multiplied, and inverted again, producing a lightening effect.",
              "name": "screen"
            },
            {
              "description": "The incoming colors will replace the existing colors.  This is the same as using a blend mode of `nil`.",
              "name": "none"
            }
          ]
        },
        {
          "description": "The method used to compare depth and stencil values when performing the depth and stencil tests. Also used for compare modes in `Sampler`s.",
          "key": "CompareMode",
          "module": "lovr.graphics",
          "name": "CompareMode",
          "notes": "This type can also be specified using mathematical notation, e.g. `\u003d`, `\u003e`, `\u003c\u003d`, etc. `notequal` can be provided as `~\u003d` or `!\u003d`.",
          "related": [
            "Pass:setDepthTest",
            "Pass:setStencilTest",
            "Pass:setDepthWrite",
            "Pass:setStencilWrite",
            "lovr.graphics"
          ],
          "summary": "Different ways of performing comparisons.",
          "values": [
            {
              "description": "The test does not take place, and acts as though it always passes.",
              "name": "none"
            },
            {
              "description": "The test passes if the values are equal.",
              "name": "equal"
            },
            {
              "description": "The test passes if the values are not equal.",
              "name": "notequal"
            },
            {
              "description": "The test passes if the value is less than the existing one.",
              "name": "less"
            },
            {
              "description": "The test passes if the value is less than or equal to the existing one.",
              "name": "lequal"
            },
            {
              "description": "The test passes if the value is greater than the existing one.",
              "name": "greater"
            },
            {
              "description": "The test passes if the value is greater than or equal to the existing one.",
              "name": "gequal"
            }
          ]
        },
        {
          "description": "The different ways of doing triangle backface culling.",
          "key": "CullMode",
          "module": "lovr.graphics",
          "name": "CullMode",
          "related": [
            "Winding",
            "Pass:setCullMode",
            "Pass:setWinding",
            "lovr.graphics"
          ],
          "summary": "Different ways of doing face culling.",
          "values": [
            {
              "description": "Both sides of triangles will be drawn.",
              "name": "none"
            },
            {
              "description": "Skips rendering the back side of triangles.",
              "name": "back"
            },
            {
              "description": "Skips rendering the front side of triangles.",
              "name": "front"
            }
          ]
        },
        {
          "description": "The different ways to pack Buffer fields into memory.\n\nThe default is `packed`, which is suitable for vertex buffers and index buffers.  It doesn\u0027t add any padding between elements, and so it doesn\u0027t waste any space.  However, this layout won\u0027t necessarily work for uniform buffers and storage buffers.\n\nThe `std140` layout corresponds to the std140 layout used for uniform buffers in GLSL.  It adds the most padding between fields, and requires the stride to be a multiple of 16.  Example:\n\n    layout(std140) uniform ObjectScales { float scales[64]; };\n\nThe `std430` layout corresponds to the std430 layout used for storage buffers in GLSL.  It adds some padding between certain types, and may round up the stride.  Example:\n\n    layout(std430) buffer TileSizes { vec2 sizes[]; }",
          "key": "DataLayout",
          "module": "lovr.graphics",
          "name": "DataLayout",
          "related": [
            "lovr.graphics.newBuffer",
            "Buffer:getFormat",
            "Buffer:getStride",
            "DataType",
            "lovr.graphics"
          ],
          "summary": "Different ways of padding GPU buffer data.",
          "values": [
            {
              "description": "The packed layout, without any padding.",
              "name": "packed"
            },
            { "description": "The std140 layout.", "name": "std140" },
            { "description": "The std430 layout.", "name": "std430" }
          ]
        },
        {
          "description": "Different types for `Buffer` fields.  These are scalar, vector, or matrix types, usually packed into small amounts of space to reduce the amount of memory they occupy.\n\nThe names are encoded as follows:\n\n- The data type:\n  - `i` for signed integer\n  - `u` for unsigned integer\n  - `sn` for signed normalized (-1 to 1)\n  - `un` for unsigned normalized (0 to 1)\n  - `f` for floating point\n- The bit depth of each component\n- The letter `x` followed by the component count (for vectors)",
          "key": "DataType",
          "module": "lovr.graphics",
          "name": "DataType",
          "notes": "In addition to these values, the following aliases can be used:\n\n\u003ctable\u003e\n  \u003cthead\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eAlias\u003c\/td\u003e\n      \u003ctd\u003eMaps to\u003c\/td\u003e\n    \u003c\/tr\u003e\n  \u003c\/thead\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003evec2\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003e\u003ccode\u003ef32x2\u003c\/code\u003e\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003evec3\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003e\u003ccode\u003ef32x3\u003c\/code\u003e\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003evec4\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003e\u003ccode\u003ef32x4\u003c\/code\u003e\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003eint\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003e\u003ccode\u003ei32\u003c\/code\u003e\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003euint\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003e\u003ccode\u003eu32\u003c\/code\u003e\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003efloat\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003e\u003ccode\u003ef32\u003c\/code\u003e\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003ecolor\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003e\u003ccode\u003eun8x4\u003c\/code\u003e\u003c\/td\u003e\n    \u003c\/tr\u003e\n  \u003c\/tbody\u003e \u003c\/table\u003e\n\nAdditionally, the following convenience rules apply:\n\n- Field types can end in an `s`, which will be stripped off.\n- Field types can end in `x1`, which will be stripped off.\n\nSo you can write, e.g. `lovr.graphics.newBuffer(4, \u0027floats\u0027)`, which is cute!",
          "related": [
            "lovr.graphics.newBuffer",
            "Buffer:getFormat",
            "lovr.graphics"
          ],
          "summary": "Different types for `Buffer` fields.",
          "values": [
            { "description": "Four 8-bit signed integers.", "name": "i8x4" },
            { "description": "Four 8-bit unsigned integers.", "name": "u8x4" },
            {
              "description": "Four 8-bit signed normalized values.",
              "name": "sn8x4"
            },
            {
              "description": "Four 8-bit unsigned normalized values (aka `color`).",
              "name": "un8x4"
            },
            {
              "description": "Three 10-bit signed normalized values, and 2 padding bits.",
              "name": "sn10x3"
            },
            {
              "description": "Three 10-bit unsigned normalized values, and 2 padding bits.",
              "name": "un10x3"
            },
            { "description": "One 16-bit signed integer.", "name": "i16" },
            { "description": "Two 16-bit signed integers.", "name": "i16x2" },
            { "description": "Four 16-bit signed integers.", "name": "i16x4" },
            { "description": "One 16-bit unsigned integer.", "name": "u16" },
            { "description": "Two 16-bit unsigned integers.", "name": "u16x2" },
            {
              "description": "Four 16-bit unsigned integers.",
              "name": "u16x4"
            },
            {
              "description": "Two 16-bit signed normalized values.",
              "name": "sn16x2"
            },
            {
              "description": "Four 16-bit signed normalized values.",
              "name": "sn16x4"
            },
            {
              "description": "Two 16-bit unsigned normalized values.",
              "name": "un16x2"
            },
            {
              "description": "Four 16-bit unsigned normalized values.",
              "name": "un16x4"
            },
            {
              "description": "One 32-bit signed integer (aka `int`).",
              "name": "i32"
            },
            { "description": "Two 32-bit signed integers.", "name": "i32x2" },
            { "description": "Three 32-bit signed integers.", "name": "i32x3" },
            { "description": "Four 32-bit signed integers.", "name": "i32x4" },
            {
              "description": "One 32-bit unsigned integer (aka `uint`).",
              "name": "u32"
            },
            { "description": "Two 32-bit unsigned integers.", "name": "u32x2" },
            {
              "description": "Three 32-bit unsigned integers.",
              "name": "u32x3"
            },
            {
              "description": "Four 32-bit unsigned integers.",
              "name": "u32x4"
            },
            {
              "description": "Two 16-bit floating point numbers.",
              "name": "f16x2"
            },
            {
              "description": "Four 16-bit floating point numbers.",
              "name": "f16x4"
            },
            {
              "description": "One 32-bit floating point number (aka `float`).",
              "name": "f32"
            },
            {
              "description": "Two 32-bit floating point numbers (aka `vec2`).",
              "name": "f32x2"
            },
            {
              "description": "Three 32-bit floating point numbers (aka `vec3`).",
              "name": "f32x3"
            },
            {
              "description": "Four 32-bit floating point numbers (aka `vec4`).",
              "name": "f32x4"
            },
            {
              "description": "A 2x2 matrix containing four 32-bit floats.",
              "name": "mat2"
            },
            {
              "description": "A 3x3 matrix containing nine 32-bit floats.",
              "name": "mat3"
            },
            {
              "description": "A 4x4 matrix containing sixteen 32-bit floats.",
              "name": "mat4"
            },
            { "description": "Like u16, but 1-indexed.", "name": "index16" },
            { "description": "Like u32, but 1-indexed.", "name": "index32" }
          ]
        },
        {
          "description": "The set of shaders built in to L\u00d6VR.  These can be passed to `Pass:setShader` or `lovr.graphics.newShader` instead of writing GLSL code.  The shaders can be further customized by using the `flags` option to change their behavior.  If the active shader is set to `nil`, L\u00d6VR picks one of these shaders to use.",
          "key": "DefaultShader",
          "module": "lovr.graphics",
          "name": "DefaultShader",
          "related": ["lovr.graphics"],
          "summary": "Built-in shaders.",
          "values": [
            {
              "description": "Basic shader without lighting that uses colors and a texture.",
              "name": "unlit"
            },
            {
              "description": "Shades triangles based on their normal, resulting in a cool rainbow effect.",
              "name": "normal"
            },
            { "description": "Renders font glyphs.", "name": "font" },
            { "description": "Renders cubemaps.", "name": "cubemap" },
            {
              "description": "Renders spherical textures.",
              "name": "equirect"
            },
            { "description": "Renders a fullscreen triangle.", "name": "fill" }
          ]
        },
        {
          "description": "Different ways vertices in a mesh can be connected together and filled in with pixels.",
          "key": "DrawMode",
          "module": "lovr.graphics",
          "name": "DrawMode",
          "related": ["lovr.graphics"],
          "summary": "Different ways to draw mesh vertices.",
          "values": [
            {
              "description": "Each vertex is rendered as a single point.  The size of the point can be controlled using the `pointSize` shader flag, or by writing to the `PointSize` variable in shaders.  The maximum point size is given by the `pointSize` limit from `lovr.graphics.getLimits`.",
              "name": "points"
            },
            {
              "description": "Pairs of vertices are connected with line segments.  To draw a single line through all of the vertices, an index buffer can be used to repeat vertices.  It is not currently possible to change the width of the lines, although cylinders or capsules can be used as an alternative.",
              "name": "lines"
            },
            {
              "description": "Every 3 vertices form a triangle, which is filled in with pixels (unless `Pass:setWireframe` is used).  This mode is the most commonly used.",
              "name": "triangles"
            }
          ]
        },
        {
          "description": "Whether a shape should be drawn filled or outlined.",
          "key": "DrawStyle",
          "module": "lovr.graphics",
          "name": "DrawStyle",
          "related": [
            "Pass:plane",
            "Pass:cube",
            "Pass:box",
            "Pass:circle",
            "lovr.graphics"
          ],
          "summary": "Different styles to draw shapes.",
          "values": [
            {
              "description": "The shape will be filled in (the default).",
              "name": "fill"
            },
            { "description": "The shape will be outlined.", "name": "line" }
          ]
        },
        {
          "description": "Controls how `Sampler` objects smooth pixels in textures.",
          "key": "FilterMode",
          "module": "lovr.graphics",
          "name": "FilterMode",
          "related": [
            "lovr.graphics.newSampler",
            "Sampler:getFilter",
            "Texture:setPixels",
            "lovr.graphics"
          ],
          "summary": "Different ways to smooth textures.",
          "values": [
            {
              "description": "A pixelated appearance where the \"nearest neighbor\" pixel is used.",
              "name": "nearest"
            },
            {
              "description": "A smooth appearance where neighboring pixels are averaged.",
              "name": "linear"
            }
          ]
        },
        {
          "description": "Different ways to horizontally align text with `Pass:text`.",
          "key": "HorizontalAlign",
          "module": "lovr.graphics",
          "name": "HorizontalAlign",
          "related": [
            "VerticalAlign",
            "Pass:text",
            "Font:getVertices",
            "lovr.graphics"
          ],
          "summary": "Different ways to horizontally align text.",
          "values": [
            { "description": "Left-aligned text.", "name": "left" },
            { "description": "Centered text.", "name": "center" },
            { "description": "Right-aligned text.", "name": "right" }
          ]
        },
        {
          "description": "Whether a Mesh stores its data on the CPU or GPU.",
          "key": "MeshStorage",
          "module": "lovr.graphics",
          "name": "MeshStorage",
          "notes": "There are some significant differences and tradeoffs between the two modes:\n\n- CPU meshes store a second copy of the vertices in RAM, which can be expensive for large\n  meshes.\n- When vertices are modified, CPU meshes will update the CPU copy, and only upload to the GPU\n  the next time the Mesh is drawn.  GPU meshes, on the other hand, will immediately upload\n  modified vertices to the GPU.  This means that calling `Mesh:setVertices` multiple times per\n  frame will be faster with a CPU mesh.\n- CPU meshes have an internal vertex buffer that can\u0027t be accessed from Lua.\n- CPU meshes can compute their bounding box using `Mesh:computeBoundingBox`.  GPU meshes can\u0027t.",
          "related": ["lovr.graphics.newMesh", "lovr.graphics"],
          "summary": "Whether a Mesh stores its data on the CPU or GPU.",
          "values": [
            {
              "description": "The Mesh will store a copy of the vertices on the CPU.",
              "name": "cpu"
            },
            {
              "description": "The Mesh will not keep a CPU copy, only storing vertices on the GPU.",
              "name": "gpu"
            }
          ]
        },
        {
          "description": "Different coordinate spaces for nodes in a `Model`.",
          "key": "OriginType",
          "module": "lovr.graphics",
          "name": "OriginType",
          "related": [
            "Model:getNodePosition",
            "Model:getNodeOrientation",
            "Model:getNodeScale",
            "Model:getNodePose",
            "Model:getNodeTransform",
            "Model:getRootNode",
            "Model:getNodeParent",
            "lovr.graphics"
          ],
          "summary": "Different coordinate spaces for nodes in a Model.",
          "values": [
            {
              "description": "Transforms are relative to the origin (root) of the Model.",
              "name": "root"
            },
            {
              "description": "Transforms are relative to the parent of the node.",
              "name": "parent"
            }
          ]
        },
        {
          "description": "Different shader stages.  Graphics shaders have a `vertex` and `fragment` stage, and compute shaders have a single `compute` stage.",
          "key": "ShaderStage",
          "module": "lovr.graphics",
          "name": "ShaderStage",
          "related": ["lovr.graphics"],
          "summary": "Different shader stages.",
          "values": [
            {
              "description": "The vertex stage, which computes transformed vertex positions.",
              "name": "vertex"
            },
            {
              "description": "The fragment stage, which computes pixel colors.",
              "name": "fragment"
            },
            {
              "description": "The compute stage, which performs arbitrary computation.",
              "name": "compute"
            }
          ]
        },
        {
          "description": "The two types of shaders that can be created.",
          "key": "ShaderType",
          "module": "lovr.graphics",
          "name": "ShaderType",
          "related": [
            "lovr.graphics.newShader",
            "Shader:getType",
            "ShaderStage",
            "lovr.graphics"
          ],
          "summary": "Different types of Shaders.",
          "values": [
            {
              "description": "A graphics shader with a vertex and pixel stage.",
              "name": "graphics"
            },
            {
              "description": "A compute shader with a single compute stage.",
              "name": "compute"
            }
          ]
        },
        {
          "description": "Different types of stacks that can be pushed and popped with `Pass:push` and `Pass:pop`.",
          "key": "StackType",
          "module": "lovr.graphics",
          "name": "StackType",
          "related": ["lovr.graphics"],
          "summary": "Types of stacks that can be pushed and popped.",
          "values": [
            {
              "description": "The transform stack (`Pass:transform`, `Pass:translate`, etc.).",
              "name": "transform"
            },
            {
              "description": "Graphics state, like `Pass:setColor`, `Pass:setFont`, etc.  Notably this does not include camera poses\/projections or shader variables changed with `Pass:send`.",
              "name": "state"
            }
          ]
        },
        {
          "description": "Different ways of updating the stencil buffer with `Pass:setStencilWrite`.",
          "key": "StencilAction",
          "module": "lovr.graphics",
          "name": "StencilAction",
          "related": [
            "Pass:setStencilWrite",
            "Pass:setStencilTest",
            "Pass:setColorWrite",
            "lovr.graphics"
          ],
          "summary": "Different ways of updating the stencil buffer.",
          "values": [
            {
              "description": "Stencil buffer pixels will not be changed by draws.",
              "name": "keep"
            },
            {
              "description": "Stencil buffer pixels will be set to zero.",
              "name": "zero"
            },
            {
              "description": "Stencil buffer pixels will be replaced with a custom value.",
              "name": "replace"
            },
            {
              "description": "Stencil buffer pixels will be incremented each time they\u0027re rendered to.",
              "name": "increment"
            },
            {
              "description": "Stencil buffer pixels will be decremented each time they\u0027re rendered to.",
              "name": "decrement"
            },
            {
              "description": "Similar to increment, but will wrap around to 0 when it exceeds 255.",
              "name": "incrementwrap"
            },
            {
              "description": "Similar to decrement, but will wrap around to 255 when it goes below 0.",
              "name": "decrementwrap"
            },
            {
              "description": "The bits in the stencil buffer pixels will be inverted.",
              "name": "invert"
            }
          ]
        },
        {
          "description": "These are the different ways `Texture` objects can be used.  These are passed in to `lovr.graphics.isFormatSupported` to see which texture operations are supported by the GPU for a given format.",
          "key": "TextureFeature",
          "module": "lovr.graphics",
          "name": "TextureFeature",
          "related": ["lovr.graphics"],
          "summary": "Different ways Textures can be used.",
          "values": [
            {
              "description": "The Texture can be sampled (e.g. used in a `Material` or sent to a `texture2D` variable in shaders).",
              "name": "sample"
            },
            {
              "description": "The Texture can used as a canvas in a `Pass`.",
              "name": "render"
            },
            {
              "description": "The Texture can be sent to a storage image variable in shaders (e.g. `image2D`).",
              "name": "storage"
            },
            {
              "description": "The Texture can be used with `Pass:blit` and `Pass:generateMipmaps`.",
              "name": "blit"
            }
          ]
        },
        {
          "description": "Different types of textures.  Textures are multidimensional blocks of GPU memory, and the texture\u0027s type determines how many dimensions there are, and adds some semantics about what the 3rd dimension means.",
          "key": "TextureType",
          "module": "lovr.graphics",
          "name": "TextureType",
          "related": ["lovr.graphics"],
          "summary": "The different types of textures.",
          "values": [
            {
              "description": "A single 2D image, the most common type.",
              "name": "2d"
            },
            {
              "description": "A 3D image, where a sequence of 2D images defines a 3D volume.  Each mipmap level of a 3D texture gets smaller in the x, y, and z axes, unlike cubemap and array textures.",
              "name": "3d"
            },
            {
              "description": "Six square 2D images with the same dimensions that define the faces of a cubemap, used for skyboxes or other \"directional\" images.  Can also have higher multiples of 6 images, which will be interpreted as a cubemap array image.",
              "name": "cube"
            },
            {
              "description": "Array textures are sequences of distinct 2D images that all have the same dimensions.",
              "name": "array"
            }
          ]
        },
        {
          "description": "These are the different things `Texture`s can be used for.  When creating a Texture, a set of these flags can be provided, restricting what operations are allowed on the texture.  Using a smaller set of flags may improve performance.  If none are provided, the only usage flag applied is `sample`.",
          "key": "TextureUsage",
          "module": "lovr.graphics",
          "name": "TextureUsage",
          "related": ["lovr.graphics"],
          "summary": "Different operations `Texture` can be used for.",
          "values": [
            {
              "description": "Whether the texture can be sampled from in Shaders (i.e. used in a material, or bound to a variable with a `texture` type, like `texture2D`).",
              "name": "sample"
            },
            {
              "description": "Whether the texture can be rendered to (i.e. by using it as a render target in `lovr.graphics.pass`).",
              "name": "render"
            },
            {
              "description": "Whether the texture can be used as a storage texture for compute operations (i.e. bound to a variable with an `image` type, like `image2D`).",
              "name": "storage"
            },
            {
              "description": "Whether the texture can be used for transfer operations like `Texture:setPixels`, `Texture:blit`, etc.",
              "name": "transfer"
            }
          ]
        },
        {
          "description": "Different ways to vertically align text with `Pass:text`.",
          "key": "VerticalAlign",
          "module": "lovr.graphics",
          "name": "VerticalAlign",
          "related": [
            "HorizontalAlign",
            "Pass:text",
            "Font:getVertices",
            "lovr.graphics"
          ],
          "summary": "Different ways to vertically align text.",
          "values": [
            { "description": "Top-aligned text.", "name": "top" },
            { "description": "Centered text.", "name": "middle" },
            { "description": "Bottom-aligned text.", "name": "bottom" }
          ]
        },
        {
          "description": "Indicates whether the front face of a triangle uses the clockwise or counterclockwise vertex order.",
          "key": "Winding",
          "module": "lovr.graphics",
          "name": "Winding",
          "related": ["Pass:setWinding", "Pass:setCullMode", "lovr.graphics"],
          "summary": "Different triangle windings.",
          "values": [
            { "description": "Clockwise winding.", "name": "clockwise" },
            {
              "description": "Counterclockwise winding.",
              "name": "counterclockwise"
            }
          ]
        },
        {
          "description": "Controls how `Sampler` objects wrap textures.",
          "key": "WrapMode",
          "module": "lovr.graphics",
          "name": "WrapMode",
          "related": ["lovr.graphics"],
          "summary": "Different ways to wrap textures.",
          "values": [
            {
              "description": "Pixels will be clamped to the edge, with pixels outside the 0-1 uv range using colors from the nearest edge.",
              "name": "clamp"
            },
            { "description": "Tiles the texture.", "name": "repeat" },
            {
              "description": "Similar to `repeat`, but flips the texture each time it repeats.",
              "name": "mirror"
            },
            {
              "description": "Similar to `clamp`, but everything outside the 0-1 uv range will be filled with transparent black, i.e. `(0, 0, 0, 0)`.",
              "name": "border"
            }
          ]
        }
      ],
      "functions": [
        {
          "description": "Compiles shader code to SPIR-V bytecode.  The bytecode can be passed to `lovr.graphics.newShader` to create shaders, which will be faster than creating it from GLSL. The bytecode is portable, so bytecode compiled on one platform will work on other platforms. This allows shaders to be precompiled in a build step.",
          "key": "lovr.graphics.compileShader",
          "module": "lovr.graphics",
          "name": "compileShader",
          "notes": "The input can be GLSL or SPIR-V.  If it\u0027s SPIR-V, it will be returned unchanged as a Blob.\n\nIf the shader fails to compile, an error will be thrown with the error message.",
          "related": ["lovr.graphics.newShader", "Shader", "lovr.graphics"],
          "summary": "Compile shader code to bytecode.",
          "tag": "graphics-objects",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The type of shader to compile.",
                  "name": "stage",
                  "type": "ShaderStage"
                },
                {
                  "description": "A string or filename with shader code.",
                  "name": "source",
                  "type": "string"
                }
              ],
              "returns": [
                {
                  "description": "A Blob containing compiled SPIR-V code.",
                  "name": "bytecode",
                  "type": "Blob"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The type of shader to compile.",
                  "name": "stage",
                  "type": "ShaderStage"
                },
                {
                  "description": "A Blob containing shader code.",
                  "name": "blob",
                  "type": "Blob"
                }
              ],
              "returns": [
                {
                  "description": "A Blob containing compiled SPIR-V code.",
                  "name": "bytecode",
                  "type": "Blob"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the global background color.  The textures in a render pass will be cleared to this color at the beginning of the pass if no other clear option is specified.  Additionally, the headset and window will be cleared to this color before rendering.",
          "key": "lovr.graphics.getBackgroundColor",
          "module": "lovr.graphics",
          "name": "getBackgroundColor",
          "notes": "Setting the background color in `lovr.draw` will apply on the following frame, since the default pass is cleared before `lovr.draw` is called.\n\nInternally, this color is applied to the default pass objects when retrieving one of them using `lovr.headset.getPass` or `lovr.graphics.getWindowPass`.  Both are called automatically by the default `lovr.run` implementation.\n\nUsing the background color to clear the display is expected to be more efficient than manually clearing after a render pass begins, especially on mobile GPUs.",
          "related": [
            "lovr.graphics.newPass",
            "Pass:setClear",
            "Texture:clear",
            "Pass:fill",
            "lovr.graphics.setBackgroundColor",
            "lovr.graphics"
          ],
          "summary": "Get the background color.",
          "tag": "graphics-global",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The red component of the background color.",
                  "name": "r",
                  "type": "number"
                },
                {
                  "description": "The green component of the background color.",
                  "name": "g",
                  "type": "number"
                },
                {
                  "description": "The blue component of the background color.",
                  "name": "b",
                  "type": "number"
                },
                {
                  "description": "The alpha component of the background color.",
                  "name": "a",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the default Font.  The default font is Varela Round, created at 32px with a spread value of `4.0`.  It\u0027s used by `Pass:text` if no Font is provided.",
          "key": "lovr.graphics.getDefaultFont",
          "module": "lovr.graphics",
          "name": "getDefaultFont",
          "related": ["Pass:text", "lovr.graphics.newFont", "lovr.graphics"],
          "summary": "Get the default Font.",
          "tag": "graphics-objects",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The default Font object.",
                  "name": "font",
                  "type": "Font"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns information about the graphics device and driver.",
          "key": "lovr.graphics.getDevice",
          "module": "lovr.graphics",
          "name": "getDevice",
          "notes": "The device and vendor ID numbers will usually be PCI IDs, which are standardized numbers consisting of 4 hex digits.  Various online databases and system utilities can be used to look up these numbers.  Here are some example vendor IDs for a few popular GPU manufacturers:\n\n\u003ctable\u003e\n  \u003cthead\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eID\u003c\/td\u003e\n      \u003ctd\u003eVendor\u003c\/td\u003e\n    \u003c\/tr\u003e\n  \u003c\/thead\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003e0x1002\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003eAdvanced Micro Devices, Inc.\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003e0x8086\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003eIntel Corporation\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003e0x10de\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003eNVIDIA Corporation\u003c\/td\u003e\n    \u003c\/tr\u003e\n  \u003c\/tbody\u003e \u003c\/table\u003e\n\nIt is not currently possible to get the version of the driver, although this could be added.\n\nRegarding multiple GPUs: If OpenXR is enabled, the OpenXR runtime has control over which GPU is used, which ensures best compatibility with the VR headset.  Otherwise, the \"first\" GPU returned by the renderer will be used.  There is currently no other way to pick a GPU to use.",
          "related": [
            "lovr.graphics.getFeatures",
            "lovr.graphics.getLimits",
            "lovr.graphics"
          ],
          "summary": "Get information about the graphics device and driver.",
          "tag": "graphics-misc",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "name": "device",
                  "table": [
                    {
                      "description": "The vendor-unique number for this GPU.",
                      "name": "id",
                      "type": "number"
                    },
                    {
                      "description": "The identifier of the GPU vendor.",
                      "name": "vendor",
                      "type": "number"
                    },
                    {
                      "description": "The name of the GPU.",
                      "name": "name",
                      "type": "string"
                    },
                    {
                      "description": "The renderer in use, currently either \"Vulkan\" or \"WebGPU\".",
                      "name": "renderer",
                      "type": "string"
                    },
                    {
                      "description": "The number of threads that run in a single GPU compute unit.  This is usually 32 or 64, and is sometimes called the \"wave\" or \"warp\" size.  This can be used to optimize compute shaders for the current hardware.",
                      "name": "subgroupSize",
                      "type": "number"
                    },
                    {
                      "description": "Whether the GPU is a discrete graphics card.",
                      "name": "discrete",
                      "type": "boolean"
                    }
                  ],
                  "type": "table"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns a table indicating which features are supported by the GPU.",
          "key": "lovr.graphics.getFeatures",
          "module": "lovr.graphics",
          "name": "getFeatures",
          "related": [
            "lovr.graphics.isFormatSupported",
            "lovr.graphics.getDevice",
            "lovr.graphics.getLimits",
            "lovr.graphics"
          ],
          "summary": "Get the supported GPU features.",
          "tag": "graphics-misc",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "",
                  "name": "features",
                  "table": [
                    {
                      "description": "Whether `TextureFormat`s starting with `bc` are supported. This will almost always be `true` on desktop GPUs and will almost always be `false` on mobile GPUs.",
                      "name": "textureBC",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether `TextureFormat`s beginning with `astc` are supported.  This will almost always be `true` on mobile GPUs and will almost always be `false` on desktop GPUs.",
                      "name": "textureASTC",
                      "type": "boolean"
                    },
                    {
                      "description": "When supported, `Pass:setWireframe` will work, otherwise it will do nothing. This will always be `true` when using Vulkan, and will always be `false` when using WebGPU.",
                      "name": "wireframe",
                      "type": "boolean"
                    },
                    {
                      "description": "When supported, `Pass:setDepthClamp` will work, otherwise it will do nothing.",
                      "name": "depthClamp",
                      "type": "boolean"
                    },
                    {
                      "description": "When supported, multisampled render passes can use a non-multisampled depth texture. Otherwise, the depth texture sample count needs to match the render pass sample count.",
                      "name": "depthResolve",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether indirect draws can set the firstInstance property of buffer memory to something other than zero.",
                      "name": "indirectDrawFirstInstance",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether shader code can use doubles.",
                      "name": "float64",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether shader code can use signed and unsigned 64-bit integers.",
                      "name": "int64",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether shader code can use signed and unsigned 16-bit integers.",
                      "name": "int16",
                      "type": "boolean"
                    }
                  ],
                  "type": "table"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns limits of the current GPU.",
          "key": "lovr.graphics.getLimits",
          "module": "lovr.graphics",
          "name": "getLimits",
          "notes": "The limit ranges are as follows:\n\n\u003ctable\u003e\n  \u003cthead\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eLimit\u003c\/td\u003e\n      \u003ctd\u003eMinimum\u003c\/td\u003e\n      \u003ctd\u003eMaximum\u003c\/td\u003e\n    \u003c\/tr\u003e\n  \u003c\/thead\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003etextureSize2D\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003e4096\u003c\/td\u003e\n      \u003ctd\u003e\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003etextureSize3D\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003e256\u003c\/td\u003e\n      \u003ctd\u003e\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003etextureSizeCube\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003e4096\u003c\/td\u003e\n      \u003ctd\u003e\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003etextureLayers\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003e256\u003c\/td\u003e\n      \u003ctd\u003e\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003erenderSize\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003e{ 4096, 4096, 6 }\u003c\/td\u003e\n      \u003ctd\u003e\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003euniformBuffersPerStage\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003e9\u003c\/td\u003e\n      \u003ctd\u003e32*\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003estorageBuffersPerStage\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003e4\u003c\/td\u003e\n      \u003ctd\u003e32*\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003esampledTexturesPerStage\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003e32\u003c\/td\u003e\n      \u003ctd\u003e32*\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003estorageTexturesPerStage\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003e4\u003c\/td\u003e\n      \u003ctd\u003e32*\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003esamplersPerStage\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003e15\u003c\/td\u003e\n      \u003ctd\u003e32*\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003eresourcesPerShader\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003e32\u003c\/td\u003e\n      \u003ctd\u003e32*\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003euniformBufferRange\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003e65536\u003c\/td\u003e\n      \u003ctd\u003e\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003estorageBufferRange\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003e134217728 (128MB)\u003c\/td\u003e\n      \u003ctd\u003e1073741824 (1GB)*\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003euniformBufferAlign\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003e\u003c\/td\u003e\n      \u003ctd\u003e256\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003estorageBufferAlign\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003e\u003c\/td\u003e\n      \u003ctd\u003e64\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003evertexAttributes\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003e16\u003c\/td\u003e\n      \u003ctd\u003e16*\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003evertexBufferStride\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003e2048\u003c\/td\u003e\n      \u003ctd\u003e65535*\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003evertexShaderOutputs\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003e64\u003c\/td\u003e\n      \u003ctd\u003e\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003eclipDistances\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003e0\u003c\/td\u003e\n      \u003ctd\u003e\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003ecullDistances\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003e0\u003c\/td\u003e\n      \u003ctd\u003e\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003eclipAndCullDistances\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003e0\u003c\/td\u003e\n      \u003ctd\u003e\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003ecomputeDispatchCount\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003e{ 65536, 65536, 65536 }\u003c\/td\u003e\n      \u003ctd\u003e\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003ecomputeWorkgroupSize\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003e{ 128, 128, 64 }\u003c\/td\u003e\n      \u003ctd\u003e\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003ecomputeWorkgroupVolume\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003e128\u003c\/td\u003e\n      \u003ctd\u003e\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003ecomputeSharedMemory\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003e16384 (16KB)\u003c\/td\u003e\n      \u003ctd\u003e\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003epushConstantSize\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003e128\u003c\/td\u003e\n      \u003ctd\u003e256*\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003eindirectDrawCount\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003e1\u003c\/td\u003e\n      \u003ctd\u003e\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003einstances\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003e134217727\u003c\/td\u003e\n      \u003ctd\u003e\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003eanisotropy\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003e0.0\u003c\/td\u003e\n      \u003ctd\u003e\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003epointSize\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003e1.0\u003c\/td\u003e\n      \u003ctd\u003e\u003c\/td\u003e\n    \u003c\/tr\u003e\n  \u003c\/tbody\u003e \u003c\/table\u003e\n\nNote: in the table above, `*` means that L\u00d6VR itself is imposing a cap on the limit, instead of the GPU.",
          "related": [
            "lovr.graphics.isFormatSupported",
            "lovr.graphics.getDevice",
            "lovr.graphics.getFeatures",
            "lovr.graphics"
          ],
          "summary": "Get the limits of the current GPU.",
          "tag": "graphics-misc",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "",
                  "name": "limits",
                  "table": [
                    {
                      "description": "The maximum width\/height of `2d` and `array` textures.",
                      "name": "textureSize2D",
                      "type": "number"
                    },
                    {
                      "description": "The maximum width\/height\/depth of `3d` textures.",
                      "name": "textureSize3D",
                      "type": "number"
                    },
                    {
                      "description": "The maximum width\/height of `cube` textures.",
                      "name": "textureSizeCube",
                      "type": "number"
                    },
                    {
                      "description": "The maximum depth of `array` textures.",
                      "name": "textureLayers",
                      "type": "number"
                    },
                    {
                      "description": "The maximum width, height, and layer count of a texture (or texture view) used as a render target.",
                      "name": "renderSize",
                      "type": "table"
                    },
                    {
                      "description": "The maximum number of uniform buffers in a shader stage.",
                      "name": "uniformBuffersPerStage",
                      "type": "number"
                    },
                    {
                      "description": "The maximum number of storage buffers in a shader stage.",
                      "name": "storageBuffersPerStage",
                      "type": "number"
                    },
                    {
                      "description": "The maximum number of sampled textures in a shader stage.",
                      "name": "sampledTexturesPerStage",
                      "type": "number"
                    },
                    {
                      "description": "The maximum number of storage textures in a shader stage.",
                      "name": "storageTexturesPerStage",
                      "type": "number"
                    },
                    {
                      "description": "The maximum number of samplers in a shader stage.",
                      "name": "samplersPerStage",
                      "type": "number"
                    },
                    {
                      "description": "The maximum combined number of buffers, textures, and sampler variables in a Shader.",
                      "name": "resourcesPerShader",
                      "type": "number"
                    },
                    {
                      "description": "The maximum range of bytes that can be bound to a uniform buffer in a shader.",
                      "name": "uniformBufferRange",
                      "type": "number"
                    },
                    {
                      "description": "The maximum range of bytes that can be bound to a storage buffer in a shader.",
                      "name": "storageBufferRange",
                      "type": "number"
                    },
                    {
                      "description": "When binding a range of bytes to a uniform buffer binding in a shader, the byte offset of the range must be a multiple of this limit\u0027s value.",
                      "name": "uniformBufferAlign",
                      "type": "number"
                    },
                    {
                      "description": "When binding a range of bytes to a storage buffer binding in a shader, the byte offset of the range must be a multiple of this limit\u0027s value.",
                      "name": "storageBufferAlign",
                      "type": "number"
                    },
                    {
                      "description": "The maximum number of input attributes in a vertex shader.",
                      "name": "vertexAttributes",
                      "type": "number"
                    },
                    {
                      "description": "The maximum stride of a buffer used as a vertex buffer, in bytes.",
                      "name": "vertexBufferStride",
                      "type": "number"
                    },
                    {
                      "description": "The maximum number of components output from a vertex shader.",
                      "name": "vertexShaderOutputs",
                      "type": "number"
                    },
                    {
                      "description": "The maximum number of clipping planes declared by a shader.",
                      "name": "clipDistances",
                      "type": "number"
                    },
                    {
                      "description": "The maximum number of cull distances declared by a shader.",
                      "name": "cullDistances",
                      "type": "number"
                    },
                    {
                      "description": "The maximum number of clipping planes and cull distances declared by a shader.",
                      "name": "clipAndCullDistances",
                      "type": "number"
                    },
                    {
                      "description": "The maximum values of `x`, `y`, and `z` in `Pass:compute`.",
                      "name": "workgroupCount",
                      "type": "table"
                    },
                    {
                      "description": "The maximum values of `local_size_x`, `local_size_y`, and `local_size_z` declared in a compute shader.",
                      "name": "workgroupSize",
                      "type": "table"
                    },
                    {
                      "description": "The maximum product of `local_size_x`, `local_size_y`, and `local_size_z` in a compute shader.",
                      "name": "totalWorkgroupSize",
                      "type": "number"
                    },
                    {
                      "description": "The maximum number of bytes used by `shared` variables in compute shaders.",
                      "name": "computeSharedMemory",
                      "type": "number"
                    },
                    {
                      "description": "The maximum number of draws that can be issued by an indirect draw call.",
                      "name": "indirectDrawCount",
                      "type": "number"
                    },
                    {
                      "description": "The maximum number of instances that can be rendered in a draw call.",
                      "name": "instances",
                      "type": "number"
                    },
                    {
                      "description": "The maximum value of the `anisotropy` parameter in `lovr.graphics.newSampler`.",
                      "name": "anisotropy",
                      "type": "number"
                    },
                    {
                      "description": "The maximum point size.",
                      "name": "pointSize",
                      "type": "number"
                    }
                  ],
                  "type": "table"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the window pass.  This is a builtin render `Pass` object that renders to the desktop window texture.  If the desktop window was not open when the graphics module was initialized, this function will return `nil`.",
          "key": "lovr.graphics.getWindowPass",
          "module": "lovr.graphics",
          "name": "getWindowPass",
          "notes": "`lovr.conf` may be used to change the settings for the pass:  `t.graphics.antialias` enables antialiasing, and `t.graphics.stencil` enables the stencil buffer.\n\nThis pass clears the window texture to the background color, which can be changed using `lovr.graphics.setBackgroundColor`.",
          "related": ["lovr.graphics"],
          "summary": "Get the window pass.",
          "tag": "graphics-objects",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The window pass, or `nil` if there is no window.",
                  "name": "pass",
                  "type": "Pass"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the type of operations the GPU supports for a texture format, if any.",
          "key": "lovr.graphics.isFormatSupported",
          "module": "lovr.graphics",
          "name": "isFormatSupported",
          "related": [
            "lovr.graphics.getDevice",
            "lovr.graphics.getFeatures",
            "lovr.graphics.getLimits",
            "lovr.graphics"
          ],
          "summary": "Check if a Texture format is supported.",
          "tag": "graphics-misc",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The texture format to query.",
                  "name": "format",
                  "type": "TextureFormat"
                },
                {
                  "description": "Zero or more features to check.  If no features are given, this function will return whether the GPU supports *any* feature for this format.  Otherwise, this function will only return true if *all* of the input features are supported.",
                  "name": "...features",
                  "type": "TextureFeature"
                }
              ],
              "returns": [
                {
                  "description": "Whether the GPU supports these operations for textures with this format, when created with the `linear` flag set to `true`.",
                  "name": "linear",
                  "type": "boolean"
                },
                {
                  "description": "Whether the GPU supports these operations for textures with this format, when created with the `linear` flag set to `false`.",
                  "name": "srgb",
                  "type": "boolean"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns whether timing stats are enabled.  When enabled, `Pass:getStats` will return `submitTime` and `gpuTime` durations.  Timing is enabled by default when `t.graphics.debug` is set in `lovr.conf`.  Timing has a small amount of overhead, so it should only be enabled when needed.",
          "key": "lovr.graphics.isTimingEnabled",
          "module": "lovr.graphics",
          "name": "isTimingEnabled",
          "related": [
            "Pass:getStats",
            "lovr.graphics.setTimingEnabled",
            "lovr.graphics"
          ],
          "summary": "Check if timing stats are enabled.",
          "tag": "graphics-global",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "Whether timing is enabled.",
                  "name": "enabled",
                  "type": "boolean"
                }
              ]
            }
          ]
        },
        {
          "description": "Creates a Buffer.",
          "examples": [
            {
              "code": "-- 2 matrices\nlovr.graphics.newBuffer(\u0027mat4\u0027, 2)\n\n-- 3 integers, with initial data\nlovr.graphics.newBuffer(\u0027int\u0027, { 1, 2, 3 })\n\n-- a simple mesh:\nlovr.graphics.newBuffer({\n  { name \u003d \u0027VertexPosition\u0027, type \u003d \u0027vec3\u0027 },\n  { name \u003d \u0027VertexColor\u0027, type \u003d \u0027color\u0027 }\n}, 4)\n\n-- a uniform buffer with vec3\u0027s, using the std140 packing\nlovr.graphics.newBuffer({ \u0027vec3\u0027, layout \u003d \u0027std140\u0027 }, data)\n\n-- a uniform buffer with key-value fields\nlovr.graphics.newBuffer({\n  { \u0027AmbientColor\u0027, \u0027vec3\u0027 },\n  { \u0027LightPosition\u0027, \u0027vec3\u0027 },\n  { \u0027LightType\u0027, \u0027u32\u0027 },\n  { \u0027LightColor\u0027, \u0027vec4\u0027 },\n  layout \u003d \u0027std140\u0027\n})\n\n-- a buffer with nested structure and array types\nlovr.graphics.newBuffer({\n  { \u0027globals\u0027, {\n    { \u0027ObjectCount\u0027, \u0027int\u0027 },\n    { \u0027WorldSize\u0027, \u0027vec2\u0027 },\n    { \u0027Scale\u0027, \u0027float\u0027 }\n  }},\n  { \u0027materials\u0027, {\n    { \u0027Color\u0027, \u0027vec4\u0027 },\n    { \u0027Glow\u0027, \u0027vec3\u0027 },\n    { \u0027Roughness\u0027, \u0027float\u0027 }\n  }, length \u003d 32 },\n  layout \u003d \u0027std430\u0027\n})\n\n-- a buffer using a variable from a shader:\nlovr.graphics.newBuffer(shader:getBufferFormat(\u0027transforms\u0027))",
              "description": "Examples of different buffer formats."
            }
          ],
          "key": "lovr.graphics.newBuffer",
          "module": "lovr.graphics",
          "name": "newBuffer",
          "notes": "The format table can contain a list of `DataType`s or a list of tables to provide extra information about each field.  Each inner table has the following keys:\n\n- `type` is the `DataType` of the field and is required.\n- `name` is the name of the field, used to match table keys and vertex attribute names.\n- `offset` is the byte offset of the field.  Any fields with a `nil` offset will be placed next\n  to each other sequentially in memory, subject to any padding required by the Buffer\u0027s layout.\n  In practice this means that you probably want to provide an `offset` for either all of the\n  fields or none of them.\n- `length` is the array size of the field.\n\nAs a shorthand, the name, type, and optionally the length of a field can be provided as a list instead of using keys.\n\nIf no table or Blob is used to define the initial Buffer contents, its data will be undefined.",
          "related": ["Shader:getBufferFormat", "lovr.graphics"],
          "summary": "Create a new Buffer.",
          "tag": "graphics-objects",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The size of the Buffer, in bytes.",
                  "name": "size",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "The new Buffer.",
                  "name": "buffer",
                  "type": "Buffer"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "A Blob with the initial contents of the Buffer.  The size of the Blob will be used to determine the length of the Buffer.",
                  "name": "blob",
                  "type": "Blob"
                }
              ],
              "returns": [
                {
                  "description": "The new Buffer.",
                  "name": "buffer",
                  "type": "Buffer"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "A list of fields in the Buffer.",
                  "name": "format",
                  "table": [
                    {
                      "default": "packed",
                      "description": "How to lay out the Buffer fields in memory.",
                      "name": "layout",
                      "type": "DataLayout"
                    },
                    {
                      "description": "The stride of the Buffer, in bytes.  When `nil`, the stride will be automatically computed based on the fields.  The stride can not be zero or smaller than the max byte occupied by one of the fields.  The layout of the Buffer may adjust the stride.",
                      "name": "stride",
                      "type": "number"
                    }
                  ],
                  "type": "table"
                },
                {
                  "default": "1",
                  "description": "The length of the Buffer.",
                  "name": "length",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "The new Buffer.",
                  "name": "buffer",
                  "type": "Buffer"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "A list of fields in the Buffer.",
                  "name": "format",
                  "table": [
                    {
                      "default": "packed",
                      "description": "How to lay out the Buffer fields in memory.",
                      "name": "layout",
                      "type": "DataLayout"
                    },
                    {
                      "description": "The stride of the Buffer, in bytes.  When `nil`, the stride will be automatically computed based on the fields.  The stride can not be zero or smaller than the max byte occupied by one of the fields.  The layout of the Buffer may adjust the stride.",
                      "name": "stride",
                      "type": "number"
                    }
                  ],
                  "type": "table"
                },
                {
                  "description": "The initial data to put into the Buffer.  The length of the Buffer will be determined by the contents of the table.  The contents can be a mix of tables, numbers, and vectors, but the length calculation requires each field to consistently use one type of data.",
                  "name": "data",
                  "type": "table"
                }
              ],
              "returns": [
                {
                  "description": "The new Buffer.",
                  "name": "buffer",
                  "type": "Buffer"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "A list of fields in the Buffer.",
                  "name": "format",
                  "table": [
                    {
                      "default": "packed",
                      "description": "How to lay out the Buffer fields in memory.",
                      "name": "layout",
                      "type": "DataLayout"
                    },
                    {
                      "description": "The stride of the Buffer, in bytes.  When `nil`, the stride will be automatically computed based on the fields.  The stride can not be zero or smaller than the max byte occupied by one of the fields.  The layout of the Buffer may adjust the stride.",
                      "name": "stride",
                      "type": "number"
                    }
                  ],
                  "type": "table"
                },
                {
                  "description": "A Blob with the initial contents of the Buffer.  The size of the Blob will be used to determine the length of the Buffer.",
                  "name": "blob",
                  "type": "Blob"
                }
              ],
              "returns": [
                {
                  "description": "The new Buffer.",
                  "name": "buffer",
                  "type": "Buffer"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The type of each item in the Buffer.",
                  "name": "type",
                  "type": "DataType"
                },
                {
                  "default": "1",
                  "description": "The length of the Buffer.",
                  "name": "length",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "The new Buffer.",
                  "name": "buffer",
                  "type": "Buffer"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The type of each item in the Buffer.",
                  "name": "type",
                  "type": "DataType"
                },
                {
                  "description": "The initial data to put into the Buffer.  The length of the Buffer will be determined by the contents of the table.  The contents can be a mix of tables, numbers, and vectors, but the length calculation requires each field to consistently use one type of data.",
                  "name": "data",
                  "type": "table"
                }
              ],
              "returns": [
                {
                  "description": "The new Buffer.",
                  "name": "buffer",
                  "type": "Buffer"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The type of each item in the Buffer.",
                  "name": "type",
                  "type": "DataType"
                },
                {
                  "description": "A Blob with the initial contents of the Buffer.  The size of the Blob will be used to determine the length of the Buffer.",
                  "name": "blob",
                  "type": "Blob"
                }
              ],
              "returns": [
                {
                  "description": "The new Buffer.",
                  "name": "buffer",
                  "type": "Buffer"
                }
              ]
            }
          ]
        },
        {
          "description": "Creates a new Font.",
          "key": "lovr.graphics.newFont",
          "module": "lovr.graphics",
          "name": "newFont",
          "related": [
            "lovr.graphics.getDefaultFont",
            "lovr.data.newRasterizer",
            "Pass:text",
            "lovr.graphics"
          ],
          "summary": "Create a new Font.",
          "tag": "graphics-objects",
          "variants": [
            {
              "arguments": [
                {
                  "description": "A path to a TTF or BMFont file.",
                  "name": "filename",
                  "type": "string"
                },
                {
                  "default": "32",
                  "description": "The size of the Font in pixels (TTF only).  Larger sizes are slower to initialize and use more memory, but have better quality.",
                  "name": "size",
                  "type": "number"
                },
                {
                  "default": "4",
                  "description": "For signed distance field fonts (currently all fonts), the width of the SDF, in pixels.  The greater the distance the font is viewed from, the larger this value needs to be for the font to remain properly antialiased.  Increasing this will have a performance penalty similar to increasing the size of the font.",
                  "name": "spread",
                  "type": "number"
                }
              ],
              "description": "Creates a new Font from a font file.",
              "returns": [
                {
                  "description": "The new Font.",
                  "name": "font",
                  "type": "Font"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "A Blob containing TTF or BMFont file data.",
                  "name": "blob",
                  "type": "Blob"
                },
                {
                  "default": "32",
                  "description": "The size of the Font in pixels (TTF only).  Larger sizes are slower to initialize and use more memory, but have better quality.",
                  "name": "size",
                  "type": "number"
                },
                {
                  "default": "4",
                  "description": "For signed distance field fonts (currently all fonts), the width of the SDF, in pixels.  The greater the distance the font is viewed from, the larger this value needs to be for the font to remain properly antialiased.  Increasing this will have a performance penalty similar to increasing the size of the font.",
                  "name": "spread",
                  "type": "number"
                }
              ],
              "description": "Creates a new Font from font data.",
              "returns": [
                {
                  "description": "The new Font.",
                  "name": "font",
                  "type": "Font"
                }
              ]
            },
            {
              "arguments": [
                {
                  "default": "32",
                  "description": "The size of the Font in pixels (TTF only).  Larger sizes are slower to initialize and use more memory, but have better quality.",
                  "name": "size",
                  "type": "number"
                },
                {
                  "default": "4",
                  "description": "For signed distance field fonts (currently all fonts), the width of the SDF, in pixels.  The greater the distance the font is viewed from, the larger this value needs to be for the font to remain properly antialiased.  Increasing this will have a performance penalty similar to increasing the size of the font.",
                  "name": "spread",
                  "type": "number"
                }
              ],
              "description": "Creates a new Font using the default typeface (Varela Round).",
              "returns": [
                {
                  "description": "The new Font.",
                  "name": "font",
                  "type": "Font"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "An existing Rasterizer to use to load glyph images.",
                  "name": "rasterizer",
                  "type": "Rasterizer"
                },
                {
                  "default": "4",
                  "description": "For signed distance field fonts (currently all fonts), the width of the SDF, in pixels.  The greater the distance the font is viewed from, the larger this value needs to be for the font to remain properly antialiased.  Increasing this will have a performance penalty similar to increasing the size of the font.",
                  "name": "spread",
                  "type": "number"
                }
              ],
              "description": "Creates a new Font from an existing Rasterizer.",
              "returns": [
                {
                  "description": "The new Font.",
                  "name": "font",
                  "type": "Font"
                }
              ]
            }
          ]
        },
        {
          "description": "Creates a new Material from a table of properties and textures.  All fields are optional.  Once a Material is created, its properties can not be changed.  Instead, a new Material should be created with the updated properties.",
          "key": "lovr.graphics.newMaterial",
          "module": "lovr.graphics",
          "name": "newMaterial",
          "notes": "The non-texture material properties can be accessed in shaders using `Material.\u003cproperty\u003e`, where the property is the same as the Lua table key.  The textures use capitalized names in shader code, e.g. `ColorTexture`.",
          "related": ["lovr.graphics"],
          "summary": "Create a new Material.",
          "tag": "graphics-objects",
          "variants": [
            {
              "arguments": [
                {
                  "description": "Material properties.",
                  "name": "properties",
                  "table": [
                    {
                      "default": "{ 1, 1, 1, 1 }",
                      "description": "The base color of the surface.  Can be a `Vec3`, `Vec4`, table of numbers, or hexcode. Can be toggled in shaders using the `materialColor` flag, which defaults to `true`.",
                      "name": "color",
                      "type": "Vec4"
                    },
                    {
                      "default": "{ 0, 0, 0, 0 }",
                      "description": "The glow color of the surface, sometimes called \"emissive\".  The glow is not affected by lighting, so it\u0027s a good fit for e.g. headlights on a car or LED lights on a panel.  The alpha of the glow color is used as the glow strength.  Can be a `Vec3`, `Vec4`, table of numbers, or hexcode.  Can be toggled in shaders using the `glow` flag, which defaults to `false`.",
                      "name": "glow",
                      "type": "Vec4"
                    },
                    {
                      "default": "{ 0, 0 }",
                      "description": "An offset to apply to the UV coordinates used to sample textures.  The offset is not affected by `uvScale`.  This can be used to map UV coordinates to a sub-rectangle of a texture atlas.  Can be a `Vec2`, table of numbers, or a single number which gets assigned to both axes.  Can be toggled in shaders using the `uvTransform` flag, which defaults to `true`.",
                      "name": "uvShift",
                      "type": "Vec2"
                    },
                    {
                      "default": "{ 1, 1 }",
                      "description": "A scale factor to apply to the UV coordinates used to sample textures.  The scale is not affected by `uvOffset`.  This can be used to map UV coordinates to a sub-rectangle of a texture atlas, or repeat a texture multiple times across a surface.  Can be a `Vec2`, table of numbers, or a single number which gets assigned to both axes. Can be toggled in shaders using the `uvTransform` flag, which defaults to `true`.",
                      "name": "uvScale",
                      "type": "Vec2"
                    },
                    {
                      "default": "0",
                      "description": "The metalness the surface, used for physically-based rendering.  1.0 means the surface is metallic (conductor), and 0.0 means the surface is non-metallic (dielectric).  Values in between are seldom used and are only used in textures to transition between a metallic and non-metallic surface.  Metals reflect light differently than non-metals. Used by the lighting helper functions `initSurface` and `getLighting`.",
                      "name": "metalness",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The roughness of the surface, used for physically-based rendering.  1.0 means the surface is rough (blurry reflections), and 0.0 means the surface is smooth (sharp reflections).  Used by the lighting helper functions `initSurface` and `getLighting`.",
                      "name": "roughness",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The clearcoat factor.  Not currently used by L\u00d6VR.",
                      "name": "clearcoat",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The roughness of the clearcoat layer.  Not currently used by L\u00d6VR.",
                      "name": "clearcoatRoughness",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The strength of the ambient occlusion effect.  Ambient occlusion only affects indirect lighting.  Used by the lighting helper functions `initSurface` and `getIndirectLighting`.  Can be toggled in shaders using the `ambientOcclusion` flag, which defaults to `true`.",
                      "name": "occlusionStrength",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The strength of the normal map.  Used by the `initSurface` function to bend the surface normal.  Can be toggled in shaders using the `normalMap` flag, which defaults to `false`.",
                      "name": "normalScale",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The alpha cutoff.  At the end of the fragment shader, if the alpha of the final color is below the alpha cutoff, then the pixel will be \"discarded\" which means that it won\u0027t write a depth value.  Often used for transparent textures, especially with the \"alpha to coverage\" state set by `Pass:setAlphaToCoverage`.  Can be toggled in shaders using the `alphaCutoff` flag, which defaults to `false`.",
                      "name": "alphaCutoff",
                      "type": "number"
                    },
                    {
                      "description": "The base color texture.  In shaders this gets multiplied with the `color` property to get the base color of the pixel.  Can be toggled in shaders using the `colorTexture` flag, which defaults to `true`.",
                      "name": "texture",
                      "type": "Texture"
                    },
                    {
                      "description": "The glow color texture.  In shaders, samples from this texture get multiplied with the `glow` property to get the glow color of the pixel.  Can be toggled in shaders using the `glowTexture` flag, which defaults to `true` (also requires the `glow` flag to be enabled).",
                      "name": "glowTexture",
                      "type": "Texture"
                    },
                    {
                      "description": "The metalness texture.  In shaders, samples from the blue channel of this texture get multiplied with the `metalness` property to get the metalness value of the pixel.  Can be toggled in shaders using the `metalnessTexture` flag, which defaults to `true`.",
                      "name": "metalnessTexture",
                      "type": "Texture"
                    },
                    {
                      "description": "The roughness texture.  In shaders, samples from the green channel of this texture get multiplied with the `roughness` property to get the roughness value of the pixel.  Can be toggled in shaders using the `roughnessTexture` flag, which defaults to `true`.",
                      "name": "roughnessTexture",
                      "type": "Texture"
                    },
                    {
                      "description": "Not currently used by L\u00d6VR.",
                      "name": "clearcoatTexture",
                      "type": "Texture"
                    },
                    {
                      "description": "The ambient occlusion texture.  In shaders, samples from the red channel of this texture get multiplied with the `occlusionStrength` property to get the ambient occlusion value of the pixel. Used by the lighting helper functions `initSurface` and `getIndirectLighting`.  Can be toggled in shaders using the `ambientOcclusion` flag, which defaults to `true`.",
                      "name": "occlusionTexture",
                      "type": "Texture"
                    },
                    {
                      "description": "The normal map, used to apply details to a surface without adding mesh geometry.  The `normalScale` property can be used to control how strong the effect is.  Can be toggled in shaders using the `normalMap` flag, which defaults to `false`.",
                      "name": "normalTexture",
                      "type": "Texture"
                    }
                  ],
                  "type": "table"
                }
              ],
              "returns": [
                {
                  "description": "The new material.",
                  "name": "material",
                  "type": "Material"
                }
              ]
            }
          ]
        },
        {
          "description": "Creates a Mesh.  The capacity of the Mesh must be provided upfront, using either a vertex count or the vertex data itself.  A custom vertex format can be given to specify the set of attributes in each vertex, which get sent to the vertex shader.  If the format isn\u0027t given, the default vertex format will be used:\n\n    {\n      { \u0027VertexPosition\u0027, \u0027vec3\u0027 },\n      { \u0027VertexNormal\u0027, \u0027vec3\u0027 },\n      { \u0027VertexUV\u0027, \u0027vec2\u0027 }\n    }",
          "examples": [
            {
              "code": "function lovr.load()\n  mesh \u003d lovr.graphics.newMesh({\n    { \u0027VertexPosition\u0027, \u0027vec3\u0027 },\n    { \u0027VertexColor\u0027, \u0027vec4\u0027 }\n  }, {\n    {   0,  .4, 0 , 1, 0, 0, 1 },\n    { -.5, -.4, 0 , 0, 1, 0, 1 },\n    {  .5, -.4, 0 , 0, 0, 1, 1 }\n  })\nend\n\nfunction lovr.draw(pass)\n  pass:draw(mesh, 0, 1.7, -1)\nend"
            }
          ],
          "key": "lovr.graphics.newMesh",
          "module": "lovr.graphics",
          "name": "newMesh",
          "notes": "The Mesh will always use the `gpu` storage mode if it\u0027s created from a vertex buffer.",
          "related": [
            "lovr.graphics.newBuffer",
            "lovr.graphics.newModel",
            "lovr.graphics"
          ],
          "summary": "Create a new Mesh.",
          "tag": "graphics-objects",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The number of vertices in the Mesh.",
                  "name": "count",
                  "type": "number"
                },
                {
                  "default": "\u0027cpu\u0027",
                  "description": "The storage mode of the Mesh.",
                  "name": "storage",
                  "type": "MeshStorage"
                }
              ],
              "returns": [
                {
                  "description": "The new Mesh.",
                  "name": "mesh",
                  "type": "Mesh"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "A table of vertices, formatted according to the vertex format.  The length of the table will be used to set the vertex count of the Mesh.",
                  "name": "vertices",
                  "type": "table"
                },
                {
                  "default": "\u0027cpu\u0027",
                  "description": "The storage mode of the Mesh.",
                  "name": "storage",
                  "type": "MeshStorage"
                }
              ],
              "returns": [
                {
                  "description": "The new Mesh.",
                  "name": "mesh",
                  "type": "Mesh"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "A Blob containing vertex data, formatted according to the vertex format.  The size of the Blob will be used to set the vertex count of the Mesh, and must be a multiple of the vertex size.",
                  "name": "blob",
                  "type": "Blob"
                },
                {
                  "default": "\u0027cpu\u0027",
                  "description": "The storage mode of the Mesh.",
                  "name": "storage",
                  "type": "MeshStorage"
                }
              ],
              "returns": [
                {
                  "description": "The new Mesh.",
                  "name": "mesh",
                  "type": "Mesh"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "A table of attributes describing the format of each vertex.  Each attribute is a table that must have `name` and `type` keys, where the name is a string and the type is a `DataType`. Attributes can also have an `offset` key, which is a byte offset relative to the start of the vertex.  As a shorthand, the name and type can be given as a pair without keys. Additionally, the format can have a `stride` key to set the number of bytes between subsequent vertices.",
                  "name": "format",
                  "type": "table"
                },
                {
                  "description": "The number of vertices in the Mesh.",
                  "name": "count",
                  "type": "number"
                },
                {
                  "default": "\u0027cpu\u0027",
                  "description": "The storage mode of the Mesh.",
                  "name": "storage",
                  "type": "MeshStorage"
                }
              ],
              "returns": [
                {
                  "description": "The new Mesh.",
                  "name": "mesh",
                  "type": "Mesh"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "A table of attributes describing the format of each vertex.  Each attribute is a table that must have `name` and `type` keys, where the name is a string and the type is a `DataType`. Attributes can also have an `offset` key, which is a byte offset relative to the start of the vertex.  As a shorthand, the name and type can be given as a pair without keys. Additionally, the format can have a `stride` key to set the number of bytes between subsequent vertices.",
                  "name": "format",
                  "type": "table"
                },
                {
                  "description": "A table of vertices, formatted according to the vertex format.  The length of the table will be used to set the vertex count of the Mesh.",
                  "name": "vertices",
                  "type": "table"
                },
                {
                  "default": "\u0027cpu\u0027",
                  "description": "The storage mode of the Mesh.",
                  "name": "storage",
                  "type": "MeshStorage"
                }
              ],
              "returns": [
                {
                  "description": "The new Mesh.",
                  "name": "mesh",
                  "type": "Mesh"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "A table of attributes describing the format of each vertex.  Each attribute is a table that must have `name` and `type` keys, where the name is a string and the type is a `DataType`. Attributes can also have an `offset` key, which is a byte offset relative to the start of the vertex.  As a shorthand, the name and type can be given as a pair without keys. Additionally, the format can have a `stride` key to set the number of bytes between subsequent vertices.",
                  "name": "format",
                  "type": "table"
                },
                {
                  "description": "A Blob containing vertex data, formatted according to the vertex format.  The size of the Blob will be used to set the vertex count of the Mesh, and must be a multiple of the vertex size.",
                  "name": "blob",
                  "type": "Blob"
                },
                {
                  "default": "\u0027cpu\u0027",
                  "description": "The storage mode of the Mesh.",
                  "name": "storage",
                  "type": "MeshStorage"
                }
              ],
              "returns": [
                {
                  "description": "The new Mesh.",
                  "name": "mesh",
                  "type": "Mesh"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "A Buffer containing vertex data.  Its length will be used as the vertex count, and its format will be used as the vertex format.",
                  "name": "buffer",
                  "type": "Buffer"
                }
              ],
              "returns": [
                {
                  "description": "The new Mesh.",
                  "name": "mesh",
                  "type": "Mesh"
                }
              ]
            }
          ]
        },
        {
          "description": "Loads a 3D model from a file.  Currently, OBJ, glTF, and binary STL files are supported.",
          "key": "lovr.graphics.newModel",
          "module": "lovr.graphics",
          "name": "newModel",
          "notes": "Currently, the following features are not supported by the model importer:\n\n- glTF: Only the default scene is loaded.\n- glTF: Currently, each skin in a Model can have up to 256 joints.\n- glTF: Meshes can\u0027t appear multiple times in the node hierarchy with different skins, they need\n  to use 1 skin consistently.\n- glTF: `KHR_texture_transform` is supported, but all textures in a material will use the same\n  transform.\n- STL: ASCII STL files are not supported.\n\nDiffuse and emissive textures will be loaded using sRGB encoding, all other textures will be loaded as linear.\n\nLoading a model file will fail if the asset references textures or other files using absolute paths.  Relative paths should be used instead, and will be relative to the model file within the virtual filesystem.",
          "related": ["lovr.data.newModelData", "Pass:draw", "lovr.graphics"],
          "summary": "Create a new Model.",
          "tag": "graphics-objects",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The path to model file.",
                  "name": "filename",
                  "type": "string"
                },
                {
                  "description": "Model options.",
                  "name": "options",
                  "table": [
                    {
                      "default": "true",
                      "description": "Whether the textures created for the Model should have mipmaps generated.",
                      "name": "mipmaps",
                      "type": "boolean"
                    },
                    {
                      "default": "true",
                      "description": "Whether the textures and materials in the Model should be loaded.  When false, the model will use the material set with `Pass:setMaterial`, although it will apply to all nodes.",
                      "name": "materials",
                      "type": "boolean"
                    }
                  ],
                  "type": "table"
                }
              ],
              "returns": [
                {
                  "description": "The new Model.",
                  "name": "model",
                  "type": "Model"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "A Blob containing 3D model data.",
                  "name": "blob",
                  "type": "Blob"
                },
                {
                  "description": "Model options.",
                  "name": "options",
                  "table": [
                    {
                      "default": "true",
                      "description": "Whether the textures created for the Model should have mipmaps generated.",
                      "name": "mipmaps",
                      "type": "boolean"
                    },
                    {
                      "default": "true",
                      "description": "Whether the textures and materials in the Model should be loaded.  When false, the model will use the material set with `Pass:setMaterial`, although it will apply to all nodes.",
                      "name": "materials",
                      "type": "boolean"
                    }
                  ],
                  "type": "table"
                }
              ],
              "returns": [
                {
                  "description": "The new Model.",
                  "name": "model",
                  "type": "Model"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "An existing ModelData object to use for the Model.",
                  "name": "modelData",
                  "type": "ModelData"
                },
                {
                  "description": "Model options.",
                  "name": "options",
                  "table": [
                    {
                      "default": "true",
                      "description": "Whether the textures created for the Model should have mipmaps generated.",
                      "name": "mipmaps",
                      "type": "boolean"
                    },
                    {
                      "default": "true",
                      "description": "Whether the textures and materials in the Model should be loaded.  When false, the model will use the material set with `Pass:setMaterial`, although it will apply to all nodes.",
                      "name": "materials",
                      "type": "boolean"
                    }
                  ],
                  "type": "table"
                }
              ],
              "returns": [
                {
                  "description": "The new Model.",
                  "name": "model",
                  "type": "Model"
                }
              ]
            }
          ]
        },
        {
          "description": "Creates and returns a new Pass object.  The canvas (the set of textures the Pass renders to) can be specified when creating the Pass, or later using `Pass:setCanvas`.",
          "key": "lovr.graphics.newPass",
          "module": "lovr.graphics",
          "name": "newPass",
          "notes": "Fun facts about render passes:\n\n- Textures must have been created with the `render` `TextureUsage`.\n- Textures must have the same dimensions, layer counts, and sample counts.\n- When rendering to textures with multiple layers, each draw will be broadcast to all layers.\n  Render passes have multiple \"views\" (cameras), and each layer uses a corresponding view,\n  allowing each layer to be rendered from a different viewpoint.  This enables fast stereo\n  rendering, but can also be used to efficiently render to cubemaps.  The `ViewIndex` variable\n  can also be used in shaders to set up any desired per-view behavior.\n- Mipmaps will automatically be generated for textures at the end of the render pass.\n- It\u0027s okay to have zero color textures, but in this case there must be a depth texture.\n- It\u0027s possible to render to a specific mipmap level of a Texture, or a subset of its layers, by\n  rendering to texture views, see `lovr.graphics.newTextureView`.",
          "related": [
            "lovr.graphics.submit",
            "lovr.graphics.getWindowPass",
            "lovr.headset.getPass",
            "lovr.graphics"
          ],
          "summary": "Create a new Pass.",
          "tag": "graphics-objects",
          "variants": [
            {
              "arguments": [
                {
                  "description": "One or more textures the pass will render to.  This can be changed later using `Pass:setCanvas`.",
                  "name": "...textures",
                  "type": "Texture"
                }
              ],
              "description": "Create a pass that renders to a set of textures.",
              "returns": [
                {
                  "description": "The new Pass.",
                  "name": "pass",
                  "type": "Pass"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "Render target configuration.  Up to 4 textures can be provided in table keys 1 through 4, as well as the following keys:",
                  "name": "canvas",
                  "table": [
                    {
                      "description": "Depth\/stencil buffer settings.  In addition to a table, it can be a `Texture`, a `TextureFormat`, or `false` to disable the depth buffer.",
                      "name": "depth",
                      "table": [
                        {
                          "default": "\u0027d32f\u0027",
                          "description": "The format of the depth buffer texture, which must be a depth format (the ones that start with `d`).  L\u00d6VR will create or reuse an internal depth buffer with this format.",
                          "name": "format",
                          "type": "TextureFormat"
                        },
                        {
                          "description": "A Texture to use as the depth buffer.  Takes precedence over `format`.",
                          "name": "texture",
                          "type": "Texture"
                        }
                      ],
                      "type": "table"
                    },
                    {
                      "default": "4",
                      "description": "The number of multisamples to use.  Can be 4 for antialiasing, or 1 to disable antialiasing.",
                      "name": "samples",
                      "type": "number"
                    }
                  ],
                  "type": "table"
                }
              ],
              "description": "Create a pass, with extra canvas settings.",
              "returns": [
                {
                  "description": "The new Pass.",
                  "name": "pass",
                  "type": "Pass"
                }
              ]
            },
            {
              "arguments": {},
              "description": "Create an empty Pass without a canvas.",
              "returns": [
                {
                  "description": "The new Pass.",
                  "name": "pass",
                  "type": "Pass"
                }
              ]
            }
          ]
        },
        {
          "description": "Creates a new Sampler.  Samplers are immutable, meaning their parameters can not be changed after the sampler is created.  Instead, a new sampler should be created with the updated properties.",
          "key": "lovr.graphics.newSampler",
          "module": "lovr.graphics",
          "name": "newSampler",
          "related": ["Pass:setSampler", "lovr.graphics"],
          "summary": "Create a new Sampler.",
          "tag": "graphics-objects",
          "variants": [
            {
              "arguments": [
                {
                  "description": "Parameters for the sampler.",
                  "name": "parameters",
                  "table": [
                    {
                      "default": "\u0027linear\u0027",
                      "description": "How the sampler smooths texture pixels.  Can be a table of 3 FilterModes, or a single FilterMode to use for all three.",
                      "name": "filter",
                      "table": [
                        {
                          "description": "The filter mode to use when minifying a texture (drawing it at a smaller size than its native pixel resolution).",
                          "name": "[1]",
                          "type": "FilterMode"
                        },
                        {
                          "description": "The filter mode to use when magnifying a texture (drawing it at a larger size than its native pixel resolution).",
                          "name": "[2]",
                          "type": "FilterMode"
                        },
                        {
                          "description": "The filter mode used to smooth between mipmap levels in a texture.",
                          "name": "[3]",
                          "type": "FilterMode"
                        }
                      ],
                      "type": "table"
                    },
                    {
                      "default": "\u0027repeat\u0027",
                      "description": "How the sampler behaves when wrapping UVs outside the 0-1 range.  Can be a table of 3 WrapModes, or a single WrapMode to use for all three axes.",
                      "name": "wrap",
                      "table": [
                        {
                          "description": "The horizontal wrap mode.",
                          "name": "[1]",
                          "type": "WrapMode"
                        },
                        {
                          "description": "The vertical wrap mode.",
                          "name": "[2]",
                          "type": "WrapMode"
                        },
                        {
                          "description": "The \"z\" wrap mode for 3D textures.",
                          "name": "[3]",
                          "type": "WrapMode"
                        }
                      ],
                      "type": "table"
                    },
                    {
                      "default": "\u0027none\u0027",
                      "description": "The compare mode of the sampler (for shadow samplers).",
                      "name": "compare",
                      "type": "CompareMode"
                    },
                    {
                      "default": "1",
                      "description": "The maximum amount of anisotropic filtering to use.",
                      "name": "anisotropy",
                      "type": "number"
                    },
                    {
                      "description": "A table of 2 mipmap levels the sampler will clamp to.",
                      "name": "mipmaprange",
                      "type": "table"
                    }
                  ],
                  "type": "table"
                }
              ],
              "returns": [
                {
                  "description": "The new sampler.",
                  "name": "sampler",
                  "type": "Sampler"
                }
              ]
            }
          ]
        },
        {
          "description": "Creates a Shader, which is a small program that runs on the GPU.\n\nShader code is usually written in GLSL and compiled to SPIR-V bytecode.  SPIR-V is faster to load but requires a build step.  Either form can be used to create a shader.\n\nBy default, the provided shader code is expected to implement a `vec4 lovrmain() { ... }` function that is called for each vertex or fragment.  If the `raw` option is set to `true`, the code is treated as a raw shader and the `lovrmain` function is not required. In this case, the shader code is expected to implement its own `main` function.",
          "key": "lovr.graphics.newShader",
          "module": "lovr.graphics",
          "name": "newShader",
          "related": [
            "lovr.graphics.compileShader",
            "ShaderType",
            "ShaderStage",
            "lovr.graphics"
          ],
          "summary": "Create a new Shader.",
          "tag": "graphics-objects",
          "variants": [
            {
              "arguments": [
                {
                  "description": "A string, path to a file, or Blob containing GLSL or SPIR-V code for the vertex stage.  Can also be a `DefaultShader` to use that shader\u0027s vertex code.",
                  "name": "vertex",
                  "type": "string"
                },
                {
                  "description": "A string, path to a file, or Blob containing GLSL or SPIR-V code for the fragment stage. Can also be a `DefaultShader` to use that shader\u0027s fragment code.",
                  "name": "fragment",
                  "type": "string"
                },
                {
                  "description": "Shader options.",
                  "name": "options",
                  "table": [
                    {
                      "description": "A table of shader flags.  The keys of the table should be flag names or flag ID numbers. The values can be numbers or booleans, depending on the type of the flag as declared in the shader.",
                      "name": "flags",
                      "type": "table"
                    },
                    {
                      "description": "A label to use for the shader in debugging tools.",
                      "name": "label",
                      "type": "string"
                    },
                    {
                      "description": "If set to true, the code is treated as a raw shader.  It will be compiled with none of the L\u00d6VR helpers.",
                      "name": "raw",
                      "type": "boolean"
                    }
                  ],
                  "type": "table"
                }
              ],
              "description": "Create a graphics shader.  It has a vertex stage that computes vertex positions, and a fragment stage that computes pixel colors.",
              "returns": [
                {
                  "description": "The new shader.",
                  "name": "shader",
                  "type": "Shader"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "A string, path to a file, or Blob containing GLSL or SPIR-V code for the compute stage.",
                  "name": "compute",
                  "type": "string"
                },
                {
                  "description": "Shader options.",
                  "name": "options",
                  "table": [
                    {
                      "description": "A table of shader flags.  The keys of the table should be flag names or flag ID numbers. The values can be numbers or booleans, depending on the type of the flag as declared in the shader.",
                      "name": "flags",
                      "type": "table"
                    },
                    {
                      "description": "A label to use for the shader in debugging tools.",
                      "name": "label",
                      "type": "string"
                    },
                    {
                      "description": "If set to true, the code is treated as a raw shader.  It will be compiled with none of the L\u00d6VR helpers.",
                      "name": "raw",
                      "type": "boolean"
                    }
                  ],
                  "type": "table"
                }
              ],
              "description": "Create a compute shader.",
              "returns": [
                {
                  "description": "The new shader.",
                  "name": "shader",
                  "type": "Shader"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The default shader to use.",
                  "name": "default",
                  "type": "DefaultShader"
                },
                {
                  "description": "Shader options.",
                  "name": "options",
                  "table": [
                    {
                      "description": "A table of shader flags.  The keys of the table should be flag names or flag ID numbers. The values can be numbers or booleans, depending on the type of the flag as declared in the shader.",
                      "name": "flags",
                      "type": "table"
                    },
                    {
                      "description": "A label to use for the shader in debugging tools.",
                      "name": "label",
                      "type": "string"
                    },
                    {
                      "description": "If set to true, the code is treated as a raw shader.  It will be compiled with none of the L\u00d6VR helpers.",
                      "name": "raw",
                      "type": "boolean"
                    }
                  ],
                  "type": "table"
                }
              ],
              "description": "Create a copy of one of the default shaders (used to provide different flags).",
              "returns": [
                {
                  "description": "The new shader.",
                  "name": "shader",
                  "type": "Shader"
                }
              ]
            }
          ]
        },
        {
          "description": "Creates a new Texture.  Image filenames or `Image` objects can be used to provide the initial pixel data and the dimensions, format, and type.  Alternatively, dimensions can be provided, which will create an empty texture.",
          "key": "lovr.graphics.newTexture",
          "module": "lovr.graphics",
          "name": "newTexture",
          "notes": "If no `type` is provided in the options table, L\u00d6VR will guess the `TextureType` of the Texture based on the number of layers:\n\n- If there\u0027s only 1 layer, the type will be `2d`.\n- If there are 6 images provided, the type will be `cube`.\n- Otherwise, the type will be `array`.\n\nNote that an Image can contain multiple layers and mipmaps.  When a single Image is provided, its layer count will be used as the Texture\u0027s layer count.\n\nIf multiple Images are used to initialize the Texture, they must all have a single layer, and their dimensions, format, and mipmap counts must match.\n\nWhen providing cubemap images in a table, they can be in one of the following forms:\n\n    { \u0027px.png\u0027, \u0027nx.png\u0027, \u0027py.png\u0027, \u0027ny.png\u0027, \u0027pz.png\u0027, \u0027nz.png\u0027 }\n    { right \u003d \u0027px.png\u0027, left \u003d \u0027nx.png\u0027, top \u003d \u0027py.png\u0027, bottom \u003d \u0027ny.png\u0027, back \u003d \u0027pz.png\u0027, front \u003d \u0027nz.png\u0027 }\n    { px \u003d \u0027px.png\u0027, nx \u003d \u0027nx.png\u0027, py \u003d \u0027py.png\u0027, ny \u003d \u0027ny.png\u0027, pz \u003d \u0027pz.png\u0027, nz \u003d \u0027nz.png\u0027 }\n\n(Where \u0027p\u0027 stands for positive and \u0027n\u0027 stands for negative).\n\nIf no `usage` is provided in the options table, L\u00d6VR will guess the `TextureUsage` of the Texture.  The `sample` usage is always included, but if the texture was created without any images then the texture will have the `render` usage as well.\n\nThe supported image formats are png, jpg, hdr, dds, ktx1, ktx2, and astc.\n\nIf image data is provided, mipmaps will be generated for any missing mipmap levels.",
          "related": ["lovr.graphics.newTextureView", "lovr.graphics"],
          "summary": "Create a new Texture.",
          "tag": "graphics-objects",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The filename of an image to load.",
                  "name": "filename",
                  "type": "string"
                },
                {
                  "description": "Texture options.",
                  "name": "options",
                  "table": [
                    {
                      "description": "The type of the texture.",
                      "name": "type",
                      "type": "TextureType"
                    },
                    {
                      "default": "\u0027rgba8\u0027",
                      "description": "The format of the texture (ignored when images are provided).",
                      "name": "format",
                      "type": "TextureFormat"
                    },
                    {
                      "default": "false",
                      "description": "Whether the texture is in linear color space instead of sRGB.  Linear textures should be used for non-color data, like normal maps.",
                      "name": "linear",
                      "type": "boolean"
                    },
                    {
                      "default": "1",
                      "description": "The number of samples in the texture, used for multisample antialiasing.  Currently must be 1 or 4.  Ignored when images are provided.",
                      "name": "samples",
                      "type": "number"
                    },
                    {
                      "default": "true",
                      "description": "The number of mipmap levels in the texture, or a boolean.  If true, a full mipmap chain will be created.  If false, the texture will only have a single mipmap.",
                      "name": "mipmaps",
                      "type": "*"
                    },
                    {
                      "description": "A list of `TextureUsage` indicating how the texture will be used.",
                      "name": "usage",
                      "type": "table"
                    },
                    {
                      "description": "A label for the Texture that will show up in debugging tools.",
                      "name": "label",
                      "type": "string"
                    }
                  ],
                  "type": "table"
                }
              ],
              "returns": [
                {
                  "description": "The new Texture.",
                  "name": "texture",
                  "type": "Texture"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The width of the Texture, in pixels.",
                  "name": "width",
                  "type": "number"
                },
                {
                  "description": "The height of the Texture, in pixels.",
                  "name": "height",
                  "type": "number"
                },
                {
                  "description": "Texture options.",
                  "name": "options",
                  "table": [
                    {
                      "description": "The type of the texture.",
                      "name": "type",
                      "type": "TextureType"
                    },
                    {
                      "default": "\u0027rgba8\u0027",
                      "description": "The format of the texture (ignored when images are provided).",
                      "name": "format",
                      "type": "TextureFormat"
                    },
                    {
                      "default": "false",
                      "description": "Whether the texture is in linear color space instead of sRGB.  Linear textures should be used for non-color data, like normal maps.",
                      "name": "linear",
                      "type": "boolean"
                    },
                    {
                      "default": "1",
                      "description": "The number of samples in the texture, used for multisample antialiasing.  Currently must be 1 or 4.  Ignored when images are provided.",
                      "name": "samples",
                      "type": "number"
                    },
                    {
                      "default": "true",
                      "description": "The number of mipmap levels in the texture, or a boolean.  If true, a full mipmap chain will be created.  If false, the texture will only have a single mipmap.",
                      "name": "mipmaps",
                      "type": "*"
                    },
                    {
                      "description": "A list of `TextureUsage` indicating how the texture will be used.",
                      "name": "usage",
                      "type": "table"
                    },
                    {
                      "description": "A label for the Texture that will show up in debugging tools.",
                      "name": "label",
                      "type": "string"
                    }
                  ],
                  "type": "table"
                }
              ],
              "returns": [
                {
                  "description": "The new Texture.",
                  "name": "texture",
                  "type": "Texture"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The width of the Texture, in pixels.",
                  "name": "width",
                  "type": "number"
                },
                {
                  "description": "The height of the Texture, in pixels.",
                  "name": "height",
                  "type": "number"
                },
                {
                  "description": "The number of layers in the Texture.",
                  "name": "layers",
                  "type": "number"
                },
                {
                  "description": "Texture options.",
                  "name": "options",
                  "table": [
                    {
                      "description": "The type of the texture.",
                      "name": "type",
                      "type": "TextureType"
                    },
                    {
                      "default": "\u0027rgba8\u0027",
                      "description": "The format of the texture (ignored when images are provided).",
                      "name": "format",
                      "type": "TextureFormat"
                    },
                    {
                      "default": "false",
                      "description": "Whether the texture is in linear color space instead of sRGB.  Linear textures should be used for non-color data, like normal maps.",
                      "name": "linear",
                      "type": "boolean"
                    },
                    {
                      "default": "1",
                      "description": "The number of samples in the texture, used for multisample antialiasing.  Currently must be 1 or 4.  Ignored when images are provided.",
                      "name": "samples",
                      "type": "number"
                    },
                    {
                      "default": "true",
                      "description": "The number of mipmap levels in the texture, or a boolean.  If true, a full mipmap chain will be created.  If false, the texture will only have a single mipmap.",
                      "name": "mipmaps",
                      "type": "*"
                    },
                    {
                      "description": "A list of `TextureUsage` indicating how the texture will be used.",
                      "name": "usage",
                      "type": "table"
                    },
                    {
                      "description": "A label for the Texture that will show up in debugging tools.",
                      "name": "label",
                      "type": "string"
                    }
                  ],
                  "type": "table"
                }
              ],
              "returns": [
                {
                  "description": "The new Texture.",
                  "name": "texture",
                  "type": "Texture"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "An Image object holding pixel data to load into the Texture.",
                  "name": "image",
                  "type": "string"
                },
                {
                  "description": "Texture options.",
                  "name": "options",
                  "table": [
                    {
                      "description": "The type of the texture.",
                      "name": "type",
                      "type": "TextureType"
                    },
                    {
                      "default": "\u0027rgba8\u0027",
                      "description": "The format of the texture (ignored when images are provided).",
                      "name": "format",
                      "type": "TextureFormat"
                    },
                    {
                      "default": "false",
                      "description": "Whether the texture is in linear color space instead of sRGB.  Linear textures should be used for non-color data, like normal maps.",
                      "name": "linear",
                      "type": "boolean"
                    },
                    {
                      "default": "1",
                      "description": "The number of samples in the texture, used for multisample antialiasing.  Currently must be 1 or 4.  Ignored when images are provided.",
                      "name": "samples",
                      "type": "number"
                    },
                    {
                      "default": "true",
                      "description": "The number of mipmap levels in the texture, or a boolean.  If true, a full mipmap chain will be created.  If false, the texture will only have a single mipmap.",
                      "name": "mipmaps",
                      "type": "*"
                    },
                    {
                      "description": "A list of `TextureUsage` indicating how the texture will be used.",
                      "name": "usage",
                      "type": "table"
                    },
                    {
                      "description": "A label for the Texture that will show up in debugging tools.",
                      "name": "label",
                      "type": "string"
                    }
                  ],
                  "type": "table"
                }
              ],
              "returns": [
                {
                  "description": "The new Texture.",
                  "name": "texture",
                  "type": "Texture"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "A table of filenames or Images to load into the Texture.",
                  "name": "images",
                  "type": "table"
                },
                {
                  "description": "Texture options.",
                  "name": "options",
                  "table": [
                    {
                      "description": "The type of the texture.",
                      "name": "type",
                      "type": "TextureType"
                    },
                    {
                      "default": "\u0027rgba8\u0027",
                      "description": "The format of the texture (ignored when images are provided).",
                      "name": "format",
                      "type": "TextureFormat"
                    },
                    {
                      "default": "false",
                      "description": "Whether the texture is in linear color space instead of sRGB.  Linear textures should be used for non-color data, like normal maps.",
                      "name": "linear",
                      "type": "boolean"
                    },
                    {
                      "default": "1",
                      "description": "The number of samples in the texture, used for multisample antialiasing.  Currently must be 1 or 4.  Ignored when images are provided.",
                      "name": "samples",
                      "type": "number"
                    },
                    {
                      "default": "true",
                      "description": "The number of mipmap levels in the texture, or a boolean.  If true, a full mipmap chain will be created.  If false, the texture will only have a single mipmap.",
                      "name": "mipmaps",
                      "type": "*"
                    },
                    {
                      "description": "A list of `TextureUsage` indicating how the texture will be used.",
                      "name": "usage",
                      "type": "table"
                    },
                    {
                      "description": "A label for the Texture that will show up in debugging tools.",
                      "name": "label",
                      "type": "string"
                    }
                  ],
                  "type": "table"
                }
              ],
              "returns": [
                {
                  "description": "The new Texture.",
                  "name": "texture",
                  "type": "Texture"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "A Blob object holding pixel data to load into the Texture.",
                  "name": "blob",
                  "type": "Blob"
                },
                {
                  "description": "Texture options.",
                  "name": "options",
                  "table": [
                    {
                      "description": "The type of the texture.",
                      "name": "type",
                      "type": "TextureType"
                    },
                    {
                      "default": "\u0027rgba8\u0027",
                      "description": "The format of the texture (ignored when images are provided).",
                      "name": "format",
                      "type": "TextureFormat"
                    },
                    {
                      "default": "false",
                      "description": "Whether the texture is in linear color space instead of sRGB.  Linear textures should be used for non-color data, like normal maps.",
                      "name": "linear",
                      "type": "boolean"
                    },
                    {
                      "default": "1",
                      "description": "The number of samples in the texture, used for multisample antialiasing.  Currently must be 1 or 4.  Ignored when images are provided.",
                      "name": "samples",
                      "type": "number"
                    },
                    {
                      "default": "true",
                      "description": "The number of mipmap levels in the texture, or a boolean.  If true, a full mipmap chain will be created.  If false, the texture will only have a single mipmap.",
                      "name": "mipmaps",
                      "type": "*"
                    },
                    {
                      "description": "A list of `TextureUsage` indicating how the texture will be used.",
                      "name": "usage",
                      "type": "table"
                    },
                    {
                      "description": "A label for the Texture that will show up in debugging tools.",
                      "name": "label",
                      "type": "string"
                    }
                  ],
                  "type": "table"
                }
              ],
              "returns": [
                {
                  "description": "The new Texture.",
                  "name": "texture",
                  "type": "Texture"
                }
              ]
            }
          ]
        },
        {
          "description": "Creates a new Texture view.  A texture view does not store any pixels on its own, but instead uses the pixel data of a \"parent\" Texture object.  The width, height, format, sample count, and usage flags all match the parent.  The view may have a different `TextureType`, and it may reference a subset of the parent texture\u0027s layers and mipmap levels.\n\nTexture views are used for:\n\n- Reinterpretation of texture contents.  For example, a cubemap can be treated as an array\n  texture.\n- Rendering to a particular array layer or mipmap level of a texture.\n- Binding a particular range of layers or mipmap levels to a shader.",
          "key": "lovr.graphics.newTextureView",
          "module": "lovr.graphics",
          "name": "newTextureView",
          "related": ["lovr.graphics.newTexture", "lovr.graphics"],
          "summary": "Create a texture view.",
          "tag": "graphics-objects",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The parent Texture to create a view of.",
                  "name": "parent",
                  "type": "Texture"
                },
                {
                  "description": "Options for the texture view.",
                  "name": "options",
                  "table": [
                    {
                      "description": "The texture type of the view.  Defaults to the type of the parent.",
                      "name": "type",
                      "type": "TextureType"
                    },
                    {
                      "default": "1",
                      "description": "The index of the first layer referenced by the view.",
                      "name": "layer",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "The number of layers in the view.  Defaults to 1 if a layer index is provided, otherwise the view will reference all layers.",
                      "name": "layercount",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The index of the first mipmap referenced by the view.",
                      "name": "mipmap",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "The number of mipmap levels in the view.  Defaults to 1 if a mipmap index is provided, otherwise the view will reference all mipmaps.",
                      "name": "mipmapcount",
                      "type": "number"
                    },
                    {
                      "description": "An optional label for the view that will show up in debugging tools.",
                      "name": "label",
                      "type": "string"
                    }
                  ],
                  "type": "table"
                }
              ],
              "returns": [
                {
                  "description": "The new texture view.",
                  "name": "view",
                  "type": "Texture"
                }
              ]
            }
          ]
        },
        {
          "description": "Presents the window texture to the desktop window.  This function is called automatically by the default implementation of `lovr.run`, so it normally does not need to be called.",
          "key": "lovr.graphics.present",
          "module": "lovr.graphics",
          "name": "present",
          "notes": "This should be called after submitting the window pass (`lovr.graphics.getWindowPass`).  If the window texture has not been rendered to since the last present, this function does nothing.",
          "related": [
            "lovr.graphics.submit",
            "lovr.graphics.getWindowPass",
            "lovr.graphics"
          ],
          "summary": "Update the desktop window contents.",
          "tag": "work-submission",
          "variants": [{ "arguments": {}, "returns": {} }]
        },
        {
          "description": "Changes the global background color.  The textures in a render pass will be cleared to this color at the beginning of the pass if no other clear option is specified.  Additionally, the headset and window will be cleared to this color before rendering.",
          "key": "lovr.graphics.setBackgroundColor",
          "module": "lovr.graphics",
          "name": "setBackgroundColor",
          "notes": "Setting the background color in `lovr.draw` will apply on the following frame, since the default pass is cleared before `lovr.draw` is called.\n\nInternally, this color is applied to the default pass objects when retrieving one of them using `lovr.headset.getPass` or `lovr.graphics.getWindowPass`.  Both are called automatically by the default `lovr.run` implementation.\n\nUsing the background color to clear the display is expected to be more efficient than manually clearing after a render pass begins, especially on mobile GPUs.",
          "related": [
            "lovr.graphics.newPass",
            "Pass:setClear",
            "Texture:clear",
            "Pass:fill",
            "lovr.graphics.getBackgroundColor",
            "lovr.graphics"
          ],
          "summary": "Set the background color.",
          "tag": "graphics-global",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The red component of the background color.",
                  "name": "r",
                  "type": "number"
                },
                {
                  "description": "The green component of the background color.",
                  "name": "g",
                  "type": "number"
                },
                {
                  "description": "The blue component of the background color.",
                  "name": "b",
                  "type": "number"
                },
                {
                  "default": "1.0",
                  "description": "The alpha component of the background color.",
                  "name": "a",
                  "type": "number"
                }
              ],
              "returns": {}
            },
            {
              "arguments": [
                {
                  "description": "A hexcode (like `0xffffff`) to use for the background color (does not support alpha).",
                  "name": "hex",
                  "type": "number"
                },
                {
                  "default": "1.0",
                  "description": "The alpha component of the background color.",
                  "name": "a",
                  "type": "number"
                }
              ],
              "returns": {}
            },
            {
              "arguments": [
                {
                  "description": "A table containing 3 or 4 color components.",
                  "name": "table",
                  "type": "table"
                }
              ],
              "returns": {}
            }
          ]
        },
        {
          "description": "Enables or disables timing stats.  When enabled, `Pass:getStats` will return `submitTime` and `gpuTime` durations.  Timing is enabled by default when `t.graphics.debug` is set in `lovr.conf`.  Timing has a small amount of overhead, so it should only be enabled when needed.",
          "key": "lovr.graphics.setTimingEnabled",
          "module": "lovr.graphics",
          "name": "setTimingEnabled",
          "related": [
            "Pass:getStats",
            "lovr.graphics.isTimingEnabled",
            "lovr.graphics"
          ],
          "summary": "Enable or disable timing stats.",
          "tag": "graphics-global",
          "variants": [
            {
              "arguments": [
                {
                  "description": "Whether timing should be enabled.",
                  "name": "enable",
                  "type": "boolean"
                }
              ],
              "returns": {}
            }
          ]
        },
        {
          "description": "Submits work to the GPU.",
          "key": "lovr.graphics.submit",
          "module": "lovr.graphics",
          "name": "submit",
          "notes": "The submitted `Pass` objects will run in the order specified.  Commands within a single Pass do not have any ordering guarantees.\n\nSubmitting work to the GPU is not thread safe.  No other `lovr.graphics` or `Pass` functions may run at the same time as `lovr.graphics.submit`.\n\nCalling this function will invalidate any temporary buffers or passes that were created during the frame.\n\nSubmitting work to the GPU is a relatively expensive operation.  It\u0027s a good idea to batch all `Pass` objects into 1 submission if possible, unless there\u0027s a good reason not to.  One such reason would be that the frame has so much work that some of it needs to be submitted early to prevent the GPU from running out of things to do.  Another would be for `Readback` objects.\n\nBy default, this function is called with the default pass at the end of `lovr.draw` and `lovr.mirror`.\n\nIt is valid to submit zero passes.  This will send an empty batch of work to the GPU.",
          "related": ["lovr.graphics.wait", "lovr.graphics"],
          "summary": "Submit recorded graphics work to the GPU.",
          "tag": "work-submission",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The pass objects to submit.  Falsy values will be skipped.",
                  "name": "...",
                  "type": "Pass"
                }
              ],
              "returns": [
                {
                  "description": "Always returns true, for convenience when returning from `lovr.draw`.",
                  "name": "true",
                  "type": "boolean"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "A table of passes to submit.  Falsy values will be skipped.",
                  "name": "t",
                  "type": "table"
                }
              ],
              "returns": [
                {
                  "description": "Always returns true, for convenience when returning from `lovr.draw`.",
                  "name": "true",
                  "type": "boolean"
                }
              ]
            }
          ]
        },
        {
          "description": "Waits for all submitted GPU work to finish.  A normal application that is trying to render graphics at a high framerate should never use this function, since waiting like this prevents the CPU from doing other useful work.  Otherwise, reasons to use this function might be for debugging or to force a `Readback` to finish immediately.",
          "key": "lovr.graphics.wait",
          "module": "lovr.graphics",
          "name": "wait",
          "related": ["lovr.graphics.submit", "lovr.graphics"],
          "summary": "Stall the CPU until all submitted GPU work is finished.",
          "tag": "work-submission",
          "variants": [{ "arguments": {}, "returns": {} }]
        }
      ],
      "key": "lovr.graphics",
      "name": "graphics",
      "objects": [
        {
          "constructors": ["lovr.graphics.newBuffer"],
          "description": "A Buffer is a block of memory on the GPU.  It\u0027s like a GPU version of a `Blob`.  Lua code can write data to the buffer which uploads to VRAM, and shaders read buffer data during rendering. Compute shaders can also write to buffers.\n\nThe **size** of a Buffer is the number of bytes of VRAM it occupies.  It\u0027s set when the Buffer is created and can\u0027t be changed afterwards.\n\nBuffers can optionally have a **format**, which defines the type of data stored in the buffer. The format determines how Lua values are converted into binary.  Like the size, it can\u0027t change after the buffer is created.  `Shader:getBufferFormat` returns the format of a variable in a `Shader`.\n\nWhen a Buffer has a format, it also has a **length**, which is the number of items it holds, and a **stride**, which is the number of bytes between each item.\n\n`Buffer:setData` is used to upload data to the Buffer.  `Buffer:clear` can also be used to efficiently zero out a Buffer.\n\n`Buffer:getData` can be used to download data from the Buffer, but be aware that it stalls the GPU until the download is complete, which is very slow!  `Buffer:newReadback` will instead download the data in the background, which avoids costly stalls.\n\nBuffers are often used for mesh data.  Vertices stored in buffers can be drawn using `Pass:mesh`.  `Mesh` objects can also be used, which wrap Buffers along with some extra metadata.\n\nBuffers can be \"bound\" to a variable in a Shader using `Pass:send`.  That means that the next time the shader runs, the data from the Buffer will be used for the stuff in the variable.\n\nIt\u0027s important to understand that data from a Buffer will only be used at the point when graphics commands are actually submitted.  This example records 2 draws, changing the buffer data between each one:\n\n    buffer:setData(data1)\n    pass:mesh(buffer)\n    buffer:setData(data2)\n    pass:mesh(buffer)\n    lovr.graphics.submit(pass)\n\n**Both** draws will use `data2` here!  That\u0027s because `lovr.graphics.submit` is where the draws actually get processed, so they both see the \"final\" state of the buffer.  The data in a Buffer can\u0027t be 2 things at once!  If you need multiple versions of data, it\u0027s best to use a bigger buffer with offsets (or multiple buffers).",
          "key": "Buffer",
          "methods": [
            {
              "description": "Clears a range of data in the Buffer to a value.",
              "key": "Buffer:clear",
              "module": "lovr.graphics",
              "name": "clear",
              "related": ["Texture:clear", "Buffer"],
              "summary": "Clear data in the Buffer.",
              "tag": "buffer-transfer",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "0",
                      "description": "The offset of the range of the Buffer to clear, in bytes.  Must be a multiple of 4.",
                      "name": "offset",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "The number of bytes to clear.  If `nil`, clears to the end of the Buffer.  Must be a multiple of 4.",
                      "name": "extent",
                      "type": "number"
                    },
                    {
                      "default": "0x00000000",
                      "description": "The value to clear to.  This will be interpreted as a 32 bit number, which will be repeated across the clear range.",
                      "name": "value",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Downloads the Buffer\u0027s data from VRAM and returns it as a table.  This function is very very slow because it stalls the CPU until the data is finished downloading, so it should only be used for debugging or non-interactive scripts.  `Buffer:newReadback` is an alternative that returns a `Readback` object, which will not block the CPU.",
              "key": "Buffer:getData",
              "module": "lovr.graphics",
              "name": "getData",
              "notes": "The length of the table will equal the number of items read.  Here are some examples of how the table is formatted:\n\n    buffer \u003d lovr.graphics.newBuffer(\u0027int\u0027, { 7 })\n    buffer:getData() --\u003e returns { 7 }\n\n    buffer \u003d lovr.graphics.newBuffer(\u0027vec3\u0027, { 7, 8, 9 })\n    buffer:getData() --\u003e returns {{ 7, 8, 9 }}\n\n    buffer \u003d lovr.graphics.newBuffer(\u0027int\u0027, { 1, 2, 3 })\n    buffer:getData() --\u003e returns { 1, 2, 3 }\n\n    buffer \u003d lovr.graphics.newBuffer({ \u0027vec2\u0027, \u0027vec2\u0027 }, {\n      vec2(1,2), vec2(3,4),\n      vec2(5,6), vec2(7,8)\n    })\n    buffer:getData() --\u003e returns { { 1, 2, 3, 4 }, { 5, 6, 7, 8 } }\n\n    buffer \u003d lovr.graphics.newBuffer({\n      { \u0027a\u0027, \u0027float\u0027 },\n      { \u0027b\u0027, \u0027float\u0027 }\n    }, { a \u003d 1, b \u003d 2 })\n    buffer:getData() --\u003e returns { { 1, 2 } }\n\n    buffer \u003d lovr.graphics.newBuffer({\n      { \u0027x\u0027, \u0027int\u0027, 3 }\n    }, { x \u003d { 1, 2, 3 } })\n    buffer:getData() --\u003e returns { { x \u003d { 1, 2, 3 } } }\n\n    buffer \u003d lovr.graphics.newBuffer({\n      { \u0027lights\u0027, {\n        { \u0027pos\u0027, \u0027vec3\u0027 },\n        { \u0027size\u0027, \u0027float\u0027 },\n      }, 10}\n    }, data)\n    buffer:getData() --\u003e returns { { lights \u003d { { pos \u003d ..., size \u003d ... }, ... } } }\n\nIn summary, each individual item is wrapped in a table, except if the format is a single number. If the format has nested types or arrays then the tables will be key-value, otherwise they will use numeric keys.",
              "related": [
                "Buffer:newReadback",
                "Buffer:mapData",
                "Readback:getData",
                "Buffer:setData",
                "Buffer"
              ],
              "summary": "Get the data in the Buffer.",
              "tag": "buffer-transfer",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "1",
                      "description": "The index of the first item to read.",
                      "name": "index",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "The number of items to read.  If nil, reads the remainder of the buffer.",
                      "name": "count",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The table with the Buffer\u0027s data.",
                      "name": "t",
                      "type": "table"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the format the Buffer was created with.",
              "examples": [
                {
                  "code": "function lovr.load()\n  buffer \u003d lovr.graphics.newBuffer({\n    { \u0027a\u0027, \u0027float\u0027 },\n    { \u0027b\u0027, \u0027un16x2\u0027 }\n  })\n\n  for i, field in ipairs(buffer:getFormat()) do\n    print((\u0027%s: %s\u0027):format(field.name, field.type))\n  end\n\n  -- prints the following:\n  -- a: f32\n  -- b: un16x2\nend"
                }
              ],
              "key": "Buffer:getFormat",
              "module": "lovr.graphics",
              "name": "getFormat",
              "related": [
                "Buffer:getSize",
                "Buffer:getLength",
                "Buffer:getStride",
                "Buffer"
              ],
              "summary": "Get the format of the Buffer.",
              "tag": "buffer-metadata",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "A list of fields comprising the format.",
                      "name": "format",
                      "table": [
                        {
                          "description": "The name of the field (if fields were created with names).",
                          "name": "[].name",
                          "type": "string"
                        },
                        {
                          "description": "The `DataType` of the field, or a recursive table with the sub-format.",
                          "name": "[].type",
                          "type": "*"
                        },
                        {
                          "description": "The offset of the field relative to its parent, in bytes.",
                          "name": "[].offset",
                          "type": "number"
                        },
                        {
                          "description": "The array length of the field, or `nil` if it\u0027s not an array.",
                          "name": "[].length",
                          "type": "number"
                        },
                        {
                          "description": "The stride of the field in bytes, or `nil` if it\u0027s not an array.",
                          "name": "[].stride",
                          "type": "number"
                        }
                      ],
                      "type": "table"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the length of the Buffer, or `nil` if the Buffer was not created with a format.",
              "key": "Buffer:getLength",
              "module": "lovr.graphics",
              "name": "getLength",
              "related": ["Buffer:getSize", "Buffer:getStride", "Buffer"],
              "summary": "Get the length of the Buffer.",
              "tag": "buffer-metadata",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The length of the Buffer.",
                      "name": "length",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the size of the Buffer in VRAM, in bytes.  This is the same as `length * stride`.\n\nThe size of the Buffer can\u0027t change after it\u0027s created.",
              "key": "Buffer:getSize",
              "module": "lovr.graphics",
              "name": "getSize",
              "related": ["Buffer:getLength", "Buffer:getStride", "Buffer"],
              "summary": "Get the size of the Buffer, in bytes.",
              "tag": "buffer-metadata",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The size of the Buffer, in bytes.",
                      "name": "size",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the distance between each item in the Buffer, in bytes, or `nil` if the Buffer was not created with a format.",
              "key": "Buffer:getStride",
              "module": "lovr.graphics",
              "name": "getStride",
              "notes": "When a Buffer is created, the stride can be set explicitly, otherwise it will be automatically computed based on the fields in the Buffer.\n\nStrides can not be zero, and can not be smaller than the size of a single item.",
              "related": ["Buffer:getSize", "Buffer:getLength", "Buffer"],
              "summary": "Get the stride of the Buffer, in bytes.",
              "tag": "buffer-metadata",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The stride of the Buffer, in bytes.",
                      "name": "stride",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns a pointer to GPU memory and schedules a copy from this pointer to the buffer\u0027s data. The data in the pointer will replace the data in the buffer.  This is intended for use with the LuaJIT FFI or for passing to C libraries.",
              "key": "Buffer:mapData",
              "module": "lovr.graphics",
              "name": "mapData",
              "notes": "The pointer remains valid until the next call to `lovr.graphics.submit`, during which the data in the pointer will be uploaded to the buffer.\n\nThe initial contents of the pointer are undefined.\n\nSpecial care should be taken when writing data:\n\n- Reading data from the pointer will be very slow on some systems, and should be avoided.\n- It is better to write data to the pointer sequentially.  Random access may be slower.",
              "related": ["Blob:getPointer", "Buffer"],
              "summary": "Get a writable pointer to the Buffer\u0027s memory.",
              "tag": "buffer-transfer",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "0",
                      "description": "A byte offset in the buffer to write to.",
                      "name": "offset",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "The number of bytes to replace.  If nil, writes to the rest of the buffer.",
                      "name": "extent",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "A pointer to the Buffer\u0027s memory.",
                      "name": "pointer",
                      "type": "lightuserdata"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Creates and returns a new `Readback` that will download the data in the Buffer from VRAM. Once the readback is complete, `Readback:getData` returns the data as a table, or `Readback:getBlob` returns the data as a `Blob`.",
              "key": "Buffer:newReadback",
              "module": "lovr.graphics",
              "name": "newReadback",
              "notes": "The offset and extent arguments must be a multiple of the Buffer\u0027s stride (unless it was created without a format).",
              "related": ["Buffer:getData", "Texture:newReadback", "Buffer"],
              "summary": "Read back the contents of the Buffer asynchronously.",
              "tag": "buffer-transfer",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "0",
                      "description": "A byte offset to read from.",
                      "name": "offset",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "The number of bytes to read.  If nil, reads the rest of the buffer.",
                      "name": "extent",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "A new Readback object.",
                      "name": "readback",
                      "type": "Readback"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Copies data to the Buffer from either a table, `Blob`, or `Buffer`.",
              "examples": [
                {
                  "code": "function lovr.load()\n  buffer \u003d lovr.graphics.newBuffer(\u0027int\u0027, 3)\n  buffer:setData({ 1, 2, 3 })\n\n  buffer \u003d lovr.graphics.newBuffer(\u0027vec3\u0027, 2)\n  buffer:setData({ 1,2,3, 4,5,6 })\n  buffer:setData({ { 1, 2, 3 }, { 4, 5, 6 } })\n  buffer:setData({ vec3(1, 2, 3), vec3(4, 5, 6) })\n\n  -- When the Buffer\u0027s length is 1, wrapping in table is optional:\n  buffer \u003d lovr.graphics.newBuffer(\u0027vec3\u0027)\n  buffer:setData(1, 2, 3)\n  buffer:setData(vec3(1, 2, 3))\n\n  -- Same for key-value structs\n  buffer \u003d lovr.graphics.newBuffer({\n    { \u0027x\u0027, \u0027float\u0027 },\n    { \u0027y\u0027, \u0027float\u0027 }\n  })\n  buffer:setData({ x \u003d 1, y \u003d 2 })\n\n  -- Key\/value formats\n  buffer \u003d lovr.graphics.newBuffer({\n    { \u0027x\u0027, \u0027float\u0027 },\n    { \u0027y\u0027, \u0027float\u0027 }\n  }, 3)\n  buffer:setData({\n    { x \u003d 1, y \u003d 2 },\n    { x \u003d 3, y \u003d 4 },\n    { x \u003d 5, y \u003d 6 }\n  })\n  buffer:setData({ 1, 2, 3, 4, 5, 6 })\n  buffer:setData({ { 1, 2 }, { 3, 4 }, { 5, 6 } })\n\n  -- Nested formats\n  buffer \u003d lovr.graphics.newBuffer({\n    { \u0027a\u0027, {\n      {\u0027b\u0027, {\n        \u0027c\u0027, \u0027float\u0027\n      }}\n    }}\n  })\n  buffer:setData({ a \u003d { b \u003d { c \u003d 42 } } })\n\n  -- Inner arrays\n  buffer \u003d lovr.graphics.newBuffer({\n    { \u0027positions\u0027, \u0027vec3\u0027, 10 },\n    { \u0027sizes\u0027, \u0027float\u0027, 10 },\n    layout \u003d \u0027std140\u0027\n  })\n  local data \u003d { positions \u003d {}, sizes \u003d {} }\n  for i \u003d 1, buffer:getLength() do\n    data.positions[i] \u003d vec3(i, i, i)\n    data.sizes[i] \u003d i\n  end\n  buffer:setData(data)\nend",
                  "description": "Various examples of copying different formats."
                }
              ],
              "key": "Buffer:setData",
              "module": "lovr.graphics",
              "name": "setData",
              "notes": "One gotcha is that unspecified fields will be set to zero.  Here\u0027s an example:\n\n    buffer \u003d lovr.graphics.newBuffer({{ \u0027x\u0027, \u0027int\u0027 }, { \u0027y\u0027, \u0027int\u0027 }})\n    buffer:setData({ x \u003d 1, y \u003d 1 }) -- set the data\n    buffer:setData({ x \u003d 1 }) -- set the data, partially\n    -- buffer data is now {x\u003d1, y\u003d0}!\n\nThis doesn\u0027t apply to separate items in the buffer.  For example, if the Buffer\u0027s length is 2 and only the 1st item is set, the second item will remain undisturbed:\n\n    buffer \u003d lovr.graphics.newBuffer({{ \u0027x\u0027, \u0027int\u0027 }, { \u0027y\u0027, \u0027int\u0027 }}, 2)\n    buffer:setData({{ x \u003d 1, y \u003d 1 }, { x \u003d 2, y \u003d 2 }}) -- set the data\n    buffer:setData({{ x \u003d 1 }}) -- set one item, partially\n    -- buffer data is now {{x\u003d1, y\u003d0}, {x\u003d2, y\u003d2}}",
              "related": ["Buffer:getData", "Buffer"],
              "summary": "Change the data in the Buffer.",
              "tag": "buffer-transfer",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "A flat or nested table of items to copy to the Buffer (see notes for format).",
                      "name": "table",
                      "type": "table"
                    },
                    {
                      "default": "1",
                      "description": "The index of the first value in the Buffer to update.",
                      "name": "destinationIndex",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The index in the table to copy from.",
                      "name": "sourceIndex",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "The number of items to copy.  `nil` will copy as many items as possible, based on the lengths of the source and destination.",
                      "name": "count",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "Numerical components to copy to the buffer.",
                      "name": "...numbers",
                      "type": "number"
                    }
                  ],
                  "description": "Copies a single field to a buffer with numbers (buffer length must be 0).",
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "Vector objects to copy to the buffer.",
                      "name": "vector",
                      "type": "*"
                    }
                  ],
                  "description": "Copies a single vector to a buffer (buffer length must be 0).",
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The Blob to copy data from.",
                      "name": "blob",
                      "type": "Blob"
                    },
                    {
                      "default": "0",
                      "description": "The byte offset to copy to.",
                      "name": "destinationOffset",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The byte offset to copy from.",
                      "name": "sourceOffset",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "The number of bytes to copy.  If nil, copies as many bytes as possible.",
                      "name": "size",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The Buffer to copy data from.",
                      "name": "buffer",
                      "type": "Buffer"
                    },
                    {
                      "default": "0",
                      "description": "The byte offset to copy to.",
                      "name": "destinationOffset",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The byte offset to copy from.",
                      "name": "sourceOffset",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "The number of bytes to copy.  If nil, copies as many bytes as possible.",
                      "name": "size",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            }
          ],
          "module": "lovr.graphics",
          "name": "Buffer",
          "related": ["lovr.graphics"],
          "sections": [
            { "name": "Metadata", "tag": "buffer-metadata" },
            { "name": "Transfers", "tag": "buffer-transfer" }
          ],
          "summary": "A block of memory on the GPU."
        },
        {
          "constructors": [
            "lovr.graphics.newFont",
            "lovr.graphics.getDefaultFont"
          ],
          "description": "Font objects are used to render text with `Pass:text`.  The active font can be changed using `Pass:setFont`.  The default font is Varela Round, which is used when no font is active, and can be retrieved using `lovr.graphics.getDefaultFont`.  Custom fonts can be loaded from TTF and BMFont files using `lovr.graphics.newFont`.\n\nEach Font uses a `Rasterizer` to load the font and create images for each glyph. As text is drawn, the Font uploads images from the Rasterizer to a GPU texture atlas as needed.  The Font also performs text layout and mesh generation for strings of text.\n\nFor TTF fonts, L\u00d6VR uses a text rendering technique called \"multichannel signed distance fields\" (MSDF), which makes the font rendering remain crisp when text is viewed up close.",
          "key": "Font",
          "methods": [
            {
              "description": "Returns the ascent of the font.  The ascent is the maximum amount glyphs ascend above the baseline.  The units depend on the font\u0027s pixel density.  With the default density, the units correspond to meters.",
              "key": "Font:getAscent",
              "module": "lovr.graphics",
              "name": "getAscent",
              "related": [
                "Rasterizer:getAscent",
                "Font:getDescent",
                "Font:getHeight",
                "Font:getKerning",
                "Font:getWidth",
                "Font"
              ],
              "summary": "Get the ascent of the Font.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The ascent of the font.",
                      "name": "ascent",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the descent of the font.  The descent is the maximum amount glyphs descend below the baseline.  The units depend on the font\u0027s pixel density.  With the default density, the units correspond to meters.",
              "key": "Font:getDescent",
              "module": "lovr.graphics",
              "name": "getDescent",
              "related": [
                "Rasterizer:getDescent",
                "Font:getAscent",
                "Font:getHeight",
                "Font:getKerning",
                "Font:getWidth",
                "Font"
              ],
              "summary": "Get the descent of the Font.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The descent of the font.",
                      "name": "descent",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the height of the font, sometimes also called the leading.  This is the full height of a line of text, including the space between lines.  Each line of a multiline string is separated on the y axis by this height, multiplied by the font\u0027s line spacing.  The units depend on the font\u0027s pixel density.  With the default density, the units correspond to meters.",
              "key": "Font:getHeight",
              "module": "lovr.graphics",
              "name": "getHeight",
              "related": [
                "Rasterizer:getLeading",
                "Font:getLineSpacing",
                "Font:setLineSpacing",
                "Font:getAscent",
                "Font:getDescent",
                "Font:getKerning",
                "Font:getWidth",
                "Font:getLines",
                "Font"
              ],
              "summary": "Get the height of the Font.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The height of the font.",
                      "name": "height",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the kerning between 2 glyphs.  Kerning is a slight horizontal adjustment between 2 glyphs to improve the visual appearance.  It will often be negative.  The units depend on the font\u0027s pixel density.  With the default density, the units correspond to meters.",
              "key": "Font:getKerning",
              "module": "lovr.graphics",
              "name": "getKerning",
              "related": [
                "Rasterizer:getKerning",
                "Font:getAscent",
                "Font:getDescent",
                "Font:getHeight",
                "Font:getWidth",
                "Font"
              ],
              "summary": "Get the kerning between 2 glyphs.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The first character.",
                      "name": "first",
                      "type": "string"
                    },
                    {
                      "description": "The second character.",
                      "name": "second",
                      "type": "string"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The kerning between the two glyphs.",
                      "name": "keming",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The first codepoint.",
                      "name": "firstCodepoint",
                      "type": "number"
                    },
                    {
                      "description": "The second character.",
                      "name": "second",
                      "type": "string"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The kerning between the two glyphs.",
                      "name": "keming",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The first character.",
                      "name": "first",
                      "type": "string"
                    },
                    {
                      "description": "The second codepoint.",
                      "name": "secondCodepoint",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The kerning between the two glyphs.",
                      "name": "keming",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The first codepoint.",
                      "name": "firstCodepoint",
                      "type": "number"
                    },
                    {
                      "description": "The second codepoint.",
                      "name": "secondCodepoint",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The kerning between the two glyphs.",
                      "name": "keming",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the line spacing of the Font.  When spacing out lines, the height of the font is multiplied the line spacing to get the final spacing value.  The default is 1.0.",
              "key": "Font:getLineSpacing",
              "module": "lovr.graphics",
              "name": "getLineSpacing",
              "related": ["Font:getHeight", "Font:setLineSpacing", "Font"],
              "summary": "Get the line spacing of the Font.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The line spacing of the font.",
                      "name": "spacing",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns a table of wrapped lines for a piece of text, given a line length limit.  Newlines are handled correctly.  The wrap limit units depend on the pixel density of the font.  With the default pixel density, the units correspond to meters when the font is drawn at 1.0 scale.",
              "key": "Font:getLines",
              "module": "lovr.graphics",
              "name": "getLines",
              "related": [
                "Font:getWidth",
                "Font:getHeight",
                "Pass:text",
                "Font"
              ],
              "summary": "Wrap a string into a sequence of lines.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The text to wrap.",
                      "name": "string",
                      "type": "string"
                    },
                    {
                      "description": "The line length to wrap at.",
                      "name": "wrap",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "A table strings, one for each wrapped line (without any color information).",
                      "name": "lines",
                      "type": "table"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A table of colored strings, each given as a `{ color, string }` pair.  The color can be a `Vec3`, `Vec4`, table, or hexcode.",
                      "name": "strings",
                      "type": "table"
                    },
                    {
                      "description": "The line length to wrap at.",
                      "name": "wrap",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "A table strings, one for each wrapped line (without any color information).",
                      "name": "lines",
                      "type": "table"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the pixel density of the font.  The density is a \"pixels per world unit\" factor that controls how the pixels in the font\u0027s texture are mapped to units in the coordinate space.\n\nThe default pixel density is set to the height of the font.  This means that lines of text rendered with a scale of 1.0 come out to 1 unit (meter) tall.  However, if this font was drawn to a 2D texture where the units are in pixels, the font would still be drawn 1 unit (pixel) tall!  Scaling the coordinate space or the size of the text by the height of the font would fix this.  However, a more convenient option is to set the pixel density of the font to 1.0 when doing 2D rendering to make the font\u0027s size match up with the pixels of the canvas.",
              "key": "Font:getPixelDensity",
              "module": "lovr.graphics",
              "name": "getPixelDensity",
              "related": ["Font:setPixelDensity", "Font"],
              "summary": "Get the pixel density of the Font.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The pixel density of the font.",
                      "name": "density",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the Rasterizer object backing the Font.",
              "key": "Font:getRasterizer",
              "module": "lovr.graphics",
              "name": "getRasterizer",
              "related": [
                "lovr.graphics.newFont",
                "lovr.data.newRasterizer",
                "Font"
              ],
              "summary": "Get the Font\u0027s Rasterizer.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The Rasterizer.",
                      "name": "rasterizer",
                      "type": "Rasterizer"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns a table of vertices for a piece of text, along with a Material to use when rendering it. The Material returned by this function may not be the same if the Font\u0027s texture atlas needs to be recreated with a bigger size to make room for more glyphs.",
              "key": "Font:getVertices",
              "module": "lovr.graphics",
              "name": "getVertices",
              "notes": "Each vertex is a table of 4 floating point numbers with the following data:\n\n    { x, y, u, v }\n\nThese could be placed in a vertex buffer using the following buffer format:\n\n    { \u0027vec2:VertexPosition\u0027, \u0027vec2:VertexUV\u0027 }",
              "related": ["Font"],
              "summary": "Get the vertices for a piece of text.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The text to render.",
                      "name": "string",
                      "type": "string"
                    },
                    {
                      "default": "0",
                      "description": "The maximum line length.  The units depend on the pixel density of the font, but are in meters by default.",
                      "name": "wrap",
                      "type": "number"
                    },
                    {
                      "description": "The horizontal align.",
                      "name": "halign",
                      "type": "HorizontalAlign"
                    },
                    {
                      "description": "The vertical align.",
                      "name": "valign",
                      "type": "VerticalAlign"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The table of vertices.  See below for the format of each vertex.",
                      "name": "vertices",
                      "type": "table"
                    },
                    {
                      "description": "A Material to use when rendering the vertices.",
                      "name": "material",
                      "type": "Material"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A table of colored strings, each given as a `{ color, string }` pair.  The color can be a `Vec3`, `Vec4`, table, or hexcode.",
                      "name": "strings",
                      "type": "table"
                    },
                    {
                      "default": "0",
                      "description": "The maximum line length.  The units depend on the pixel density of the font, but are in meters by default.",
                      "name": "wrap",
                      "type": "number"
                    },
                    {
                      "description": "The horizontal align.",
                      "name": "halign",
                      "type": "HorizontalAlign"
                    },
                    {
                      "description": "The vertical align.",
                      "name": "valign",
                      "type": "VerticalAlign"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The table of vertices.  See below for the format of each vertex.",
                      "name": "vertices",
                      "type": "table"
                    },
                    {
                      "description": "A Material to use when rendering the vertices.",
                      "name": "material",
                      "type": "Material"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the maximum width of a piece of text.  This function does not perform wrapping but does respect newlines in the text.",
              "key": "Font:getWidth",
              "module": "lovr.graphics",
              "name": "getWidth",
              "related": [
                "Font:getAscent",
                "Font:getDescent",
                "Font:getHeight",
                "Font:getKerning",
                "Font:getLines",
                "Font"
              ],
              "summary": "Get the width of rendered text.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The text to measure.",
                      "name": "string",
                      "type": "string"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The maximum width of the text.",
                      "name": "width",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A table of colored strings, each given as a `{ color, string }` pair.  The color can be a `Vec3`, `Vec4`, table, or hexcode.",
                      "name": "strings",
                      "type": "table"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The maximum width of the text.",
                      "name": "width",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Sets the line spacing of the Font.  When spacing out lines, the height of the font is multiplied by the line spacing to get the final spacing value.  The default is 1.0.",
              "key": "Font:setLineSpacing",
              "module": "lovr.graphics",
              "name": "setLineSpacing",
              "related": ["Font:getHeight", "Font:getLineSpacing", "Font"],
              "summary": "Set the line spacing of the Font.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The new line spacing.",
                      "name": "spacing",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the pixel density of the font.  The density is a \"pixels per world unit\" factor that controls how the pixels in the font\u0027s texture are mapped to units in the coordinate space.\n\nThe default pixel density is set to the height of the font.  This means that lines of text rendered with a scale of 1.0 come out to 1 unit (meter) tall.  However, if this font was drawn to a 2D texture where the units are in pixels, the font would still be drawn 1 unit (pixel) tall!  Scaling the coordinate space or the size of the text by the height of the font would fix this.  However, a more convenient option is to set the pixel density of the font to 1.0 when doing 2D rendering to make the font\u0027s size match up with the pixels of the canvas.",
              "key": "Font:setPixelDensity",
              "module": "lovr.graphics",
              "name": "setPixelDensity",
              "related": ["Font:getPixelDensity", "Font"],
              "summary": "Set the pixel density of the Font.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The new pixel density of the font.",
                      "name": "density",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": {},
                  "description": "Resets the pixel density to the default, which is given by `Font:getHeight`.",
                  "returns": {}
                }
              ]
            }
          ],
          "module": "lovr.graphics",
          "name": "Font",
          "notes": "MSDF text requires a special shader to work.  L\u00d6VR will automatically switch to this shader if no shader is active on the `Pass`.  This font shader is also available as a `DefaultShader`.",
          "related": ["lovr.graphics"],
          "summary": "A Font used to render text."
        },
        {
          "constructors": ["lovr.graphics.newMaterial"],
          "description": "Materials are a set of properties and textures that define the properties of a surface, like what color it is, how bumpy or shiny it is, etc. `Shader` code can use the data from a material to compute lighting.\n\nMaterials are immutable, and can\u0027t be changed after they are created.  Instead, a new Material should be created with the updated properties.\n\n`Pass:setMaterial` changes the active material, causing it to affect rendering until the active material is changed again.\n\nUsing material objects is optional.  `Pass:setMaterial` can take a `Texture`, and `Pass:setColor` can change the color of objects, so basic tinting and texturing of surfaces does not require a full material to be created.  Also, a custom material system could be developed by sending textures and other data to shaders manually.\n\n`Model` objects will create materials for all of the materials defined in the model file.\n\nIn shader code, non-texture material properties can be accessed as `Material.\u003cproperty\u003e`, and material textures can be accessed as `\u003cType\u003eTexture`, e.g. `RoughnessTexture`.",
          "key": "Material",
          "methods": [
            {
              "description": "Returns the properties of the Material in a table.",
              "key": "Material:getProperties",
              "module": "lovr.graphics",
              "name": "getProperties",
              "related": ["Material"],
              "summary": "Get the properties of the Material.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The Material properties.",
                      "name": "properties",
                      "type": "table"
                    }
                  ]
                }
              ]
            }
          ],
          "module": "lovr.graphics",
          "name": "Material",
          "related": ["lovr.graphics"],
          "summary": "A set of properties and textures that define the properties of a surface."
        },
        {
          "constructors": ["lovr.graphics.newMesh"],
          "description": "Meshes store arbitrary geometry data, and can be drawn with `Pass:draw`.\n\nMeshes hold a list of **vertices**.  The number of vertices is declared upfront when the Mesh is created, and it can not be resized afterwards.\n\nThe Mesh has a **vertex format**, which is a set of **attributes** comprising each vertex, like a `position`, `color`, etc.\n\nThe **vertex indices** in the Mesh describe the order that the vertices are rendered in.  This is an optimization that allows vertices to be reused if they are used for multiple triangles, without duplicating all of their data.\n\nThe Mesh has a **draw mode**, which controls how the vertices are connected together to create pixels.  It can either be `points`, `lines`, or `triangles`.\n\nThe Mesh can have a `Material` applied, which defines colors, textures, and other properties of its surface.\n\nThe **draw range** of the Mesh defines a subset of the vertices to render when the Mesh is drawn.\n\nThe **bounding box** of the Mesh allows L\u00d6VR to skip rendering it when it\u0027s out of view.",
          "key": "Mesh",
          "methods": [
            {
              "description": "Computes the axis-aligned bounding box of the Mesh from its vertices.\n\nIf the Mesh was created with the `gpu` storage mode, this function will do nothing and return `false`.\n\nIf the Mesh does not have an attribute named `VertexPosition` with the `f32x3` (aka `vec3`) type, this function will do nothing and return `false`.\n\nOtherwise, the bounding box will be set and the return value will be `true`.\n\nThe bounding box can also be assigned manually using `Mesh:setBoundingBox`, which can be used to set the bounding box on a `gpu` mesh or for cases where the bounding box is already known.\n\nPasses will use the bounding box of a Mesh to cull it against the cameras when `Pass:setViewCull` is enabled, which avoids rendering it when it\u0027s out of view.",
              "key": "Mesh:computeBoundingBox",
              "module": "lovr.graphics",
              "name": "computeBoundingBox",
              "related": [
                "Mesh:getBoundingBox",
                "Mesh:setBoundingBox",
                "Pass:setViewCull",
                "Collider:getAABB",
                "Shape:getAABB",
                "Model:getBoundingBox",
                "ModelData:getBoundingBox",
                "Mesh"
              ],
              "summary": "Compute the bounding box of the Mesh.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "Whether the bounding box was updated.",
                      "name": "updated",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the axis-aligned bounding box of the Mesh, or `nil` if the Mesh doesn\u0027t have a bounding box.\n\nMeshes with the `cpu` storage mode can compute their bounding box automatically using `Mesh:computeBoundingBox`.  The bounding box can also be set manually using `Mesh:setBoundingBox`.\n\nPasses will use the bounding box of a Mesh to cull it against the cameras when `Pass:setViewCull` is enabled, which avoids rendering it when it\u0027s out of view.",
              "key": "Mesh:getBoundingBox",
              "module": "lovr.graphics",
              "name": "getBoundingBox",
              "related": [
                "Mesh:computeBoundingBox",
                "Pass:setViewCull",
                "Collider:getAABB",
                "Shape:getAABB",
                "Model:getBoundingBox",
                "ModelData:getBoundingBox",
                "Mesh:setBoundingBox",
                "Mesh"
              ],
              "summary": "Get the bounding box of the Mesh.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The minimum x coordinate of the bounding box.",
                      "name": "minx",
                      "type": "number"
                    },
                    {
                      "description": "The maximum x coordinate of the bounding box.",
                      "name": "maxx",
                      "type": "number"
                    },
                    {
                      "description": "The minimum y coordinate of the bounding box.",
                      "name": "miny",
                      "type": "number"
                    },
                    {
                      "description": "The maximum y coordinate of the bounding box.",
                      "name": "maxy",
                      "type": "number"
                    },
                    {
                      "description": "The minimum z coordinate of the bounding box.",
                      "name": "minz",
                      "type": "number"
                    },
                    {
                      "description": "The maximum z coordinate of the bounding box.",
                      "name": "maxz",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the `DrawMode` of the mesh, which controls how the vertices in the Mesh are connected together to create pixels.  The default is `triangles`.",
              "key": "Mesh:getDrawMode",
              "module": "lovr.graphics",
              "name": "getDrawMode",
              "related": ["Pass:setMeshMode", "Mesh:setDrawMode", "Mesh"],
              "summary": "Get the draw mode of the Mesh.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The current draw mode.",
                      "name": "mode",
                      "type": "DrawMode"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the range of vertices drawn by the Mesh.  If different sets of mesh data are stored in a single Mesh object, the draw range can be used to select different sets of vertices to render.",
              "key": "Mesh:getDrawRange",
              "module": "lovr.graphics",
              "name": "getDrawRange",
              "related": ["Mesh:setIndices", "Mesh:setDrawRange", "Mesh"],
              "summary": "Get the range of vertices drawn by the Mesh.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The index of the first vertex that will be drawn (or the first index, if the Mesh has vertex indices).",
                      "name": "start",
                      "type": "number"
                    },
                    {
                      "description": "The number of vertices that will be drawn (or indices, if the Mesh has vertex indices).",
                      "name": "count",
                      "type": "number"
                    },
                    {
                      "description": "When the Mesh has vertex indices, an offset that will be added to the index values before fetching the corresponding vertex.  This is ignored if the Mesh does not have vertex indices.",
                      "name": "offset",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": {},
                  "description": "This function returns nothing if no draw range is set.",
                  "returns": {}
                }
              ]
            },
            {
              "description": "Returns the `Buffer` object that holds the data for the vertex indices in the Mesh.\n\nThis can be `nil` if the Mesh doesn\u0027t have any indices.\n\nIf a Mesh uses the `cpu` storage mode, the index buffer is internal to the `Mesh` and this function will return `nil`.  This ensures that the CPU data for the Mesh does not get out of sync with the GPU data in the Buffer.",
              "key": "Mesh:getIndexBuffer",
              "module": "lovr.graphics",
              "name": "getIndexBuffer",
              "related": [
                "Mesh:getIndices",
                "Mesh:setIndices",
                "Mesh:getVertexBuffer",
                "Mesh:setIndexBuffer",
                "Mesh"
              ],
              "summary": "Get the Buffer backing the vertex indices of the Mesh.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The index buffer.",
                      "name": "buffer",
                      "type": "Buffer"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns a table with the Mesh\u0027s vertex indices.",
              "key": "Mesh:getIndices",
              "module": "lovr.graphics",
              "name": "getIndices",
              "notes": "This function will be very very slow if the Mesh\u0027s storage is `gpu`, because the data needs to be downloaded from the GPU.",
              "related": [
                "Mesh:getIndexBuffer",
                "Mesh:setIndexBuffer",
                "Mesh:setIndices",
                "Mesh"
              ],
              "summary": "Get the vertex indices in the Mesh.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "A table of numbers with the 1-based vertex indices.",
                      "name": "t",
                      "type": "table"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the `Material` applied to the Mesh.",
              "key": "Mesh:getMaterial",
              "module": "lovr.graphics",
              "name": "getMaterial",
              "related": [
                "Pass:setMaterial",
                "Model:getMaterial",
                "lovr.graphics.newMaterial",
                "Mesh:setMaterial",
                "Mesh"
              ],
              "summary": "Get the Material applied to the Mesh.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The material.",
                      "name": "material",
                      "type": "Material"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the `Buffer` object that holds the data for the vertices in the Mesh.\n\nIf a Mesh uses the `cpu` storage mode, the vertex buffer is internal to the `Mesh` and this function will return `nil`.  This ensures that the CPU data for the Mesh does not get out of sync with the GPU data in the Buffer.",
              "key": "Mesh:getVertexBuffer",
              "module": "lovr.graphics",
              "name": "getVertexBuffer",
              "related": [
                "Mesh:getVertices",
                "Mesh:setVertices",
                "Mesh:getIndexBuffer",
                "Mesh"
              ],
              "summary": "Get the Buffer backing the vertices of the Mesh.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The vertex buffer.",
                      "name": "buffer",
                      "type": "Buffer"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the number of vertices in the Mesh.  The vertex count is set when the Mesh is created and can\u0027t change afterwards.",
              "key": "Mesh:getVertexCount",
              "module": "lovr.graphics",
              "name": "getVertexCount",
              "related": [
                "Mesh:getVertexStride",
                "Mesh:getVertexFormat",
                "lovr.graphics.newMesh",
                "Model:getMesh",
                "Mesh"
              ],
              "summary": "Get the number of vertices in the Mesh.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The number of vertices in the Mesh.",
                      "name": "count",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the vertex format of the Mesh, which is a list of \"attributes\" that make up the data for each vertex (position, color, UV, etc.).",
              "key": "Mesh:getVertexFormat",
              "module": "lovr.graphics",
              "name": "getVertexFormat",
              "notes": "If no vertex format is given when the Mesh is created, it will use a default format:\n\n    {\n      { \u0027VertexPosition\u0027, \u0027vec3\u0027, 0 },\n      { \u0027VertexNormal\u0027, \u0027vec3\u0027, 12 },\n      { \u0027VertexUV\u0027, \u0027vec2\u0027, 24 }\n    }\n\nThe name of the vertex attribute corresponds to an `in` input variable in a vertex shader.\n\nThere are a few built-in attributes that all shaders will understand and use by default:\n\n\u003ctable\u003e\n  \u003cthead\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eName\u003c\/td\u003e\n      \u003ctd\u003eDescription\u003c\/td\u003e\n    \u003c\/tr\u003e\n  \u003c\/thead\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003eVertexPosition\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003eThe position of the vertex.\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003eVertexNormal\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003eThe normal vector of the vertex.\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003eVertexUV\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003eThe texture coordinate of the vertex.\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003eVertexColor\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003eThe color of the vertex (linear color space).\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ccode\u003eVertexTangent\u003c\/code\u003e\u003c\/td\u003e\n      \u003ctd\u003eThe tangent vector of the vertex.\u003c\/td\u003e\n    \u003c\/tr\u003e\n  \u003c\/tbody\u003e \u003c\/table\u003e\n\nSee the `Shaders` and `Meshes` guides for more info.",
              "related": [
                "Mesh:getVertexCount",
                "Mesh:getVertexStride",
                "lovr.graphics.newMesh",
                "Mesh"
              ],
              "summary": "Get the vertex format of the Mesh.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The vertex format.",
                      "name": "format",
                      "table": [
                        {
                          "description": "The name of the attribute.",
                          "name": "[][1]",
                          "type": "string"
                        },
                        {
                          "description": "The type of the attribute.",
                          "name": "[][2]",
                          "type": "DataType"
                        },
                        {
                          "description": "The byte offset of the attribute.",
                          "name": "[][3]",
                          "type": "number"
                        }
                      ],
                      "type": "table"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the stride of the Mesh, which is the number of bytes used by each vertex.",
              "key": "Mesh:getVertexStride",
              "module": "lovr.graphics",
              "name": "getVertexStride",
              "related": [
                "Mesh:getVertexCount",
                "Mesh:getVertexFormat",
                "lovr.graphics.newMesh",
                "Mesh"
              ],
              "summary": "Get the size of each vertex in the Mesh.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The stride of the Mesh, in bytes.",
                      "name": "stride",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the vertices in the Mesh.",
              "key": "Mesh:getVertices",
              "module": "lovr.graphics",
              "name": "getVertices",
              "notes": "\u003e **This function will be very very slow if the storage mode of the Mesh is `gpu`, because the\n\u003e data will be downloaded from VRAM.  A better option is to call `Buffer:newReadback` on the\n\u003e Mesh\u0027s underlying vertex buffer (`Mesh:getVertexBuffer`), which will download in the\n\u003e background instead of waiting for it to complete.**",
              "related": [
                "Mesh:getVertexBuffer",
                "Mesh:getVertexFormat",
                "Mesh:getIndices",
                "Mesh:setIndices",
                "Mesh:setVertices",
                "Mesh"
              ],
              "summary": "Get the vertices in the Mesh.",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "1",
                      "description": "The index of the first vertex to return.",
                      "name": "index",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "The number of vertices to return.  If nil, returns the \"rest\" of the vertices, based on the `index` argument.",
                      "name": "count",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "A table of vertices.  Each vertex is a table of numbers for each vertex attribute, given by the vertex format of the Mesh.",
                      "name": "vertices",
                      "type": "table"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Sets or removes the axis-aligned bounding box of the Mesh.\n\nMeshes with the `cpu` storage mode can compute their bounding box automatically using `Mesh:computeBoundingBox`.\n\nPasses will use the bounding box of a Mesh to cull it against the cameras when `Pass:setViewCull` is enabled, which avoids rendering it when it\u0027s out of view.",
              "key": "Mesh:setBoundingBox",
              "module": "lovr.graphics",
              "name": "setBoundingBox",
              "related": [
                "Mesh:computeBoundingBox",
                "Pass:setViewCull",
                "Collider:getAABB",
                "Shape:getAABB",
                "Model:getBoundingBox",
                "ModelData:getBoundingBox",
                "Mesh:getBoundingBox",
                "Mesh"
              ],
              "summary": "Set or remove the bounding box of the Mesh.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The minimum x coordinate of the bounding box.",
                      "name": "minx",
                      "type": "number"
                    },
                    {
                      "description": "The maximum x coordinate of the bounding box.",
                      "name": "maxx",
                      "type": "number"
                    },
                    {
                      "description": "The minimum y coordinate of the bounding box.",
                      "name": "miny",
                      "type": "number"
                    },
                    {
                      "description": "The maximum y coordinate of the bounding box.",
                      "name": "maxy",
                      "type": "number"
                    },
                    {
                      "description": "The minimum z coordinate of the bounding box.",
                      "name": "minz",
                      "type": "number"
                    },
                    {
                      "description": "The maximum z coordinate of the bounding box.",
                      "name": "maxz",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": {},
                  "description": "Remove the bounding box.",
                  "returns": {}
                }
              ]
            },
            {
              "description": "Changes the `DrawMode` of the mesh, which controls how the vertices in the Mesh are connected together to create pixels.  The default is `triangles`.",
              "key": "Mesh:setDrawMode",
              "module": "lovr.graphics",
              "name": "setDrawMode",
              "related": ["Pass:setMeshMode", "Mesh:getDrawMode", "Mesh"],
              "summary": "Set the draw mode of the Mesh.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The current draw mode.",
                      "name": "mode",
                      "type": "DrawMode"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the range of vertices drawn by the Mesh.  If different sets of mesh data are stored in a single Mesh object, the draw range can be used to select different sets of vertices to render.",
              "key": "Mesh:setDrawRange",
              "module": "lovr.graphics",
              "name": "setDrawRange",
              "notes": "When using an index buffer, the draw range defines a range of indices to render instead of a range of vertices.  Additionally, a vertex offset can be set, which is added to the values in the index buffer before fetching the vertices.  This makes it easier to pack multiple sets of indexed mesh data in a single Mesh object, without having to manually offset the data in each index buffer.",
              "related": ["Mesh:setIndices", "Mesh:getDrawRange", "Mesh"],
              "summary": "Set the range of vertices drawn by the Mesh.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of the first vertex that will be drawn (or the first index, if the Mesh has vertex indices).",
                      "name": "start",
                      "type": "number"
                    },
                    {
                      "description": "The number of vertices that will be drawn (or indices, if the Mesh has vertex indices).",
                      "name": "count",
                      "type": "number"
                    },
                    {
                      "description": "When the Mesh has vertex indices, an offset that will be added to the index values before fetching the corresponding vertex.  This is ignored if the Mesh does not have vertex indices.",
                      "name": "offset",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": {},
                  "description": "Disable the draw range.  The Mesh will draw all of its vertices.",
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets a `Buffer` object the Mesh will use for vertex indices.\n\nThis can only be used if the Mesh uses the `gpu` storage mode.\n\nThe Buffer must have a single field with the `u16`, `u32`, `index16`, or `index32` type.",
              "examples": [
                {
                  "code": "function lovr.load()\n  mesh \u003d lovr.graphics.newMesh({\n    { -1,  1, 0 }, -- upper left\n    {  1,  1, 0 }, -- upper right\n    { -1, -1, 0 }, -- lower left\n    {  1, -1, 0 }, -- lower right\n  }, \u0027gpu\u0027)\n\n  -- 2 triangles\n  local indices \u003d { 1,3,2, 2,3,4 }\n\n  local indexBuffer \u003d lovr.graphics.newBuffer(\u0027index16\u0027, indices)\n  mesh:setIndexBuffer(indexBuffer)\nend\n\nfunction lovr.draw(pass)\n  pass:draw(mesh, 0, 1.7, -2)\nend",
                  "description": "Use an index buffer to draw a plane."
                }
              ],
              "key": "Mesh:setIndexBuffer",
              "module": "lovr.graphics",
              "name": "setIndexBuffer",
              "notes": "The index buffer stores a list of numbers where each number is the index of a vertex in the Mesh.  When drawing the Mesh, the data from the vertex corresponding to the index is used.  This can be used to reorder or reuse vertices, which uses less data than repeating a vertex multiple times in the Mesh.",
              "related": [
                "Mesh:getIndices",
                "Mesh:setIndices",
                "Mesh:getVertexBuffer",
                "Mesh:getIndexBuffer",
                "Mesh"
              ],
              "summary": "Set a Buffer for the Mesh to use for vertex indices.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index buffer.",
                      "name": "buffer",
                      "type": "Buffer"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets or clears the vertex indices of the Mesh.  Vertex indices define the list of triangles in the mesh.  They allow vertices to be reused multiple times without duplicating all their data, which can save a lot of memory and processing time if a vertex is used for multiple triangles.\n\nIf a Mesh doesn\u0027t have vertex indices, then the vertices are rendered in order.",
              "key": "Mesh:setIndices",
              "module": "lovr.graphics",
              "name": "setIndices",
              "related": [
                "Mesh:getIndexBuffer",
                "Mesh:setIndexBuffer",
                "Mesh:setVertices",
                "Mesh:getIndices",
                "Mesh"
              ],
              "summary": "Set the vertex indices of the Mesh.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "A list of numbers (1-based).",
                      "name": "t",
                      "type": "table"
                    }
                  ],
                  "description": "Set vertex indices using a table.",
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The Blob with index data.",
                      "name": "blob",
                      "type": "Blob"
                    },
                    {
                      "description": "The type of index data in the Blob.  Must be `u16` or `u32`.",
                      "name": "type",
                      "type": "DataType"
                    }
                  ],
                  "description": "Set vertex indices using a Blob.",
                  "returns": {}
                },
                {
                  "arguments": {},
                  "description": "Disable vertex indices.",
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets a `Material` to use when drawing the Mesh.",
              "key": "Mesh:setMaterial",
              "module": "lovr.graphics",
              "name": "setMaterial",
              "related": [
                "Pass:setMaterial",
                "Model:getMaterial",
                "lovr.graphics.newMaterial",
                "Mesh:getMaterial",
                "Mesh"
              ],
              "summary": "Set a Material to use when drawing the Mesh.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The material to use.",
                      "name": "material",
                      "type": "Material"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The texture to use as the material.",
                      "name": "texture",
                      "type": "Texture"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the data for vertices in the Mesh.",
              "key": "Mesh:setVertices",
              "module": "lovr.graphics",
              "name": "setVertices",
              "notes": "Note that a `Pass` that draws a Mesh will only \"see\" the vertices as they exist when the pass is submitted.  So, if this function is used to change vertices multiple times before submitting the Pass, only the final value of each vertex will be used.  Example:\n\n    function lovr.draw(pass)\n      -- Due to the second :setVertices call below, the Mesh\n      -- contains a sphere when this pass is submitted!  So\n      -- this code will actually draw 2 spheres!\n      mesh:setVertices(cube)\n      pass:draw(mesh, x1, y1, z1)\n\n      mesh:setVertices(sphere)\n      pass:draw(mesh, x2, y2, z2)\n    end\n\nIf you want multiple meshes, then use multiple Mesh objects!  Or, *append* vertices to the Mesh instead of replacing them, and use `Mesh:setDrawRange` to control which vertices are drawn for a particular draw call.\n\nCPU meshes will write the data to CPU memory and upload any changes to the GPU before the Mesh is drawn.  GPU meshes don\u0027t store this CPU copy of the data, and will immediately upload the new vertex data to VRAM.  This means that multiple calls to this function might be slower on a `gpu` mesh.",
              "related": [
                "Mesh:getVertexBuffer",
                "Mesh:getVertexFormat",
                "Mesh:getIndices",
                "Mesh:setIndices",
                "Mesh:getVertices",
                "Mesh"
              ],
              "summary": "Set vertices in the Mesh.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "A table of vertices, where each vertex is a table of numbers matching the vertex format of the Mesh.",
                      "name": "vertices",
                      "type": "table"
                    },
                    {
                      "default": "1",
                      "description": "The index of the first vertex to return.",
                      "name": "index",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "The number of vertices to return.  If nil, returns the \"rest\" of the vertices, based on the `index` argument.",
                      "name": "count",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "A Blob containing binary vertex data.",
                      "name": "blob",
                      "type": "Blob"
                    },
                    {
                      "default": "1",
                      "description": "The index of the first vertex to return.",
                      "name": "index",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "The number of vertices to return.  If nil, returns the \"rest\" of the vertices, based on the `index` argument.",
                      "name": "count",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            }
          ],
          "module": "lovr.graphics",
          "name": "Mesh",
          "related": ["lovr.graphics"],
          "summary": "A drawable triangle mesh."
        },
        {
          "constructors": ["lovr.graphics.newModel", "lovr.headset.newModel"],
          "description": "Models are 3D model assets loaded from files.  Currently, OBJ, glTF, and binary STL files are supported.\n\nA model can be drawn using `Pass:draw`.\n\nThe raw CPU data for a model is held in a `ModelData` object, which can be loaded on threads or reused for multiple Model instances.\n\nModels have a hierarchy of nodes which can have their transforms modified.  Meshes are attached to these nodes.  The same mesh can be attached to multiple nodes, allowing it to be drawn multiple times while only storing a single copy of its data.\n\nModels can have animations.  Animations have keyframes which affect the transforms of nodes. Right now each model can only be drawn with a single animated pose per frame.\n\nModels can have materials, which are collections of properties and textures that define how its surface is affected by lighting.  Each mesh in the model can use a single material.",
          "key": "Model",
          "methods": [
            {
              "description": "Animates a Model by setting or blending the transforms of nodes using data stored in the keyframes of an animation.\n\nThe animation from the model file is evaluated at the timestamp, resulting in a set of node properties.  These properties are then applied to the nodes in the model, using an optional blend factor.  If the animation doesn\u0027t have keyframes that target a given node, the node will remain unchanged.",
              "key": "Model:animate",
              "module": "lovr.graphics",
              "name": "animate",
              "notes": "If the timestamp is larger than the duration of the animation, it will wrap back around to zero, so looping an animation doesn\u0027t require using the modulo operator.\n\nTo change the speed of the animation, multiply the timestamp by a speed factor.\n\nFor each animated property in the animation, if the timestamp used for the animation is less than the timestamp of the first keyframe, the data of the first keyframe will be used.\n\nThis function can be called multiple times to layer and blend animations.  The model joints will be drawn in the final resulting pose.\n\n`Model:resetNodeTransforms` can be used to reset the model nodes to their initial transforms, which is helpful to ensure animating starts from a clean slate.",
              "related": [
                "Model:resetNodeTransforms",
                "Model:getAnimationCount",
                "Model:getAnimationName",
                "Model:getAnimationDuration",
                "Model:getNodePosition",
                "Model:setNodePosition",
                "Model:getNodeOrientation",
                "Model:setNodeOrientation",
                "Model:getNodeScale",
                "Model:setNodeScale",
                "Model:getNodeTransform",
                "Model:setNodeTransform",
                "Model"
              ],
              "summary": "Animate the Model.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The name of an animation in the model file.",
                      "name": "name",
                      "type": "string"
                    },
                    {
                      "description": "The timestamp to evaluate the keyframes at, in seconds.",
                      "name": "time",
                      "type": "number"
                    },
                    {
                      "default": "1.0",
                      "description": "How much of the animation\u0027s pose to blend into the nodes, from 0 to 1.",
                      "name": "blend",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The index of an animation in the model file.",
                      "name": "index",
                      "type": "number"
                    },
                    {
                      "description": "The timestamp to evaluate the keyframes at, in seconds.",
                      "name": "time",
                      "type": "number"
                    },
                    {
                      "default": "1.0",
                      "description": "How much of the animation\u0027s pose to blend into the nodes, from 0 to 1.",
                      "name": "blend",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Returns a lightweight copy of a Model.  Most of the data will be shared between the two copies of the model, like the materials, textures, and metadata.  However, the clone has its own set of node transforms, allowing it to be animated separately from its parent.  This allows a single model to be rendered in multiple different animation poses in a frame.",
              "key": "Model:clone",
              "module": "lovr.graphics",
              "name": "clone",
              "notes": "The node transforms of the clone will be reset to their initial setup poses.",
              "related": ["lovr.graphics.newModel", "Model"],
              "summary": "Return a lightweight copy of the Model with its own animation state.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "A genetically identical copy of the Model.",
                      "name": "model",
                      "type": "Model"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the number of animations in the Model.",
              "key": "Model:getAnimationCount",
              "module": "lovr.graphics",
              "name": "getAnimationCount",
              "related": [
                "Model:getAnimationName",
                "Model:getAnimationDuration",
                "Model:animate",
                "Model"
              ],
              "summary": "Get the number of animations in the Model.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The number of animations in the Model.",
                      "name": "count",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the duration of an animation in the Model, in seconds.",
              "key": "Model:getAnimationDuration",
              "module": "lovr.graphics",
              "name": "getAnimationDuration",
              "notes": "The duration of an animation is calculated as the largest timestamp of all of its keyframes.",
              "related": [
                "Model:getAnimationCount",
                "Model:getAnimationName",
                "Model:animate",
                "Model"
              ],
              "summary": "Get the duration of an animation in the Model.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The animation index.",
                      "name": "index",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The duration of the animation, in seconds.",
                      "name": "duration",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The name of the animation.",
                      "name": "name",
                      "type": "string"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The duration of the animation, in seconds.",
                      "name": "duration",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the name of an animation in the Model.",
              "key": "Model:getAnimationName",
              "module": "lovr.graphics",
              "name": "getAnimationName",
              "related": [
                "Model:getAnimationCount",
                "Model:getAnimationDuration",
                "Model"
              ],
              "summary": "Get the name of an animation in the Model.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of an animation.",
                      "name": "index",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The name of the animation.",
                      "name": "name",
                      "type": "string"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the number of blend shapes in the model.",
              "key": "Model:getBlendShapeCount",
              "module": "lovr.graphics",
              "name": "getBlendShapeCount",
              "related": [
                "Model:getBlendShapeName",
                "ModelData:getBlendShapeCount",
                "Model"
              ],
              "summary": "Get the number of blend shapes in the model.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The number of blend shapes in the model.",
                      "name": "count",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the name of a blend shape in the model.",
              "key": "Model:getBlendShapeName",
              "module": "lovr.graphics",
              "name": "getBlendShapeName",
              "notes": "This function will throw an error if the blend shape index is invalid.",
              "related": [
                "Model:getBlendShapeCount",
                "ModelData:getBlendShapeName",
                "Model"
              ],
              "summary": "Get the name of a blend shape in the model.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of a blend shape.",
                      "name": "index",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The name of the blend shape.",
                      "name": "name",
                      "type": "string"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the weight of a blend shape.  A blend shape contains offset values for the vertices of one of the meshes in a Model.  Whenever the Model is drawn, the offsets are multiplied by the weight of the blend shape, allowing for smooth blending between different meshes.  A weight of zero won\u0027t apply any displacement and will skip processing of the blend shape.",
              "key": "Model:getBlendShapeWeight",
              "module": "lovr.graphics",
              "name": "getBlendShapeWeight",
              "notes": "The initial weights are declared in the model file.\n\nWeights can be any number, but usually they\u0027re kept between 0 and 1.\n\nThis function will throw an error if the blend shape name or index doesn\u0027t exist.",
              "related": [
                "Model:getBlendShapeCount",
                "Model:getBlendShapeName",
                "Model:resetBlendShapes",
                "Model:setBlendShapeWeight",
                "Model"
              ],
              "summary": "Get the weight of a blend shape.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of a blend shape.",
                      "name": "index",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The weight of the blend shape.",
                      "name": "weight",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The name of a blend shape.",
                      "name": "name",
                      "type": "string"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The weight of the blend shape.",
                      "name": "weight",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the 6 values of the Model\u0027s axis-aligned bounding box.",
              "key": "Model:getBoundingBox",
              "module": "lovr.graphics",
              "name": "getBoundingBox",
              "related": [
                "Model:getWidth",
                "Model:getHeight",
                "Model:getDepth",
                "Model:getDimensions",
                "Model:getCenter",
                "Model:getBoundingSphere",
                "ModelData:getBoundingBox",
                "Collider:getAABB",
                "Model"
              ],
              "summary": "Get the bounding box of the Model.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The minimum x coordinate of the vertices in the Model.",
                      "name": "minx",
                      "type": "number"
                    },
                    {
                      "description": "The maximum x coordinate of the vertices in the Model.",
                      "name": "maxx",
                      "type": "number"
                    },
                    {
                      "description": "The minimum y coordinate of the vertices in the Model.",
                      "name": "miny",
                      "type": "number"
                    },
                    {
                      "description": "The maximum y coordinate of the vertices in the Model.",
                      "name": "maxy",
                      "type": "number"
                    },
                    {
                      "description": "The minimum z coordinate of the vertices in the Model.",
                      "name": "minz",
                      "type": "number"
                    },
                    {
                      "description": "The maximum z coordinate of the vertices in the Model.",
                      "name": "maxz",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns a sphere approximately enclosing the vertices in the Model.",
              "key": "Model:getBoundingSphere",
              "module": "lovr.graphics",
              "name": "getBoundingSphere",
              "related": [
                "Model:getWidth",
                "Model:getHeight",
                "Model:getDepth",
                "Model:getDimensions",
                "Model:getCenter",
                "Model:getBoundingBox",
                "ModelData:getBoundingSphere",
                "Model"
              ],
              "summary": "Get the bounding sphere of the Model.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The x coordinate of the position of the sphere.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate of the position of the sphere.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z coordinate of the position of the sphere.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The radius of the bounding sphere.",
                      "name": "radius",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the center of the Model\u0027s axis-aligned bounding box, relative to the Model\u0027s origin.",
              "key": "Model:getCenter",
              "module": "lovr.graphics",
              "name": "getCenter",
              "related": [
                "Model:getWidth",
                "Model:getHeight",
                "Model:getDepth",
                "Model:getDimensions",
                "Model:getBoundingBox",
                "ModelData:getCenter",
                "Model"
              ],
              "summary": "Get the center of the Model\u0027s bounding box.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The x offset of the center of the bounding box.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y offset of the center of the bounding box.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z offset of the center of the bounding box.",
                      "name": "z",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the ModelData this Model was created from.",
              "key": "Model:getData",
              "module": "lovr.graphics",
              "name": "getData",
              "related": ["lovr.data.newModelData", "Model"],
              "summary": "Get the ModelData backing the Model.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The ModelData.",
                      "name": "data",
                      "type": "ModelData"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the depth of the Model, computed from its axis-aligned bounding box.",
              "key": "Model:getDepth",
              "module": "lovr.graphics",
              "name": "getDepth",
              "related": [
                "Model:getWidth",
                "Model:getHeight",
                "Model:getDimensions",
                "Model:getCenter",
                "Model:getBoundingBox",
                "ModelData:getDepth",
                "Model"
              ],
              "summary": "Get the depth of the Model.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The depth of the Model.",
                      "name": "depth",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the width, height, and depth of the Model, computed from its axis-aligned bounding box.",
              "key": "Model:getDimensions",
              "module": "lovr.graphics",
              "name": "getDimensions",
              "related": [
                "Model:getWidth",
                "Model:getHeight",
                "Model:getDepth",
                "Model:getCenter",
                "Model:getBoundingBox",
                "ModelData:getDimensions",
                "Model"
              ],
              "summary": "Get the dimensions of the Model.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The width of the Model.",
                      "name": "width",
                      "type": "number"
                    },
                    {
                      "description": "The height of the Model.",
                      "name": "height",
                      "type": "number"
                    },
                    {
                      "description": "The depth of the Model.",
                      "name": "depth",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the height of the Model, computed from its axis-aligned bounding box.",
              "key": "Model:getHeight",
              "module": "lovr.graphics",
              "name": "getHeight",
              "related": [
                "Model:getWidth",
                "Model:getDepth",
                "Model:getDimensions",
                "Model:getCenter",
                "Model:getBoundingBox",
                "ModelData:getHeight",
                "Model"
              ],
              "summary": "Get the height of the Model.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The height of the Model.",
                      "name": "height",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the index buffer used by the Model.  The index buffer describes the order used to draw the vertices in each mesh.",
              "key": "Model:getIndexBuffer",
              "module": "lovr.graphics",
              "name": "getIndexBuffer",
              "related": ["Model:getVertexBuffer", "Model:getMesh", "Model"],
              "summary": "Get a Buffer containing the triangle indices in the Model.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The index buffer.",
                      "name": "buffer",
                      "type": "Buffer"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns a `Material` loaded from the Model.",
              "key": "Model:getMaterial",
              "module": "lovr.graphics",
              "name": "getMaterial",
              "related": [
                "Model:getMaterialCount",
                "Model:getMaterialName",
                "Model"
              ],
              "summary": "Get a Material from the Model.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The name of the Material to return.",
                      "name": "name",
                      "type": "string"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The material.",
                      "name": "material",
                      "type": "Material"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The index of the Material to return.",
                      "name": "index",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The material.",
                      "name": "material",
                      "type": "Material"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the number of materials in the Model.",
              "key": "Model:getMaterialCount",
              "module": "lovr.graphics",
              "name": "getMaterialCount",
              "related": [
                "Model:getMaterialName",
                "Model:getMaterial",
                "Model"
              ],
              "summary": "Get the number of materials in the Model.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The number of materials in the Model.",
                      "name": "count",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the name of a material in the Model.",
              "key": "Model:getMaterialName",
              "module": "lovr.graphics",
              "name": "getMaterialName",
              "related": [
                "Model:getMaterialCount",
                "Model:getMaterial",
                "Model"
              ],
              "summary": "Get the name of a material in the Model.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of a material.",
                      "name": "index",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The name of the material.",
                      "name": "name",
                      "type": "string"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns a `Mesh` from the Model.",
              "key": "Model:getMesh",
              "module": "lovr.graphics",
              "name": "getMesh",
              "related": [
                "Model:getMeshCount",
                "lovr.graphics.newMesh",
                "Model"
              ],
              "summary": "Get a Mesh from the Model.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of the Mesh to return.",
                      "name": "index",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The mesh object.",
                      "name": "mesh",
                      "type": "Mesh"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the number of meshes in the Model.",
              "key": "Model:getMeshCount",
              "module": "lovr.graphics",
              "name": "getMeshCount",
              "related": ["Model:getMesh", "Model"],
              "summary": "Get the number of meshes in the Model.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The number of meshes in the Model.",
                      "name": "count",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns extra information stored in the model file.  Currently this is only implemented for glTF models and returns the JSON string from the glTF or glb file.  The metadata can be used to get application-specific data or add support for glTF extensions not supported by L\u00d6VR.",
              "key": "Model:getMetadata",
              "module": "lovr.graphics",
              "name": "getMetadata",
              "related": ["Model"],
              "summary": "Get extra information from the model file.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The metadata from the model file.",
                      "name": "metadata",
                      "type": "string"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Given a parent node, this function returns a table with the indices of its children.",
              "key": "Model:getNodeChildren",
              "module": "lovr.graphics",
              "name": "getNodeChildren",
              "notes": "If the node does not have any children, this function returns an empty table.",
              "related": ["Model:getNodeParent", "Model:getRootNode", "Model"],
              "summary": "Get the children of a node.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of the parent node.",
                      "name": "index",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "A table containing a node index for each child of the node.",
                      "name": "children",
                      "type": "table"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The name of the parent node.",
                      "name": "name",
                      "type": "string"
                    }
                  ],
                  "returns": [
                    {
                      "description": "A table containing a node index for each child of the node.",
                      "name": "children",
                      "type": "table"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the number of nodes in the model.",
              "key": "Model:getNodeCount",
              "module": "lovr.graphics",
              "name": "getNodeCount",
              "related": ["Model"],
              "summary": "Get the number of nodes in the model.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The number of nodes in the model.",
                      "name": "count",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the name of a node.",
              "key": "Model:getNodeName",
              "module": "lovr.graphics",
              "name": "getNodeName",
              "related": [
                "Model:getNodeCount",
                "Model:getAnimationName",
                "Model:getMaterialName",
                "Model"
              ],
              "summary": "Get the name of a node in the Model.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of the node.",
                      "name": "index",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The name of the node.",
                      "name": "name",
                      "type": "string"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the orientation of a node.",
              "key": "Model:getNodeOrientation",
              "module": "lovr.graphics",
              "name": "getNodeOrientation",
              "related": [
                "Model:getNodePosition",
                "Model:setNodePosition",
                "Model:getNodeScale",
                "Model:setNodeScale",
                "Model:getNodePose",
                "Model:setNodePose",
                "Model:getNodeTransform",
                "Model:setNodeTransform",
                "Model:animate",
                "Model:setNodeOrientation",
                "Model"
              ],
              "summary": "Get the orientation of a node.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of the node.",
                      "name": "index",
                      "type": "number"
                    },
                    {
                      "default": "\u0027root\u0027",
                      "description": "Whether the orientation should be returned relative to the root node or the node\u0027s parent.",
                      "name": "origin",
                      "type": "OriginType"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The number of radians the node is rotated around its axis of rotation.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The name of the node.",
                      "name": "name",
                      "type": "string"
                    },
                    {
                      "default": "\u0027root\u0027",
                      "description": "Whether the orientation should be returned relative to the root node or the node\u0027s parent.",
                      "name": "origin",
                      "type": "OriginType"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The number of radians the node is rotated around its axis of rotation.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Given a child node, this function returns the index of its parent.",
              "key": "Model:getNodeParent",
              "module": "lovr.graphics",
              "name": "getNodeParent",
              "related": [
                "Model:getNodeChildren",
                "Model:getRootNode",
                "Model"
              ],
              "summary": "Get the parent of a node.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of the child node.",
                      "name": "index",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The index of the parent.",
                      "name": "parent",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The name of the child node.",
                      "name": "name",
                      "type": "string"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The index of the parent.",
                      "name": "parent",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the pose (position and orientation) of a node.",
              "key": "Model:getNodePose",
              "module": "lovr.graphics",
              "name": "getNodePose",
              "related": [
                "Model:getNodePosition",
                "Model:setNodePosition",
                "Model:getNodeOrientation",
                "Model:setNodeOrientation",
                "Model:getNodeScale",
                "Model:setNodeScale",
                "Model:getNodeTransform",
                "Model:setNodeTransform",
                "Model:animate",
                "Model:setNodePose",
                "Model"
              ],
              "summary": "Get the pose of a node.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of a node.",
                      "name": "index",
                      "type": "number"
                    },
                    {
                      "default": "\u0027root\u0027",
                      "description": "Whether the pose should be returned relative to the root node or the node\u0027s parent.",
                      "name": "origin",
                      "type": "OriginType"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The x position of the node.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y position of the node.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z position of the node.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The number of radians the node is rotated around its axis of rotation.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The name of a node.",
                      "name": "name",
                      "type": "string"
                    },
                    {
                      "default": "\u0027root\u0027",
                      "description": "Whether the pose should be returned relative to the root node or the node\u0027s parent.",
                      "name": "origin",
                      "type": "OriginType"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The x position of the node.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y position of the node.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z position of the node.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The number of radians the node is rotated around its axis of rotation.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the position of a node.",
              "key": "Model:getNodePosition",
              "module": "lovr.graphics",
              "name": "getNodePosition",
              "related": [
                "Model:getNodeOrientation",
                "Model:setNodeOrientation",
                "Model:getNodeScale",
                "Model:setNodeScale",
                "Model:getNodePose",
                "Model:setNodePose",
                "Model:getNodeTransform",
                "Model:setNodeTransform",
                "Model:animate",
                "Model:setNodePosition",
                "Model"
              ],
              "summary": "Get the position of a node.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of the node.",
                      "name": "index",
                      "type": "number"
                    },
                    {
                      "default": "\u0027root\u0027",
                      "description": "Whether the position should be returned relative to the root node or the node\u0027s parent.",
                      "name": "space",
                      "type": "OriginType"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The x coordinate.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z coordinate.",
                      "name": "z",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The name of the node.",
                      "name": "name",
                      "type": "string"
                    },
                    {
                      "default": "\u0027root\u0027",
                      "description": "Whether the position should be returned relative to the root node or the node\u0027s parent.",
                      "name": "space",
                      "type": "OriginType"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The x coordinate.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z coordinate.",
                      "name": "z",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the scale of a node.",
              "key": "Model:getNodeScale",
              "module": "lovr.graphics",
              "name": "getNodeScale",
              "related": [
                "Model:getNodePosition",
                "Model:setNodePosition",
                "Model:getNodeOrientation",
                "Model:setNodeOrientation",
                "Model:getNodePose",
                "Model:setNodePose",
                "Model:getNodeTransform",
                "Model:setNodeTransform",
                "Model:animate",
                "Model:setNodeScale",
                "Model"
              ],
              "summary": "Get the scale of a node.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of the node.",
                      "name": "index",
                      "type": "number"
                    },
                    {
                      "default": "\u0027root\u0027",
                      "description": "Whether the scale should be returned relative to the root node or the node\u0027s parent.",
                      "name": "origin",
                      "type": "OriginType"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The x scale.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y scale.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z scale.",
                      "name": "z",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The name of the node.",
                      "name": "name",
                      "type": "string"
                    },
                    {
                      "default": "\u0027root\u0027",
                      "description": "Whether the scale should be returned relative to the root node or the node\u0027s parent.",
                      "name": "origin",
                      "type": "OriginType"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The x scale.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y scale.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z scale.",
                      "name": "z",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the transform (position, scale, and rotation) of a node.",
              "key": "Model:getNodeTransform",
              "module": "lovr.graphics",
              "name": "getNodeTransform",
              "related": [
                "Model:getNodePosition",
                "Model:setNodePosition",
                "Model:getNodeOrientation",
                "Model:setNodeOrientation",
                "Model:getNodeScale",
                "Model:setNodeScale",
                "Model:getNodePose",
                "Model:setNodePose",
                "Model:animate",
                "Model:setNodeTransform",
                "Model"
              ],
              "summary": "Get the transform of a node.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of a node.",
                      "name": "index",
                      "type": "number"
                    },
                    {
                      "default": "\u0027root\u0027",
                      "description": "Whether the transform should be returned relative to the root node or the node\u0027s parent.",
                      "name": "origin",
                      "type": "OriginType"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The x position of the node.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y position of the node.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z position of the node.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The x scale of the node.",
                      "name": "sx",
                      "type": "number"
                    },
                    {
                      "description": "The y scale of the node.",
                      "name": "sy",
                      "type": "number"
                    },
                    {
                      "description": "The z scale of the node.",
                      "name": "sz",
                      "type": "number"
                    },
                    {
                      "description": "The number of radians the node is rotated around its axis of rotation.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The name of a node.",
                      "name": "name",
                      "type": "string"
                    },
                    {
                      "default": "\u0027root\u0027",
                      "description": "Whether the transform should be returned relative to the root node or the node\u0027s parent.",
                      "name": "origin",
                      "type": "OriginType"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The x position of the node.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y position of the node.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z position of the node.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The x scale of the node.",
                      "name": "sx",
                      "type": "number"
                    },
                    {
                      "description": "The y scale of the node.",
                      "name": "sy",
                      "type": "number"
                    },
                    {
                      "description": "The z scale of the node.",
                      "name": "sz",
                      "type": "number"
                    },
                    {
                      "description": "The number of radians the node is rotated around its axis of rotation.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the index of the model\u0027s root node.",
              "key": "Model:getRootNode",
              "module": "lovr.graphics",
              "name": "getRootNode",
              "related": ["Model:getNodeCount", "Model:getNodeParent", "Model"],
              "summary": "Get the index of the root node.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The index of the root node.",
                      "name": "root",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns one of the textures in the Model.",
              "key": "Model:getTexture",
              "module": "lovr.graphics",
              "name": "getTexture",
              "related": [
                "Model:getTextureCount",
                "Model:getMaterial",
                "Model"
              ],
              "summary": "Get one of the textures in the Model.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of the texture to get.",
                      "name": "index",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The texture.",
                      "name": "texture",
                      "type": "Texture"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the number of textures in the Model.",
              "key": "Model:getTextureCount",
              "module": "lovr.graphics",
              "name": "getTextureCount",
              "related": ["Model:getTexture", "Model"],
              "summary": "Get the number of textures in the Model.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The number of textures in the Model.",
                      "name": "count",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the total number of triangles in the Model.",
              "key": "Model:getTriangleCount",
              "module": "lovr.graphics",
              "name": "getTriangleCount",
              "notes": "This isn\u0027t always related to the length of the vertex buffer, since a mesh in the Model could be drawn by multiple nodes.",
              "related": [
                "Model:getTriangles",
                "Model:getVertexCount",
                "ModelData:getTriangleCount",
                "Model:getMesh",
                "Model"
              ],
              "summary": "Get the total number of triangles in the Model.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The total number of triangles in the Model.",
                      "name": "count",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns 2 tables containing mesh data for the Model.\n\nThe first table is a list of vertex positions and contains 3 numbers for the x, y, and z coordinate of each vertex.  The second table is a list of triangles and contains 1-based indices into the first table representing the first, second, and third vertices that make up each triangle.\n\nThe vertex positions will be affected by node transforms.",
              "key": "Model:getTriangles",
              "module": "lovr.graphics",
              "name": "getTriangles",
              "notes": "After this function is called on a Model once, the result is cached (in its ModelData).",
              "related": [
                "Model:getTriangleCount",
                "Model:getVertexCount",
                "Model:getMesh",
                "ModelData:getTriangles",
                "Model"
              ],
              "summary": "Get all the triangles in the Model.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The triangle vertex positions, returned as a flat (non-nested) table of numbers.  The position of each vertex is given as an x, y, and z coordinate.",
                      "name": "vertices",
                      "type": "table"
                    },
                    {
                      "description": "A list of numbers representing how to connect the vertices into triangles.  Each number is a 1-based index into the `vertices` table, and every 3 indices form a triangle.",
                      "name": "indices",
                      "type": "table"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns a `Buffer` that holds the vertices of all of the meshes in the Model.",
              "key": "Model:getVertexBuffer",
              "module": "lovr.graphics",
              "name": "getVertexBuffer",
              "related": ["Model:getIndexBuffer", "Model:getMesh", "Model"],
              "summary": "Get a Buffer containing the vertices in the Model.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The vertex buffer.",
                      "name": "buffer",
                      "type": "Buffer"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the total vertex count of the Model.",
              "key": "Model:getVertexCount",
              "module": "lovr.graphics",
              "name": "getVertexCount",
              "notes": "This isn\u0027t always the same as the length of the vertex buffer, since a mesh in the Model could be drawn by multiple nodes.",
              "related": [
                "Model:getTriangles",
                "Model:getTriangleCount",
                "ModelData:getVertexCount",
                "Model"
              ],
              "summary": "Get the total vertex count of the Model.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The total number of vertices.",
                      "name": "count",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the width of the Model, computed from its axis-aligned bounding box.",
              "key": "Model:getWidth",
              "module": "lovr.graphics",
              "name": "getWidth",
              "related": [
                "Model:getHeight",
                "Model:getDepth",
                "Model:getDimensions",
                "Model:getCenter",
                "Model:getBoundingBox",
                "ModelData:getWidth",
                "Model"
              ],
              "summary": "Get the width of the Model.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The width of the Model.",
                      "name": "width",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns whether the Model has any skeletal animations.",
              "key": "Model:hasJoints",
              "module": "lovr.graphics",
              "name": "hasJoints",
              "notes": "This will return when there\u0027s at least one skin in the model, as returned by `ModelData:getSkinCount`.\n\nEven if this function returns true, the model could still have non-skeletal animations.\n\nRight now a model can only be drawn with one skeletal pose per frame.",
              "related": ["Model"],
              "summary": "Check if the Model uses joints for skeletal animation.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "Whether the animation uses joint nodes for skeletal animation.",
                      "name": "jointed",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Resets blend shape weights to the original ones defined in the model file.",
              "key": "Model:resetBlendShapes",
              "module": "lovr.graphics",
              "name": "resetBlendShapes",
              "related": [
                "Model:resetNodeTransforms",
                "Model:getBlendShapeWeight",
                "Model:setBlendShapeWeight",
                "Model"
              ],
              "summary": "Reset blend shape weights.",
              "variants": [{ "arguments": {}, "returns": {} }]
            },
            {
              "description": "Resets node transforms to the original ones defined in the model file.",
              "key": "Model:resetNodeTransforms",
              "module": "lovr.graphics",
              "name": "resetNodeTransforms",
              "related": ["Model:resetBlendShapes", "Model"],
              "summary": "Reset node transforms.",
              "variants": [{ "arguments": {}, "returns": {} }]
            },
            {
              "description": "Sets the weight of a blend shape.  A blend shape contains offset values for the vertices of one of the meshes in a Model.  Whenever the Model is drawn, the offsets are multiplied by the weight of the blend shape, allowing for smooth blending between different meshes.  A weight of zero won\u0027t apply any displacement and will skip processing of the blend shape.",
              "key": "Model:setBlendShapeWeight",
              "module": "lovr.graphics",
              "name": "setBlendShapeWeight",
              "notes": "The initial weights are declared in the model file.\n\nWeights can be any number, but usually they\u0027re kept between 0 and 1.\n\nThis function will throw an error if the blend shape name or index doesn\u0027t exist.",
              "related": [
                "Model:getBlendShapeCount",
                "Model:getBlendShapeName",
                "Model:resetBlendShapes",
                "Model:getBlendShapeWeight",
                "Model"
              ],
              "summary": "Set the weight of a blend shape.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of a blend shape.",
                      "name": "index",
                      "type": "number"
                    },
                    {
                      "description": "The new weight for the blend shape.",
                      "name": "weight",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The name of a blend shape.",
                      "name": "name",
                      "type": "string"
                    },
                    {
                      "description": "The new weight for the blend shape.",
                      "name": "weight",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets or blends the orientation of a node to a new orientation.  This sets the local orientation of the node, relative to its parent.",
              "key": "Model:setNodeOrientation",
              "module": "lovr.graphics",
              "name": "setNodeOrientation",
              "related": [
                "Model:getNodePosition",
                "Model:setNodePosition",
                "Model:getNodeScale",
                "Model:setNodeScale",
                "Model:getNodePose",
                "Model:setNodePose",
                "Model:getNodeTransform",
                "Model:setNodeTransform",
                "Model:animate",
                "Model:getNodeOrientation",
                "Model"
              ],
              "summary": "Set or blend the orientation of a node.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of the node.",
                      "name": "index",
                      "type": "number"
                    },
                    {
                      "description": "The number of radians the node should be rotated around its rotation axis.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    },
                    {
                      "default": "1.0",
                      "description": "A number from 0 to 1 indicating how much of the target orientation to blend in.  A value of 0 will not change the node\u0027s orientation at all, whereas 1 will fully blend to the target orientation.",
                      "name": "blend",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The name of the node.",
                      "name": "name",
                      "type": "string"
                    },
                    {
                      "description": "The number of radians the node should be rotated around its rotation axis.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    },
                    {
                      "default": "1.0",
                      "description": "A number from 0 to 1 indicating how much of the target orientation to blend in.  A value of 0 will not change the node\u0027s orientation at all, whereas 1 will fully blend to the target orientation.",
                      "name": "blend",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The index of the node.",
                      "name": "index",
                      "type": "number"
                    },
                    {
                      "description": "The orientation.",
                      "name": "orientation",
                      "type": "Quat"
                    },
                    {
                      "default": "1.0",
                      "description": "A number from 0 to 1 indicating how much of the target orientation to blend in.  A value of 0 will not change the node\u0027s orientation at all, whereas 1 will fully blend to the target orientation.",
                      "name": "blend",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The name of the node.",
                      "name": "name",
                      "type": "string"
                    },
                    {
                      "description": "The orientation.",
                      "name": "orientation",
                      "type": "Quat"
                    },
                    {
                      "default": "1.0",
                      "description": "A number from 0 to 1 indicating how much of the target orientation to blend in.  A value of 0 will not change the node\u0027s orientation at all, whereas 1 will fully blend to the target orientation.",
                      "name": "blend",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets or blends the pose (position and orientation) of a node to a new pose.  This sets the local pose of the node, relative to its parent.  The scale will remain unchanged.",
              "key": "Model:setNodePose",
              "module": "lovr.graphics",
              "name": "setNodePose",
              "related": [
                "Model:getNodePosition",
                "Model:setNodePosition",
                "Model:getNodeOrientation",
                "Model:setNodeOrientation",
                "Model:getNodeScale",
                "Model:setNodeScale",
                "Model:getNodeTransform",
                "Model:setNodeTransform",
                "Model:animate",
                "Model:getNodePose",
                "Model"
              ],
              "summary": "Set or blend the pose of a node.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of the node.",
                      "name": "index",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the position.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the position.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the position.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The number of radians the node should be rotated around its rotation axis.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    },
                    {
                      "default": "1.0",
                      "description": "A number from 0 to 1 indicating how much of the target pose to blend in.  A value of 0 will not change the node\u0027s pose at all, whereas 1 will fully blend to the target pose.",
                      "name": "blend",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The name of the node.",
                      "name": "name",
                      "type": "string"
                    },
                    {
                      "description": "The x component of the position.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the position.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the position.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The number of radians the node should be rotated around its rotation axis.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    },
                    {
                      "default": "1.0",
                      "description": "A number from 0 to 1 indicating how much of the target pose to blend in.  A value of 0 will not change the node\u0027s pose at all, whereas 1 will fully blend to the target pose.",
                      "name": "blend",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The index of the node.",
                      "name": "index",
                      "type": "number"
                    },
                    {
                      "description": "The target position.  Can also be provided as 3 numbers.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "description": "The target orientation.  Can also be provided as 4 numbers in angle-axis form.",
                      "name": "orientation",
                      "type": "Quat"
                    },
                    {
                      "default": "1.0",
                      "description": "A number from 0 to 1 indicating how much of the target pose to blend in.  A value of 0 will not change the node\u0027s pose at all, whereas 1 will fully blend to the target pose.",
                      "name": "blend",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The name of the node.",
                      "name": "name",
                      "type": "string"
                    },
                    {
                      "description": "The target position.  Can also be provided as 3 numbers.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "description": "The target orientation.  Can also be provided as 4 numbers in angle-axis form.",
                      "name": "orientation",
                      "type": "Quat"
                    },
                    {
                      "default": "1.0",
                      "description": "A number from 0 to 1 indicating how much of the target pose to blend in.  A value of 0 will not change the node\u0027s pose at all, whereas 1 will fully blend to the target pose.",
                      "name": "blend",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets or blends the position of a node.  This sets the local position of the node, relative to its parent.",
              "key": "Model:setNodePosition",
              "module": "lovr.graphics",
              "name": "setNodePosition",
              "related": [
                "Model:getNodeOrientation",
                "Model:setNodeOrientation",
                "Model:getNodeScale",
                "Model:setNodeScale",
                "Model:getNodePose",
                "Model:setNodePose",
                "Model:getNodeTransform",
                "Model:setNodeTransform",
                "Model:animate",
                "Model:getNodePosition",
                "Model"
              ],
              "summary": "Set or blend the position of a node.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of the node.",
                      "name": "index",
                      "type": "number"
                    },
                    {
                      "description": "The x coordinate of the new position.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate of the new position.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z coordinate of the new position.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "default": "1.0",
                      "description": "A number from 0 to 1 indicating how much of the new position to blend in.  A value of 0 will not change the node\u0027s position at all, whereas 1 will fully blend to the target position.",
                      "name": "blend",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The name of the node.",
                      "name": "name",
                      "type": "string"
                    },
                    {
                      "description": "The x coordinate of the new position.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate of the new position.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z coordinate of the new position.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "default": "1.0",
                      "description": "A number from 0 to 1 indicating how much of the new position to blend in.  A value of 0 will not change the node\u0027s position at all, whereas 1 will fully blend to the target position.",
                      "name": "blend",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The index of the node.",
                      "name": "index",
                      "type": "number"
                    },
                    {
                      "description": "The new position.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "default": "1.0",
                      "description": "A number from 0 to 1 indicating how much of the new position to blend in.  A value of 0 will not change the node\u0027s position at all, whereas 1 will fully blend to the target position.",
                      "name": "blend",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The name of the node.",
                      "name": "name",
                      "type": "string"
                    },
                    {
                      "description": "The new position.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "default": "1.0",
                      "description": "A number from 0 to 1 indicating how much of the new position to blend in.  A value of 0 will not change the node\u0027s position at all, whereas 1 will fully blend to the target position.",
                      "name": "blend",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets or blends the scale of a node to a new scale.  This sets the local scale of the node, relative to its parent.",
              "key": "Model:setNodeScale",
              "module": "lovr.graphics",
              "name": "setNodeScale",
              "notes": "For best results when animating, it\u0027s recommended to keep the 3 scale components the same.",
              "related": [
                "Model:getNodePosition",
                "Model:setNodePosition",
                "Model:getNodeOrientation",
                "Model:setNodeOrientation",
                "Model:getNodePose",
                "Model:setNodePose",
                "Model:getNodeTransform",
                "Model:setNodeTransform",
                "Model:animate",
                "Model:getNodeScale",
                "Model"
              ],
              "summary": "Set or blend the scale of a node.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of the node.",
                      "name": "index",
                      "type": "number"
                    },
                    {
                      "description": "The x scale.",
                      "name": "sx",
                      "type": "number"
                    },
                    {
                      "description": "The y scale.",
                      "name": "sy",
                      "type": "number"
                    },
                    {
                      "description": "The z scale.",
                      "name": "sz",
                      "type": "number"
                    },
                    {
                      "default": "1.0",
                      "description": "A number from 0 to 1 indicating how much of the new scale to blend in.  A value of 0 will not change the node\u0027s scale at all, whereas 1 will fully blend to the target scale.",
                      "name": "blend",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The name of the node.",
                      "name": "name",
                      "type": "string"
                    },
                    {
                      "description": "The x scale.",
                      "name": "sx",
                      "type": "number"
                    },
                    {
                      "description": "The y scale.",
                      "name": "sy",
                      "type": "number"
                    },
                    {
                      "description": "The z scale.",
                      "name": "sz",
                      "type": "number"
                    },
                    {
                      "default": "1.0",
                      "description": "A number from 0 to 1 indicating how much of the new scale to blend in.  A value of 0 will not change the node\u0027s scale at all, whereas 1 will fully blend to the target scale.",
                      "name": "blend",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The index of the node.",
                      "name": "index",
                      "type": "number"
                    },
                    {
                      "description": "The new scale.",
                      "name": "scale",
                      "type": "Vec3"
                    },
                    {
                      "default": "1.0",
                      "description": "A number from 0 to 1 indicating how much of the new scale to blend in.  A value of 0 will not change the node\u0027s scale at all, whereas 1 will fully blend to the target scale.",
                      "name": "blend",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The name of the node.",
                      "name": "name",
                      "type": "string"
                    },
                    {
                      "description": "The new scale.",
                      "name": "scale",
                      "type": "Vec3"
                    },
                    {
                      "default": "1.0",
                      "description": "A number from 0 to 1 indicating how much of the new scale to blend in.  A value of 0 will not change the node\u0027s scale at all, whereas 1 will fully blend to the target scale.",
                      "name": "blend",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets or blends the transform of a node to a new transform.  This sets the local transform of the node, relative to its parent.",
              "key": "Model:setNodeTransform",
              "module": "lovr.graphics",
              "name": "setNodeTransform",
              "notes": "For best results when animating, it\u0027s recommended to keep the 3 components of the scale the same.\n\nEven though the translation, scale, and rotation parameters are given in TSR order, they are applied in the normal TRS order.",
              "related": [
                "Model:getNodePosition",
                "Model:setNodePosition",
                "Model:getNodeOrientation",
                "Model:setNodeOrientation",
                "Model:getNodeScale",
                "Model:setNodeScale",
                "Model:getNodePose",
                "Model:setNodePose",
                "Model:animate",
                "Model:getNodeTransform",
                "Model"
              ],
              "summary": "Set or blend the transform of a node.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of the node.",
                      "name": "index",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the position.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the position.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the position.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the scale.",
                      "name": "sx",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the scale.",
                      "name": "sy",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the scale.",
                      "name": "sz",
                      "type": "number"
                    },
                    {
                      "description": "The number of radians the node should be rotated around its rotation axis.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    },
                    {
                      "default": "1.0",
                      "description": "A number from 0 to 1 indicating how much of the target transform to blend in.  A value of 0 will not change the node\u0027s transform at all, whereas 1 will fully blend to the target transform.",
                      "name": "blend",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The name of the node.",
                      "name": "name",
                      "type": "string"
                    },
                    {
                      "description": "The x component of the position.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the position.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the position.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the scale.",
                      "name": "sx",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the scale.",
                      "name": "sy",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the scale.",
                      "name": "sz",
                      "type": "number"
                    },
                    {
                      "description": "The number of radians the node should be rotated around its rotation axis.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    },
                    {
                      "default": "1.0",
                      "description": "A number from 0 to 1 indicating how much of the target transform to blend in.  A value of 0 will not change the node\u0027s transform at all, whereas 1 will fully blend to the target transform.",
                      "name": "blend",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The index of the node.",
                      "name": "index",
                      "type": "number"
                    },
                    {
                      "description": "The position.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "description": "The scale.",
                      "name": "scale",
                      "type": "Vec3"
                    },
                    {
                      "description": "The orientation.",
                      "name": "orientation",
                      "type": "Quat"
                    },
                    {
                      "default": "1.0",
                      "description": "A number from 0 to 1 indicating how much of the target transform to blend in.  A value of 0 will not change the node\u0027s transform at all, whereas 1 will fully blend to the target transform.",
                      "name": "blend",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The name of the node.",
                      "name": "name",
                      "type": "string"
                    },
                    {
                      "description": "The position.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "description": "The scale.",
                      "name": "scale",
                      "type": "Vec3"
                    },
                    {
                      "description": "The orientation.",
                      "name": "orientation",
                      "type": "Quat"
                    },
                    {
                      "default": "1.0",
                      "description": "A number from 0 to 1 indicating how much of the target transform to blend in.  A value of 0 will not change the node\u0027s transform at all, whereas 1 will fully blend to the target transform.",
                      "name": "blend",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The index of the node.",
                      "name": "index",
                      "type": "number"
                    },
                    {
                      "description": "The transform.",
                      "name": "transform",
                      "type": "Mat4"
                    },
                    {
                      "default": "1.0",
                      "description": "A number from 0 to 1 indicating how much of the target transform to blend in.  A value of 0 will not change the node\u0027s transform at all, whereas 1 will fully blend to the target transform.",
                      "name": "blend",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The name of the node.",
                      "name": "name",
                      "type": "string"
                    },
                    {
                      "description": "The transform.",
                      "name": "transform",
                      "type": "Mat4"
                    },
                    {
                      "default": "1.0",
                      "description": "A number from 0 to 1 indicating how much of the target transform to blend in.  A value of 0 will not change the node\u0027s transform at all, whereas 1 will fully blend to the target transform.",
                      "name": "blend",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            }
          ],
          "module": "lovr.graphics",
          "name": "Model",
          "related": ["lovr.graphics"],
          "summary": "A 3D model."
        },
        {
          "constructors": [
            "lovr.graphics.newPass",
            "lovr.graphics.getWindowPass",
            "lovr.headset.getPass"
          ],
          "description": "Pass objects record work for the GPU.  They contain a list of things to draw and a list of compute shaders to run.\n\nMethods like `Pass:sphere` will \"record\" a draw on the Pass, which adds it to the list.  Other methods like `Pass:setBlendMode` or `Pass:setShader` will change the way the next draws are processed.\n\nOnce all of the work has been recorded to a Pass, it can be sent to the GPU using `lovr.graphics.submit`, which will start processing all of the compute work and draws (in that order).\n\nA Pass can have a canvas, which is a set of textures that the draws will render to.\n\n`Pass:reset` is used to clear all of the computes and draws, putting the Pass in a fresh state.\n\n`lovr.draw` is called every frame with a `Pass` that is configured to render to either the headset or the window.  The Pass will automatically get submitted afterwards.",
          "key": "Pass",
          "methods": [
            {
              "description": "Synchronizes compute work.\n\nBy default, within a single Pass, multiple calls to `Pass:compute` can run on the GPU in any order, or all at the same time.  This is great because it lets the GPU process the work as efficiently as possible, but sometimes multiple compute dispatches need to be sequenced.\n\nCalling this function will insert a barrier.  All compute operations on the Pass after the barrier will only start once all of the previous compute operations on the Pass are finished.",
              "examples": [
                {
                  "code": "pass \u003d lovr.graphics.newPass()\npass:setShader(computeShader)\n\npass:compute(x, y, z)\npass:compute(x, y, z)\npass:barrier()\npass:compute(x, y, z) --\u003e waits for the previous 2 :computes to complete"
                }
              ],
              "key": "Pass:barrier",
              "module": "lovr.graphics",
              "name": "barrier",
              "notes": "It\u0027s only necessary to use a barrier if a compute shader is reading\/writing the same bytes of memory that a previous compute operation in the same Pass read\/wrote.\n\nBarriers will slow things down because they reduce parallelism by causing the GPU to wait. Strategic reordering of non-dependent :compute calls around the barrier can help.\n\nCalling this function before recording any :computes will do nothing, and calling it after the last :compute will do nothing.",
              "related": ["Pass:compute", "Pass"],
              "summary": "Synchronize compute work.",
              "tag": "compute",
              "variants": [{ "arguments": {}, "returns": {} }]
            },
            {
              "description": "Begins a new tally.  The tally will count the number of pixels touched by any draws that occur while the tally is active.  If a pixel fails the depth test or stencil test then it won\u0027t be counted, so the tally is a way to detect if objects are visible.\n\nThe results for all the tallies in the pass can be copied to a `Buffer` when the Pass finishes by setting a buffer with `Pass:setTallyBuffer`.",
              "key": "Pass:beginTally",
              "module": "lovr.graphics",
              "name": "beginTally",
              "notes": "There is currently a maximum of 256 tallies per pass.\n\nIf a tally is already active, this function will error.",
              "related": ["Pass:finishTally", "Pass"],
              "summary": "Begin a tally.",
              "tag": "tally",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The index of the tally that was started.",
                      "name": "index",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Draw a box.  This is like `Pass:cube`, except it takes 3 separate values for the scale.",
              "key": "Pass:box",
              "module": "lovr.graphics",
              "name": "box",
              "related": ["Pass:cube", "Pass"],
              "summary": "Draw a box.",
              "tag": "drawing",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "0",
                      "description": "The x coordinate of the center of the box.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The y coordinate of the center of the box.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z coordinate of the center of the box.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The width of the box.",
                      "name": "width",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The height of the box.",
                      "name": "height",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The depth of the box.",
                      "name": "depth",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The rotation of the box around its rotation axis, in radians.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    },
                    {
                      "default": "\u0027fill\u0027",
                      "description": "Whether the box should be drawn filled or outlined.",
                      "name": "style",
                      "type": "DrawStyle"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The position of the box.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "description": "The size of the box.",
                      "name": "size",
                      "type": "Vec3"
                    },
                    {
                      "description": "The orientation of the box.",
                      "name": "orientation",
                      "type": "Quat"
                    },
                    {
                      "default": "\u0027fill\u0027",
                      "description": "Whether the box should be drawn filled or outlined.",
                      "name": "style",
                      "type": "DrawStyle"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The transform of the box.",
                      "name": "transform",
                      "type": "Mat4"
                    },
                    {
                      "default": "\u0027fill\u0027",
                      "description": "Whether the box should be drawn filled or outlined.",
                      "name": "style",
                      "type": "DrawStyle"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Draws a capsule.  A capsule is shaped like a cylinder with a hemisphere on each end.",
              "key": "Pass:capsule",
              "module": "lovr.graphics",
              "name": "capsule",
              "notes": "The length of the capsule does not include the end caps.  The local origin of the capsule is in the center, and the local z axis points towards the end caps.",
              "related": ["Pass"],
              "summary": "Draw a capsule.",
              "tag": "drawing",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "0",
                      "description": "The x coordinate of the center of the capsule.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The y coordinate of the center of the capsule.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z coordinate of the center of the capsule.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "default": "1.0",
                      "description": "The radius of the capsule.",
                      "name": "radius",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The length of the capsule.",
                      "name": "length",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The rotation of the capsule around its rotation axis, in radians.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    },
                    {
                      "default": "32",
                      "description": "The number of circular segments to render.",
                      "name": "segments",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The position of the center of the capsule.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "default": "1.0",
                      "description": "The radius of the capsule.",
                      "name": "radius",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The length of the capsule.",
                      "name": "length",
                      "type": "number"
                    },
                    {
                      "description": "The orientation of the capsule.",
                      "name": "orientation",
                      "type": "Quat"
                    },
                    {
                      "default": "32",
                      "description": "The number of circular segments to render.",
                      "name": "segments",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The transform of the capsule.",
                      "name": "transform",
                      "type": "Mat4"
                    },
                    {
                      "default": "32",
                      "description": "The number of circular segments to render.",
                      "name": "segments",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The starting point of the capsule.",
                      "name": "p1",
                      "type": "Vec3"
                    },
                    {
                      "description": "The ending point of the capsule.",
                      "name": "p2",
                      "type": "Vec3"
                    },
                    {
                      "default": "1.0",
                      "description": "The radius of the capsule.",
                      "name": "radius",
                      "type": "number"
                    },
                    {
                      "default": "32",
                      "description": "The number of circular segments to render.",
                      "name": "segments",
                      "type": "number"
                    }
                  ],
                  "description": "Draws a capsule between two points.",
                  "returns": {}
                }
              ]
            },
            {
              "description": "Draws a circle.",
              "key": "Pass:circle",
              "module": "lovr.graphics",
              "name": "circle",
              "notes": "The local origin of the circle is in its center.  The local z axis is perpendicular to the circle.",
              "related": ["Pass"],
              "summary": "Draw a circle.",
              "tag": "drawing",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "0",
                      "description": "The x coordinate of the center of the circle.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The y coordinate of the center of the circle.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z coordinate of the center of the circle.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The radius of the circle.",
                      "name": "radius",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The rotation of the circle around its rotation axis, in radians.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    },
                    {
                      "default": "\u0027fill\u0027",
                      "description": "Whether the circle should be filled or outlined.",
                      "name": "style",
                      "type": "DrawStyle"
                    },
                    {
                      "default": "0",
                      "description": "The angle of the beginning of the arc.",
                      "name": "angle1",
                      "type": "number"
                    },
                    {
                      "default": "2 * math.pi",
                      "description": "angle of the end of the arc.",
                      "name": "angle2",
                      "type": "number"
                    },
                    {
                      "default": "64",
                      "description": "The number of segments to render.",
                      "name": "segments",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The position of the circle.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "default": "1",
                      "description": "The radius of the circle.",
                      "name": "radius",
                      "type": "number"
                    },
                    {
                      "description": "The orientation of the circle.",
                      "name": "orientation",
                      "type": "Quat"
                    },
                    {
                      "default": "\u0027fill\u0027",
                      "description": "Whether the circle should be filled or outlined.",
                      "name": "style",
                      "type": "DrawStyle"
                    },
                    {
                      "default": "0",
                      "description": "The angle of the beginning of the arc.",
                      "name": "angle1",
                      "type": "number"
                    },
                    {
                      "default": "2 * math.pi",
                      "description": "angle of the end of the arc.",
                      "name": "angle2",
                      "type": "number"
                    },
                    {
                      "default": "64",
                      "description": "The number of segments to render.",
                      "name": "segments",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The transform of the circle.",
                      "name": "transform",
                      "type": "Mat4"
                    },
                    {
                      "default": "\u0027fill\u0027",
                      "description": "Whether the circle should be filled or outlined.",
                      "name": "style",
                      "type": "DrawStyle"
                    },
                    {
                      "default": "0",
                      "description": "The angle of the beginning of the arc.",
                      "name": "angle1",
                      "type": "number"
                    },
                    {
                      "default": "2 * math.pi",
                      "description": "angle of the end of the arc.",
                      "name": "angle2",
                      "type": "number"
                    },
                    {
                      "default": "64",
                      "description": "The number of segments to render.",
                      "name": "segments",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Runs a compute shader.  There must be an active compute shader set using `Pass:setShader`.\n\nAll of the compute shader dispatches in a Pass will run **before** all of the draws in the Pass (if any).  They will also run at the same time in parallel, unless `Pass:barrier` is used to control the order.",
              "examples": [
                {
                  "code": "function lovr.load()\n  shader \u003d lovr.graphics.newShader([[\n    layout(local_size_x \u003d 8, local_size_y \u003d 8) in;\n    layout(rgba8) uniform image2D image;\n\n    void lovrmain() {\n      ivec2 size \u003d imageSize(image);\n      ivec2 pixel \u003d ivec2(GlobalThreadID.xy);\n\n      if (pixel.x \u003e\u003d size.x || pixel.y \u003e\u003d size.y) {\n        return;\n      }\n\n      vec4 color \u003d imageLoad(image, pixel);\n      color.rgb \u003d vec3(color.r * .2126 + color.g * .7512 + color.b * .0722);\n      imageStore(image, pixel, color);\n    }\n  ]])\n\n  texture \u003d lovr.graphics.newTexture(\u0027image.png\u0027, {\n    usage \u003d { \u0027storage\u0027, \u0027sample\u0027, \u0027transfer\u0027 },\n    linear \u003d true -- srgb textures don\u0027t always support storage usage\n  })\n\n  local tw, th \u003d texture:getDimensions()\n  local sx, sy \u003d shader:getWorkgroupSize()\n  local gx, gy \u003d math.ceil(tw \/ sx), math.ceil(th \/ sy)\n\n  local computer \u003d lovr.graphics.newPass()\n\n  computer:setShader(shader)\n  computer:send(\u0027image\u0027, texture)\n  computer:compute(gx, gy)\n  lovr.graphics.submit(computer)\n\n  texture:generateMipmaps()\nend\n\nfunction lovr.draw(pass)\n  pass:draw(texture, 0, 1.7, -1)\nend",
                  "description": "A compute shader that makes a texture grayscale."
                }
              ],
              "key": "Pass:compute",
              "module": "lovr.graphics",
              "name": "compute",
              "notes": "Compute shaders are usually run once for each pixel in an image, once per particle, once per object, etc.  The 3 arguments represent how many times to run, or \"dispatch\", the compute shader, in up to 3 dimensions.  Each element of this grid is called a **workgroup**.\n\nTo make things even more complicated, each workgroup itself is made up of a set of \"mini GPU threads\", which are called **local workgroups**.  Like workgroups, the local workgroup size can also be 3D.  It\u0027s declared in the shader code, like this:\n\n    layout(local_size_x \u003d w, local_size_y \u003d h, local_size_z \u003d d) in;\n\nAll these 3D grids can get confusing, but the basic idea is to make the local workgroup size a small block of e.g. 32 particles or 8x8 pixels or 4x4x4 voxels, and then dispatch however many workgroups are needed to cover a list of particles, image, voxel field, etc.\n\nThe reason to do it this way is that the GPU runs its threads in little fixed-size bundles called subgroups.  Subgroups are usually 32 or 64 threads (the exact size is given by the `subgroupSize` property of `lovr.graphics.getDevice`) and all run together.  If the local workgroup size was `1x1x1`, then the GPU would only run 1 thread per subgroup and waste the other 31 or 63.  So for the best performance, be sure to set a local workgroup size bigger than 1!\n\nInside the compute shader, a few builtin variables can be used to figure out which workgroup is running:\n\n- `uvec3 WorkgroupCount` is the workgroup count per axis (the `Pass:compute` arguments).\n- `uvec3 WorkgroupSize` is the local workgroup size (declared in the shader).\n- `uvec3 WorkgroupID` is the index of the current (global) workgroup.\n- `uvec3 LocalThreadID` is the index of the local workgroup inside its workgroup.\n- `uint LocalThreadIndex` is a 1D version of `LocalThreadID`.\n- `uvec3 GlobalThreadID` is the unique identifier for a thread within all workgroups in a\n  dispatch. It\u0027s equivalent to `WorkgroupID * WorkgroupSize + LocalThreadID` (usually what you\n  want!)\n\nThere are limits to the number of workgroups that can be dispatched, see the `workgroupCount` limit in `lovr.graphics.getLimits`.  The local workgroup size is also limited by the `workgroupSize` and `totalWorkgroupSize` limits.\n\nIndirect compute dispatches are useful to \"chain\" compute shaders together, while keeping all of the data on the GPU.  The first dispatch can do some computation and write some results to buffers, then the second indirect dispatch can use the data in those buffers to know how many times it should run.  An example would be a compute shader that does some sort of object culling, writing the number of visible objects to a buffer along with the IDs of each one. Subsequent compute shaders can be indirectly dispatched to perform extra processing on the visible objects.  Finally, an indirect draw can be used to render them.",
              "related": [
                "Pass:barrier",
                "Pass:setShader",
                "Pass:send",
                "lovr.graphics.getLimits",
                "Pass"
              ],
              "summary": "Run a compute shader.",
              "tag": "compute",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "1",
                      "description": "The number of workgroups to dispatch in the x dimension.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The number of workgroups to dispatch in the y dimension.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The number of workgroups to dispatch in the z dimension.",
                      "name": "z",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "A Buffer object containing the x, y, and z workgroup counts, stored as 4 byte unsigned integers.",
                      "name": "buffer",
                      "type": "Buffer"
                    },
                    {
                      "default": "0",
                      "description": "The byte offset to read the workgroup counts from in the Buffer.",
                      "name": "offset",
                      "type": "number"
                    }
                  ],
                  "description": "Perform an \"indirect\" dispatch.  Instead of passing in the workgroup counts directly from Lua, the workgroup counts are read from a `Buffer` object at a particular byte offset. Each count should be a 4-byte integer, so in total 12 bytes will be read from the buffer.",
                  "returns": {}
                }
              ]
            },
            {
              "description": "Draws a cone.",
              "key": "Pass:cone",
              "module": "lovr.graphics",
              "name": "cone",
              "notes": "The local origin is at the center of the base of the cone, and the negative z axis points towards the tip.",
              "related": ["Pass"],
              "summary": "Draw a cone.",
              "tag": "drawing",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "0",
                      "description": "The x coordinate of the center of the base of the cone.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The y coordinate of the center of the base of the cone.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z coordinate of the center of the base of the cone.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The radius of the cone.",
                      "name": "radius",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The length of the cone.",
                      "name": "length",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The rotation of the cone around its rotation axis, in radians.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    },
                    {
                      "default": "64",
                      "description": "The number of segments in the cone.",
                      "name": "segments",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The position of the center of the base of the cone.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "default": "1",
                      "description": "The radius of the cone.",
                      "name": "radius",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The length of the cone.",
                      "name": "length",
                      "type": "number"
                    },
                    {
                      "description": "The orientation of the cone.",
                      "name": "orientation",
                      "type": "Quat"
                    },
                    {
                      "default": "64",
                      "description": "The number of segments in the cone.",
                      "name": "segments",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The transform of the cone.",
                      "name": "transform",
                      "type": "Mat4"
                    },
                    {
                      "default": "64",
                      "description": "The number of segments in the cone.",
                      "name": "segments",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The position of the base of the cone.",
                      "name": "p1",
                      "type": "Vec3"
                    },
                    {
                      "description": "The position of the tip of the cone.",
                      "name": "p2",
                      "type": "Vec3"
                    },
                    {
                      "default": "1",
                      "description": "The radius of the cone.",
                      "name": "radius",
                      "type": "number"
                    },
                    {
                      "default": "64",
                      "description": "The number of segments in the cone.",
                      "name": "segments",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Draws a cube.",
              "key": "Pass:cube",
              "module": "lovr.graphics",
              "name": "cube",
              "notes": "The local origin is in the center of the cube.",
              "related": ["Pass"],
              "summary": "Draw a cube.",
              "tag": "drawing",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "0",
                      "description": "The x coordinate of the center of the cube.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The y coordinate of the center of the cube.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z coordinate of the center of the cube.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The size of the cube.",
                      "name": "size",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The rotation of the cube around its rotation axis, in radians.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    },
                    {
                      "default": "\u0027fill\u0027",
                      "description": "Whether the cube should be drawn filled or outlined.",
                      "name": "style",
                      "type": "DrawStyle"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The position of the cube.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "default": "1",
                      "description": "The size of the cube.",
                      "name": "size",
                      "type": "number"
                    },
                    {
                      "description": "The orientation of the cube.",
                      "name": "orientation",
                      "type": "Quat"
                    },
                    {
                      "default": "\u0027fill\u0027",
                      "description": "Whether the cube should be drawn filled or outlined.",
                      "name": "style",
                      "type": "DrawStyle"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The transform of the cube.",
                      "name": "transform",
                      "type": "Mat4"
                    },
                    {
                      "default": "\u0027fill\u0027",
                      "description": "Whether the cube should be drawn filled or outlined.",
                      "name": "style",
                      "type": "DrawStyle"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Draws a cylinder.",
              "key": "Pass:cylinder",
              "module": "lovr.graphics",
              "name": "cylinder",
              "notes": "The local origin is in the center of the cylinder, and the length of the cylinder is along the z axis.",
              "related": ["Pass"],
              "summary": "Draw a cylinder.",
              "tag": "drawing",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "0",
                      "description": "The x coordinate of the center of the cylinder.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The y coordinate of the center of the cylinder.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z coordinate of the center of the cylinder.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The radius of the cylinder.",
                      "name": "radius",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The length of the cylinder.",
                      "name": "length",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The rotation of the cylinder around its rotation axis, in radians.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    },
                    {
                      "default": "true",
                      "description": "Whether the tops and bottoms of the cylinder should be rendered.",
                      "name": "capped",
                      "type": "boolean"
                    },
                    {
                      "default": "0",
                      "description": "The angle of the beginning of the arc.",
                      "name": "angle1",
                      "type": "number"
                    },
                    {
                      "default": "2 * math.pi",
                      "description": "angle of the end of the arc.",
                      "name": "angle2",
                      "type": "number"
                    },
                    {
                      "default": "64",
                      "description": "The number of circular segments to render.",
                      "name": "segments",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The position of the center of the cylinder.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "default": "1",
                      "description": "The radius of the cylinder.",
                      "name": "radius",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The length of the cylinder.",
                      "name": "length",
                      "type": "number"
                    },
                    {
                      "description": "The orientation of the cylinder.",
                      "name": "orientation",
                      "type": "Quat"
                    },
                    {
                      "default": "true",
                      "description": "Whether the tops and bottoms of the cylinder should be rendered.",
                      "name": "capped",
                      "type": "boolean"
                    },
                    {
                      "default": "0",
                      "description": "The angle of the beginning of the arc.",
                      "name": "angle1",
                      "type": "number"
                    },
                    {
                      "default": "2 * math.pi",
                      "description": "angle of the end of the arc.",
                      "name": "angle2",
                      "type": "number"
                    },
                    {
                      "default": "64",
                      "description": "The number of circular segments to render.",
                      "name": "segments",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The transform of the cylinder.",
                      "name": "transform",
                      "type": "Mat4"
                    },
                    {
                      "default": "true",
                      "description": "Whether the tops and bottoms of the cylinder should be rendered.",
                      "name": "capped",
                      "type": "boolean"
                    },
                    {
                      "default": "0",
                      "description": "The angle of the beginning of the arc.",
                      "name": "angle1",
                      "type": "number"
                    },
                    {
                      "default": "2 * math.pi",
                      "description": "angle of the end of the arc.",
                      "name": "angle2",
                      "type": "number"
                    },
                    {
                      "default": "64",
                      "description": "The number of circular segments to render.",
                      "name": "segments",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The starting point of the cylinder.",
                      "name": "p1",
                      "type": "Vec3"
                    },
                    {
                      "description": "The ending point of the cylinder.",
                      "name": "p2",
                      "type": "Vec3"
                    },
                    {
                      "default": "1",
                      "description": "The radius of the cylinder.",
                      "name": "radius",
                      "type": "number"
                    },
                    {
                      "default": "true",
                      "description": "Whether the tops and bottoms of the cylinder should be rendered.",
                      "name": "capped",
                      "type": "boolean"
                    },
                    {
                      "default": "0",
                      "description": "The angle of the beginning of the arc.",
                      "name": "angle1",
                      "type": "number"
                    },
                    {
                      "default": "2 * math.pi",
                      "description": "angle of the end of the arc.",
                      "name": "angle2",
                      "type": "number"
                    },
                    {
                      "default": "64",
                      "description": "The number of circular segments to render.",
                      "name": "segments",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Draws a `Model`, `Mesh`, or `Texture`.",
              "key": "Pass:draw",
              "module": "lovr.graphics",
              "name": "draw",
              "notes": "`Model:getMesh` can be used to draw individual meshes of a model.\n\nTextures ignore the `instances` parameter.\n\nWhen drawing a Texture, the plane will be 1 meter wide at 1.0 scale and the height will be adjusted based on the Texture\u0027s aspect ratio.",
              "related": ["Pass"],
              "summary": "Draw a Model, Mesh, or Texture.",
              "tag": "drawing",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The Model, Mesh, or Texture to draw.",
                      "name": "object",
                      "type": "*"
                    },
                    {
                      "default": "0",
                      "description": "The x coordinate to draw the object at.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The y coordinate to draw the object at.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z coordinate to draw the object at.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The scale of the object.",
                      "name": "scale",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The rotation of the object around its rotation axis, in radians.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The number of instances to draw.",
                      "name": "instances",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The Model, Mesh, or Texture to draw.",
                      "name": "object",
                      "type": "*"
                    },
                    {
                      "description": "The position to draw the object at.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "description": "The scale of the object, as a vector.",
                      "name": "scale3",
                      "type": "Vec3"
                    },
                    {
                      "description": "The orientation of the object.",
                      "name": "orientation",
                      "type": "Quat"
                    },
                    {
                      "default": "1",
                      "description": "The number of instances to draw.",
                      "name": "instances",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The Model, Mesh, or Texture to draw.",
                      "name": "object",
                      "type": "*"
                    },
                    {
                      "description": "The transform of the object.",
                      "name": "transform",
                      "type": "Mat4"
                    },
                    {
                      "default": "1",
                      "description": "The number of instances to draw.",
                      "name": "instances",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Draws a fullscreen triangle.  The `fill` shader is used, which stretches the triangle across the screen.",
              "key": "Pass:fill",
              "module": "lovr.graphics",
              "name": "fill",
              "notes": "This function has some special behavior for array textures:\n\n- Filling a single-layer texture to a multi-layer canvas will mirror the texture to all layers,\n  just like regular drawing.\n- Filling a 2-layer texture to a mono canvas will render the 2 layers side-by-side.\n- Filling a multi-layer texture to a multi-layer canvas will do a layer-by-layer fill (the layer\n  counts must match).",
              "related": ["Pass"],
              "summary": "Draw a fullscreen triangle.",
              "tag": "drawing",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The texture to fill.  If nil, the texture from the active material is used.",
                      "name": "texture",
                      "type": "Texture"
                    }
                  ],
                  "returns": {}
                },
                { "arguments": {}, "returns": {} }
              ]
            },
            {
              "description": "Finishes a tally that was previously started with `Pass:beginTally`.  This will stop counting the number of pixels affected by draws.\n\nThe results for all the tallies in the pass can be copied to a `Buffer` when the Pass finishes by setting a buffer with `Pass:setTallyBuffer`.",
              "key": "Pass:finishTally",
              "module": "lovr.graphics",
              "name": "finishTally",
              "notes": "There is currently a maximum of 256 tallies per pass.\n\nIf no tally is active, this function will error.",
              "related": ["Pass:beginTally", "Pass"],
              "summary": "Finish a tally.",
              "tag": "tally",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The index of the tally that was finished.",
                      "name": "index",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the Pass\u0027s canvas, or `nil` if the Pass doesn\u0027t have a canvas.  The canvas is a set of textures that the Pass will draw to when it\u0027s submitted.",
              "key": "Pass:getCanvas",
              "module": "lovr.graphics",
              "name": "getCanvas",
              "notes": "If the Pass has multiple color textures, a fragment shader should be used to write a different color to each texture.  Here\u0027s an example that writes red to the first texture and blue to the second texture:\n\n    \/\/ Declare an output variable for the second texture\n    layout(location \u003d 1) out vec4 secondColor;\n\n    vec4 lovrmain() {\n      secondColor \u003d vec4(0, 0, 1, 1);\n      return vec4(1, 0, 0, 1);\n    }",
              "related": [
                "Pass:getClear",
                "Pass:setClear",
                "Pass:getWidth",
                "Pass:getHeight",
                "Pass:getDimensions",
                "Pass:setCanvas",
                "Pass"
              ],
              "summary": "Get the Pass\u0027s canvas.",
              "tag": "canvas",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The canvas.  Numeric keys will contain the color Textures, along with the following keys:",
                      "name": "canvas",
                      "table": [
                        {
                          "description": "A `Texture` or `TextureFormat` with the depth buffer.",
                          "name": "depth",
                          "type": "*"
                        },
                        {
                          "description": "The number of multisamples used for antialiasing (either 1 or 4).",
                          "name": "samples",
                          "type": "number"
                        }
                      ],
                      "type": "table"
                    }
                  ]
                },
                {
                  "arguments": {},
                  "description": "This function returns nil when a canvas hasn\u0027t been set.",
                  "returns": {}
                }
              ]
            },
            {
              "description": "Returns the clear values of the pass.",
              "key": "Pass:getClear",
              "module": "lovr.graphics",
              "name": "getClear",
              "notes": "The default clear color is transparent black.",
              "related": ["Pass:getCanvas", "Pass:setClear", "Pass"],
              "summary": "Return the clear values of the Pass.",
              "tag": "canvas",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The clear values for the pass.  Each color texture\u0027s clear value is stored at its index, as either a 4-number rgba table or a boolean.  If the pass has a depth texture, there will also be a `depth` key with its clear value as a number or boolean.",
                      "name": "clears",
                      "type": "table"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the dimensions of the textures of the Pass\u0027s canvas, in pixels.",
              "key": "Pass:getDimensions",
              "module": "lovr.graphics",
              "name": "getDimensions",
              "notes": "If the pass doesn\u0027t have a canvas, this function returns zeros.",
              "related": [
                "Pass:getWidth",
                "Pass:getHeight",
                "Pass:getViewCount",
                "Pass:getCanvas",
                "Pass:setCanvas",
                "lovr.system.getWindowDimensions",
                "lovr.headset.getDisplayDimensions",
                "Pass"
              ],
              "summary": "Get the dimensions of the Pass\u0027s canvas.",
              "tag": "canvas",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The texture width.",
                      "name": "width",
                      "type": "number"
                    },
                    {
                      "description": "The texture height.",
                      "name": "height",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the height of the textures of the Pass\u0027s canvas, in pixels.",
              "key": "Pass:getHeight",
              "module": "lovr.graphics",
              "name": "getHeight",
              "notes": "If the pass doesn\u0027t have a canvas, this function returns zero.",
              "related": [
                "Pass:getWidth",
                "Pass:getDimensions",
                "Pass:getViewCount",
                "Pass:getCanvas",
                "Pass:setCanvas",
                "lovr.system.getWindowHeight",
                "lovr.headset.getDisplayHeight",
                "Pass"
              ],
              "summary": "Get the height of the Pass\u0027s canvas.",
              "tag": "canvas",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The texture height.",
                      "name": "height",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the debug label of the Pass, which will show up when the Pass is printed and in some graphics debugging tools.  This is set when the Pass is created, and can\u0027t be changed afterwards.",
              "key": "Pass:getLabel",
              "module": "lovr.graphics",
              "name": "getLabel",
              "related": [
                "lovr.graphics.newPass",
                "Texture:getLabel",
                "Shader:getLabel",
                "Pass"
              ],
              "summary": "Get the debug label of the Pass.",
              "tag": "pass-misc",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The label, or nil if none was set.",
                      "name": "label",
                      "type": "string"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the projection for a single view.",
              "key": "Pass:getProjection",
              "module": "lovr.graphics",
              "name": "getProjection",
              "related": [
                "lovr.headset.getViewAngles",
                "lovr.headset.getViewCount",
                "Pass:getViewPose",
                "Pass:setViewPose",
                "Pass:setProjection",
                "Pass"
              ],
              "summary": "Get the field of view.",
              "tag": "camera",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The view index.",
                      "name": "view",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The left field of view angle, in radians.",
                      "name": "left",
                      "type": "number"
                    },
                    {
                      "description": "The right field of view angle, in radians.",
                      "name": "right",
                      "type": "number"
                    },
                    {
                      "description": "The top field of view angle, in radians.",
                      "name": "up",
                      "type": "number"
                    },
                    {
                      "description": "The bottom field of view angle, in radians.",
                      "name": "down",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The view index.",
                      "name": "view",
                      "type": "number"
                    },
                    {
                      "description": "The matrix to fill with the projection.",
                      "name": "matrix",
                      "type": "Mat4"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The matrix containing the projection.",
                      "name": "matrix",
                      "type": "Mat4"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns statistics for the Pass.",
              "examples": [
                {
                  "code": "lovr.graphics.setTimingEnabled(true)\n\nfunction lovr.draw(pass)\n  pass:cube(0, 1.7, -1, .5, lovr.timer.getTime() * .2, 0, 1, 0)\n\n  local stats \u003d pass:getStats()\n  print((\u0027Rendering a cube takes %f microseconds\u0027):format(stats.gpuTime * 1e6))\nend",
                  "description": "See how long it takes the GPU to render a cube."
                }
              ],
              "key": "Pass:getStats",
              "module": "lovr.graphics",
              "name": "getStats",
              "related": [
                "lovr.graphics.isTimingEnabled",
                "lovr.graphics.setTimingEnabled",
                "Pass:setViewCull",
                "Pass"
              ],
              "summary": "Get statistics for the Pass.",
              "tag": "pass-misc",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "A table with statistics.",
                      "name": "stats",
                      "table": [
                        {
                          "description": "The number of draws added to the Pass.",
                          "name": "draws",
                          "type": "number"
                        },
                        {
                          "description": "The number of compute calls added to the Pass.",
                          "name": "computes",
                          "type": "number"
                        },
                        {
                          "description": "The number of draw calls that were culled the last time the Pass was submitted.",
                          "name": "drawsCulled",
                          "type": "number"
                        },
                        {
                          "description": "The amount of CPU memory the Pass has reserved, in bytes.",
                          "name": "cpuMemoryReserved",
                          "type": "number"
                        },
                        {
                          "description": "The amount of CPU memory the Pass is currently using, in bytes.",
                          "name": "cpuMemoryUsed",
                          "type": "number"
                        },
                        {
                          "description": "The amount of time taken on the CPU to submit the Pass the last time it was submitted, in seconds.  Only updates when timing stats have been enabled with `lovr.graphics.setTimingEnabled`, and has a few frames of delay.",
                          "name": "submitTime",
                          "type": "number"
                        },
                        {
                          "description": "The amount of time taken on the GPU to process the Pass, in seconds.  Only updates when timing stats have been enabled with `lovr.graphics.setTimingEnabled`, and has a few frames of delay.",
                          "name": "gpuTime",
                          "type": "number"
                        }
                      ],
                      "type": "table"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the Buffer that tally results will be written to.  Each time the render pass finishes, the results of all the tallies will be copied to the Buffer at the specified offset.  The buffer can be used in a later pass in a compute shader, or the data in the buffer can be read back using e.g. `Buffer:newReadback`.\n\nIf no buffer has been set, this function will return `nil`.",
              "key": "Pass:getTallyBuffer",
              "module": "lovr.graphics",
              "name": "getTallyBuffer",
              "related": [
                "Pass:beginTally",
                "Pass:finishTally",
                "Pass:setTallyBuffer",
                "Pass"
              ],
              "summary": "Get the Buffer that tally results will be written to.",
              "tag": "tally",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The buffer.",
                      "name": "buffer",
                      "type": "Buffer"
                    },
                    {
                      "description": "An offset in the buffer where results will be written.",
                      "name": "offset",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the view count of a render pass.  This is the layer count of the textures it is rendering to.",
              "key": "Pass:getViewCount",
              "module": "lovr.graphics",
              "name": "getViewCount",
              "notes": "A render pass has one \"camera\" for each view.  Whenever something is drawn, it is broadcast to each view (layer) of each texture, using the corresponding camera.",
              "related": [
                "Pass:getViewPose",
                "Pass:setViewPose",
                "Pass:getProjection",
                "Pass:setProjection",
                "lovr.headset.getViewCount",
                "Pass"
              ],
              "summary": "Returns the view count of a render pass.",
              "tag": "camera",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The view count.",
                      "name": "views",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Get the pose of a single view.",
              "key": "Pass:getViewPose",
              "module": "lovr.graphics",
              "name": "getViewPose",
              "related": [
                "lovr.headset.getViewPose",
                "lovr.headset.getViewCount",
                "Pass:getProjection",
                "Pass:setProjection",
                "Pass:setViewPose",
                "Pass"
              ],
              "summary": "Get the camera pose.",
              "tag": "camera",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The view index.",
                      "name": "view",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The x position of the viewer, in meters.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y position of the viewer, in meters.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z position of the viewer, in meters.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The number of radians the viewer is rotated around its axis of rotation.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The view index.",
                      "name": "view",
                      "type": "number"
                    },
                    {
                      "description": "The matrix to fill with the view pose.",
                      "name": "matrix",
                      "type": "Mat4"
                    },
                    {
                      "description": "Whether the matrix should be inverted.",
                      "name": "invert",
                      "type": "boolean"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The matrix containing the view pose.",
                      "name": "matrix",
                      "type": "Mat4"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the width of the textures of the Pass\u0027s canvas, in pixels.",
              "key": "Pass:getWidth",
              "module": "lovr.graphics",
              "name": "getWidth",
              "notes": "If the pass doesn\u0027t have a canvas, this function returns zero.",
              "related": [
                "Pass:getHeight",
                "Pass:getDimensions",
                "Pass:getViewCount",
                "Pass:getCanvas",
                "Pass:setCanvas",
                "lovr.system.getWindowWidth",
                "lovr.headset.getDisplayWidth",
                "Pass"
              ],
              "summary": "Get the width of the Pass\u0027s canvas.",
              "tag": "canvas",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The texture width.",
                      "name": "width",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Draws a line between points.  `Pass:mesh` can also be used to draw line segments using the `line` `DrawMode`.",
              "key": "Pass:line",
              "module": "lovr.graphics",
              "name": "line",
              "notes": "There is currently no way to increase line thickness.",
              "related": ["Pass"],
              "summary": "Draw a line.",
              "tag": "drawing",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The x coordinate of the first point.",
                      "name": "x1",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate of the first point.",
                      "name": "y1",
                      "type": "number"
                    },
                    {
                      "description": "The z coordinate of the first point.",
                      "name": "z1",
                      "type": "number"
                    },
                    {
                      "description": "The x coordinate of the next point.",
                      "name": "x2",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate of the next point.",
                      "name": "y2",
                      "type": "number"
                    },
                    {
                      "description": "The z coordinate of the next point.",
                      "name": "z2",
                      "type": "number"
                    },
                    {
                      "description": "More points to add to the line.",
                      "name": "...",
                      "type": "*"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "A table of numbers or `Vec3` objects (not a mix) representing points of the line.",
                      "name": "t",
                      "type": "table"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "A vector containing the position of the first point of the line.",
                      "name": "v1",
                      "type": "Vec3"
                    },
                    {
                      "description": "A vector containing the position of the next point on the line.",
                      "name": "v2",
                      "type": "Vec3"
                    },
                    {
                      "description": "More points to add to the line.",
                      "name": "...",
                      "type": "*"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Draws a mesh.",
              "examples": [
                {
                  "code": "function lovr.load()\n  local vertices \u003d {\n    { vec3(  0,  .4, 0), vec4(1, 0, 0, 1) },\n    { vec3(-.5, -.4, 0), vec4(0, 1, 0, 1) },\n    { vec3( .5, -.4, 0), vec4(0, 0, 1, 1) }\n  }\n\n  local format \u003d {\n    { name \u003d \u0027VertexPosition\u0027, type \u003d \u0027vec3\u0027 },\n    { name \u003d \u0027VertexColor\u0027, type \u003d \u0027vec4\u0027 }\n  }\n\n  triangle \u003d lovr.graphics.newBuffer(format, vertices)\nend\n\nfunction lovr.draw(pass)\n  pass:mesh(triangle, 0, 1.7, -1)\nend"
                }
              ],
              "key": "Pass:mesh",
              "module": "lovr.graphics",
              "name": "mesh",
              "notes": "The index buffer defines the order the vertices are drawn in.  It can be used to reorder, reuse, or omit vertices from the mesh.\n\nWhen drawing without a vertex buffer, the `VertexIndex` variable can be used in shaders to compute the position of each vertex, possibly by reading data from other `Buffer` or `Texture` resources.\n\nThe active `DrawMode` controls whether the vertices are drawn as points, lines, or triangles.\n\nThe active `Material` is applied to the mesh.",
              "related": ["Pass:setMeshMode", "Pass"],
              "summary": "Draw a mesh.",
              "tag": "drawing",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "nil",
                      "description": "The buffer containing the vertices to draw.",
                      "name": "vertices",
                      "type": "Buffer"
                    },
                    {
                      "default": "0",
                      "description": "The x coordinate of the position to draw the mesh at.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The y coordinate of the position to draw the mesh at.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z coordinate of the position to draw the mesh at.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The scale of the mesh.",
                      "name": "scale",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The number of radians the mesh is rotated around its rotational axis.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The 1-based index of the first vertex to render from the vertex buffer (or the first index, when using an index buffer).",
                      "name": "start",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "The number of vertices to render (or the number of indices, when using an index buffer). When `nil`, as many vertices or indices as possible will be drawn (based on the length of the Buffers and `start`).",
                      "name": "count",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The number of copies of the mesh to render.",
                      "name": "instances",
                      "type": "number"
                    }
                  ],
                  "description": "Draw a range of vertices from a Buffer, using numbers for the transform.",
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "default": "nil",
                      "description": "The buffer containing the vertices to draw.",
                      "name": "vertices",
                      "type": "Buffer"
                    },
                    {
                      "description": "The position to draw the mesh at.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "description": "The scale of the mesh.",
                      "name": "scales",
                      "type": "Vec3"
                    },
                    {
                      "description": "The orientation of the mesh.",
                      "name": "orientation",
                      "type": "Quat"
                    },
                    {
                      "default": "1",
                      "description": "The 1-based index of the first vertex to render from the vertex buffer (or the first index, when using an index buffer).",
                      "name": "start",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "The number of vertices to render (or the number of indices, when using an index buffer). When `nil`, as many vertices or indices as possible will be drawn (based on the length of the Buffers and `start`).",
                      "name": "count",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The number of copies of the mesh to render.",
                      "name": "instances",
                      "type": "number"
                    }
                  ],
                  "description": "Draw a range of vertices from a Buffer, using vector types for the transform.",
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "default": "nil",
                      "description": "The buffer containing the vertices to draw.",
                      "name": "vertices",
                      "type": "Buffer"
                    },
                    {
                      "description": "The transform to apply to the mesh.",
                      "name": "transform",
                      "type": "Mat4"
                    },
                    {
                      "default": "1",
                      "description": "The 1-based index of the first vertex to render from the vertex buffer (or the first index, when using an index buffer).",
                      "name": "start",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "The number of vertices to render (or the number of indices, when using an index buffer). When `nil`, as many vertices or indices as possible will be drawn (based on the length of the Buffers and `start`).",
                      "name": "count",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The number of copies of the mesh to render.",
                      "name": "instances",
                      "type": "number"
                    }
                  ],
                  "description": "Draw a range of vertices from a Buffer, using a matrix for the transform.",
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "default": "nil",
                      "description": "The buffer containing the vertices to draw.",
                      "name": "vertices",
                      "type": "Buffer"
                    },
                    {
                      "description": "The buffer containing the vertex indices to draw.",
                      "name": "indices",
                      "type": "Buffer"
                    },
                    {
                      "default": "0",
                      "description": "The x coordinate of the position to draw the mesh at.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The y coordinate of the position to draw the mesh at.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z coordinate of the position to draw the mesh at.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The scale of the mesh.",
                      "name": "scale",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The number of radians the mesh is rotated around its rotational axis.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The 1-based index of the first vertex to render from the vertex buffer (or the first index, when using an index buffer).",
                      "name": "start",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "The number of vertices to render (or the number of indices, when using an index buffer). When `nil`, as many vertices or indices as possible will be drawn (based on the length of the Buffers and `start`).",
                      "name": "count",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The number of copies of the mesh to render.",
                      "name": "instances",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "A base offset to apply to vertex indices.",
                      "name": "base",
                      "type": "number"
                    }
                  ],
                  "description": "Draw a mesh using a vertex buffer and an index buffer, using numbers for the transform.",
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "default": "nil",
                      "description": "The buffer containing the vertices to draw.",
                      "name": "vertices",
                      "type": "Buffer"
                    },
                    {
                      "description": "The buffer containing the vertex indices to draw.",
                      "name": "indices",
                      "type": "Buffer"
                    },
                    {
                      "description": "The position to draw the mesh at.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "description": "The scale of the mesh.",
                      "name": "scales",
                      "type": "Vec3"
                    },
                    {
                      "description": "The orientation of the mesh.",
                      "name": "orientation",
                      "type": "Quat"
                    },
                    {
                      "default": "1",
                      "description": "The 1-based index of the first vertex to render from the vertex buffer (or the first index, when using an index buffer).",
                      "name": "start",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "The number of vertices to render (or the number of indices, when using an index buffer). When `nil`, as many vertices or indices as possible will be drawn (based on the length of the Buffers and `start`).",
                      "name": "count",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The number of copies of the mesh to render.",
                      "name": "instances",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "A base offset to apply to vertex indices.",
                      "name": "base",
                      "type": "number"
                    }
                  ],
                  "description": "Draw a mesh using a vertex buffer and an index buffer, using vector types for the transform.",
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "default": "nil",
                      "description": "The buffer containing the vertices to draw.",
                      "name": "vertices",
                      "type": "Buffer"
                    },
                    {
                      "description": "The buffer containing the vertex indices to draw.",
                      "name": "indices",
                      "type": "Buffer"
                    },
                    {
                      "description": "The transform to apply to the mesh.",
                      "name": "transform",
                      "type": "Mat4"
                    },
                    {
                      "default": "1",
                      "description": "The 1-based index of the first vertex to render from the vertex buffer (or the first index, when using an index buffer).",
                      "name": "start",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "The number of vertices to render (or the number of indices, when using an index buffer). When `nil`, as many vertices or indices as possible will be drawn (based on the length of the Buffers and `start`).",
                      "name": "count",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The number of copies of the mesh to render.",
                      "name": "instances",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "A base offset to apply to vertex indices.",
                      "name": "base",
                      "type": "number"
                    }
                  ],
                  "description": "Draw a mesh using a vertex buffer and an index buffer, using a matrix for the transform.",
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "default": "nil",
                      "description": "The buffer containing the vertices to draw.",
                      "name": "vertices",
                      "type": "Buffer"
                    },
                    {
                      "description": "The buffer containing the vertex indices to draw.",
                      "name": "indices",
                      "type": "Buffer"
                    },
                    {
                      "description": "The buffer containing indirect draw commands.",
                      "name": "draws",
                      "type": "Buffer"
                    },
                    {
                      "default": "1",
                      "description": "The number of indirect draws to draw.",
                      "name": "drawcount",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "A byte offset into the draw buffer.",
                      "name": "offset",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The number of bytes between consecutive elements in the draw buffer.  When zero or nil, the stride is autodetected, and will be 20 bytes when an index buffer is provided and 16 bytes otherwise.",
                      "name": "stride",
                      "type": "number"
                    }
                  ],
                  "description": "Perform indirect draws by specifying a `draws` command buffer.  This allows for the drawing of instanced geometry to be orchestrated by a compute shader that writes to the `draws` buffer.  The `draws` buffer contains one or more commands that define how to draw instances. The `stride` determines the number of bytes between each draw command.  By default the draws are assumed to be tightly packed, with 20 bytes between indexed draws and 16 bytes for non-indexed draws.\n\nThe `draws` buffer should use one of these formats:\n\n    { -- drawing with vertices and indices\n      { name \u003d \u0027indexCount\u0027, type \u003d \u0027u32\u0027 },\n      { name \u003d \u0027instanceCount\u0027, type \u003d \u0027u32\u0027 },\n      { name \u003d \u0027firstIndex\u0027, type \u003d \u0027u32\u0027 },\n      { name \u003d \u0027vertexOffset\u0027, type \u003d \u0027i32\u0027 },\n      { name \u003d \u0027firstInstance\u0027, type \u003d \u0027u32\u0027 }\n    }\n\n    { -- drawing with vertices; indices \u003d nil\n      { name \u003d \u0027vertexCount\u0027, type \u003d \u0027u32\u0027 },\n      { name \u003d \u0027instanceCount\u0027, type \u003d \u0027u32\u0027 },\n      { name \u003d \u0027firstVertex\u0027, type \u003d \u0027u32\u0027 },\n      { name \u003d \u0027firstInstance\u0027, type \u003d \u0027u32\u0027 }\n    }",
                  "returns": {}
                }
              ]
            },
            {
              "description": "Resets the transform back to the origin.",
              "key": "Pass:origin",
              "module": "lovr.graphics",
              "name": "origin",
              "related": [
                "Pass:translate",
                "Pass:rotate",
                "Pass:scale",
                "Pass:transform",
                "Pass:push",
                "Pass:pop",
                "Pass"
              ],
              "summary": "Reset the transform to the origin.",
              "tag": "transform",
              "variants": [{ "arguments": {}, "returns": {} }]
            },
            {
              "description": "Draws a plane.",
              "key": "Pass:plane",
              "module": "lovr.graphics",
              "name": "plane",
              "related": ["Pass"],
              "summary": "Draw a plane.",
              "tag": "drawing",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "0",
                      "description": "The x coordinate of the center of the plane.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The y coordinate of the center of the plane.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z coordinate of the center of the plane.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The width of the plane.",
                      "name": "width",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The height of the plane.",
                      "name": "height",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The rotation of the plane around its rotation axis, in radians.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    },
                    {
                      "default": "\u0027fill\u0027",
                      "description": "Whether the plane should be drawn filled or outlined.",
                      "name": "style",
                      "type": "DrawStyle"
                    },
                    {
                      "default": "1",
                      "description": "The number of horizontal segments in the plane.",
                      "name": "columns",
                      "type": "number"
                    },
                    {
                      "default": "columns",
                      "description": "The number of vertical segments in the plane.",
                      "name": "rows",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The position of the plane.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "description": "The size of the plane.",
                      "name": "size",
                      "type": "Vec2"
                    },
                    {
                      "description": "The orientation of the plane.",
                      "name": "orientation",
                      "type": "Quat"
                    },
                    {
                      "default": "\u0027fill\u0027",
                      "description": "Whether the plane should be drawn filled or outlined.",
                      "name": "style",
                      "type": "DrawStyle"
                    },
                    {
                      "default": "1",
                      "description": "The number of horizontal segments in the plane.",
                      "name": "columns",
                      "type": "number"
                    },
                    {
                      "default": "columns",
                      "description": "The number of vertical segments in the plane.",
                      "name": "rows",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The transform of the plane.",
                      "name": "transform",
                      "type": "Mat4"
                    },
                    {
                      "default": "\u0027fill\u0027",
                      "description": "Whether the plane should be drawn filled or outlined.",
                      "name": "style",
                      "type": "DrawStyle"
                    },
                    {
                      "default": "1",
                      "description": "The number of horizontal segments in the plane.",
                      "name": "columns",
                      "type": "number"
                    },
                    {
                      "default": "columns",
                      "description": "The number of vertical segments in the plane.",
                      "name": "rows",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Draws points.  `Pass:mesh` can also be used to draw points using a `Buffer`.",
              "key": "Pass:points",
              "module": "lovr.graphics",
              "name": "points",
              "notes": "To change the size of points, set the `pointSize` shader flag in `lovr.graphics.newShader` or write to the `PointSize` variable in the vertex shader.  Points are always the same size on the screen, regardless of distance, and the units are in pixels.",
              "related": ["Pass"],
              "summary": "Draw points.",
              "tag": "drawing",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The x coordinate of the first point.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate of the first point.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z coordinate of the first point.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "More points.",
                      "name": "...",
                      "type": "*"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "A table of numbers or Vec3 objects (not both) representing point positions.",
                      "name": "t",
                      "type": "table"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "A vector containing the position of the first point to draw.",
                      "name": "v",
                      "type": "Vec3"
                    },
                    {
                      "description": "More points.",
                      "name": "...",
                      "type": "*"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Draws a polygon.  The 3D vertices must be coplanar (all lie on the same plane), and the polygon must be convex (does not intersect itself or have any angles between vertices greater than 180 degrees), otherwise rendering artifacts may occur.",
              "key": "Pass:polygon",
              "module": "lovr.graphics",
              "name": "polygon",
              "notes": "Currently, the polygon will not have normal vectors.\n\n`Mesh` objects can also be used to draw arbitrary triangle meshes.",
              "related": ["Pass:points", "Pass:line", "Pass:draw", "Pass"],
              "summary": "Draw a polygon.",
              "tag": "drawing",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The x coordinate of the first vertex.",
                      "name": "x1",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate of the first vertex.",
                      "name": "y1",
                      "type": "number"
                    },
                    {
                      "description": "The z coordinate of the first vertex.",
                      "name": "z1",
                      "type": "number"
                    },
                    {
                      "description": "The x coordinate of the next vertex.",
                      "name": "x2",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate of the next vertex.",
                      "name": "y2",
                      "type": "number"
                    },
                    {
                      "description": "The z coordinate of the next vertex.",
                      "name": "z2",
                      "type": "number"
                    },
                    {
                      "description": "More vertices to add to the polygon.",
                      "name": "...",
                      "type": "*"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "A table of numbers or `Vec3` objects (not a mix) representing vertices of the polygon.",
                      "name": "t",
                      "type": "table"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "A vector containing the position of the first vertex of the polygon.",
                      "name": "v1",
                      "type": "Vec3"
                    },
                    {
                      "description": "A vector containing the position of the next vertex on the polygon.",
                      "name": "v2",
                      "type": "Vec3"
                    },
                    {
                      "description": "More vertices to add to the polygon.",
                      "name": "...",
                      "type": "*"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Pops the transform or render state stack, restoring it to the state it was in when it was last pushed.",
              "key": "Pass:pop",
              "module": "lovr.graphics",
              "name": "pop",
              "notes": "If a stack is popped without a corresponding push, the stack \"underflows\" which causes an error.",
              "related": ["Pass:push", "StackType", "Pass"],
              "summary": "Pop one of the stacks.",
              "tag": "transform",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "\u0027transform\u0027",
                      "description": "The type of stack to pop.",
                      "name": "stack",
                      "type": "StackType"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Saves a copy of the transform or render states.  Further changes can be made to the transform or render states, and afterwards `Pass:pop` can be used to restore the original state.  Pushes and pops can be nested, but it\u0027s an error to pop without a corresponding push.",
              "key": "Pass:push",
              "module": "lovr.graphics",
              "name": "push",
              "notes": "Each stack has a limit of the number of copies it can store.  There can be 16 transforms and 4 render states saved.\n\nThe `state` stack does not save the camera info or shader variables changed with `Pass:send`.",
              "related": ["Pass:pop", "StackType", "Pass"],
              "summary": "Push state onto a stack.",
              "tag": "transform",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "\u0027transform\u0027",
                      "description": "The type of stack to push.",
                      "name": "stack",
                      "type": "StackType"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Resets the Pass, clearing all of its draws and computes and resetting all of its state to the default values.",
              "key": "Pass:reset",
              "module": "lovr.graphics",
              "name": "reset",
              "notes": "The following things won\u0027t be reset:\n\n- Pass canvas, set with `Pass:setCanvas`.\n- Pass clears, set with `Pass:setClear`.\n- The tally buffer, set with `Pass:setTallyBuffer`.",
              "related": ["Pass"],
              "summary": "Reset the Pass.",
              "tag": "pass-misc",
              "variants": [{ "arguments": {}, "returns": {} }]
            },
            {
              "description": "Rotates the coordinate system.",
              "key": "Pass:rotate",
              "module": "lovr.graphics",
              "name": "rotate",
              "related": [
                "Pass:translate",
                "Pass:scale",
                "Pass:transform",
                "Pass:origin",
                "Pass:push",
                "Pass:pop",
                "Pass"
              ],
              "summary": "Rotate the coordinate system.",
              "tag": "transform",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The amount to rotate the coordinate system by, in radians.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    }
                  ],
                  "description": "Rotate the coordinate system using numbers.",
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "A quaternion containing the rotation to apply.",
                      "name": "rotation",
                      "type": "Quat"
                    }
                  ],
                  "description": "Rotate the coordinate system using a quaternion.",
                  "returns": {}
                }
              ]
            },
            {
              "description": "Draws a rounded rectangle.",
              "key": "Pass:roundrect",
              "module": "lovr.graphics",
              "name": "roundrect",
              "related": ["Pass"],
              "summary": "Draw a rounded rectangle.",
              "tag": "drawing",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "0",
                      "description": "The x coordinate of the center of the rectangle.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The y coordinate of the center of the rectangle.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z coordinate of the center of the rectangle.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The width of the rectangle.",
                      "name": "width",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The height of the rectangle.",
                      "name": "height",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The thickness of the rectangle.",
                      "name": "thickness",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The rotation of the rectangle around its rotation axis, in radians.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The radius of the rectangle corners.  If the radius is zero or negative, the rectangle will have sharp corners.",
                      "name": "radius",
                      "type": "number"
                    },
                    {
                      "default": "8",
                      "description": "The number of circular segments to use for each corner.  This increases the smoothness, but increases the number of vertices in the mesh.",
                      "name": "segments",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The position of the rectangle.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "description": "The size of the rectangle (width, height, thickness).",
                      "name": "size",
                      "type": "Vec3"
                    },
                    {
                      "description": "The orientation of the rectangle.",
                      "name": "orientation",
                      "type": "Quat"
                    },
                    {
                      "default": "0",
                      "description": "The radius of the rectangle corners.  If the radius is zero or negative, the rectangle will have sharp corners.",
                      "name": "radius",
                      "type": "number"
                    },
                    {
                      "default": "8",
                      "description": "The number of circular segments to use for each corner.  This increases the smoothness, but increases the number of vertices in the mesh.",
                      "name": "segments",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The transform of the rectangle.",
                      "name": "transform",
                      "type": "Mat4"
                    },
                    {
                      "default": "0",
                      "description": "The radius of the rectangle corners.  If the radius is zero or negative, the rectangle will have sharp corners.",
                      "name": "radius",
                      "type": "number"
                    },
                    {
                      "default": "8",
                      "description": "The number of circular segments to use for each corner.  This increases the smoothness, but increases the number of vertices in the mesh.",
                      "name": "segments",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Scales the coordinate system.",
              "key": "Pass:scale",
              "module": "lovr.graphics",
              "name": "scale",
              "related": [
                "Pass:translate",
                "Pass:rotate",
                "Pass:transform",
                "Pass:origin",
                "Pass:push",
                "Pass:pop",
                "Pass"
              ],
              "summary": "Scale the coordinate system.",
              "tag": "transform",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The x component of the scale.",
                      "name": "sx",
                      "type": "number"
                    },
                    {
                      "default": "sx",
                      "description": "The y component of the scale.",
                      "name": "sy",
                      "type": "number"
                    },
                    {
                      "default": "sx",
                      "description": "The z component of the scale.",
                      "name": "sz",
                      "type": "number"
                    }
                  ],
                  "description": "Scale the coordinate system using numbers.",
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The scale to apply.",
                      "name": "scale",
                      "type": "Vec3"
                    }
                  ],
                  "description": "Scale the coordinate system using a vector.",
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sends a value to a variable in the Pass\u0027s active `Shader`.  The active shader is changed using `Pass:setShader`.",
              "examples": [
                {
                  "code": "function lovr.load()\n  shader \u003d lovr.graphics.newShader([[\n    uniform sampler mySampler;\n    uniform Colors { vec4 colors[256]; };\n    uniform texture2D rocks;\n    uniform uint constant;\n\n    vec4 lovrmain() {\n      return DefaultPosition;\n    }\n  ]], \u0027unlit\u0027)\n\n  clampler \u003d lovr.graphics.newSampler({ wrap \u003d \u0027clamp\u0027 })\n  colorBuffer \u003d lovr.graphics.newBuffer(256, \u0027vec4\u0027)\n  rockTexture \u003d lovr.graphics.newTexture(\u0027rocks.jpg\u0027)\nend\n\nfunction lovr.draw(pass)\n  pass:setShader(shader)\n  pass:send(\u0027mySampler\u0027, clampler)\n  pass:send(\u0027Colors\u0027, colorBuffer)\n  pass:send(\u0027rocks\u0027, rockTexture)\n  pass:send(\u0027constant\u0027, 42)\n  -- Draw\nend"
                }
              ],
              "key": "Pass:send",
              "module": "lovr.graphics",
              "name": "send",
              "notes": "The new value will persist until a new shader is set that uses a different \"type\" for the binding number of the variable.  See `Pass:setShader` for more details.",
              "related": ["Pass"],
              "summary": "Set the value of a shader variable.",
              "tag": "shaders",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The name of the Shader variable.",
                      "name": "name",
                      "type": "string"
                    },
                    {
                      "description": "The Buffer to assign.",
                      "name": "buffer",
                      "type": "Buffer"
                    },
                    {
                      "default": "0",
                      "description": "An offset from the start of the buffer where data will be read, in bytes.",
                      "name": "offset",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The number of bytes that will be available for reading.  If zero, as much data as possible will be bound, depending on the offset, buffer size, and the `uniformBufferRange` or `storageBufferRange` limit.",
                      "name": "extent",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The name of the Shader variable.",
                      "name": "name",
                      "type": "string"
                    },
                    {
                      "description": "The Texture to assign.",
                      "name": "texture",
                      "type": "Texture"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The name of the Shader variable.",
                      "name": "name",
                      "type": "string"
                    },
                    {
                      "description": "The Sampler to assign.",
                      "name": "sampler",
                      "type": "Sampler"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The name of the Shader variable.",
                      "name": "name",
                      "type": "string"
                    },
                    {
                      "description": "Numbers, booleans, vectors, or tables to assign to the data or uniform buffer.",
                      "name": "data",
                      "type": "*"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets whether alpha to coverage is enabled.  Alpha to coverage factors the alpha of a pixel into antialiasing calculations.  It can be used to get antialiased edges on textures with transparency.  It\u0027s often used for foliage.",
              "key": "Pass:setAlphaToCoverage",
              "module": "lovr.graphics",
              "name": "setAlphaToCoverage",
              "notes": "By default, alpha to coverage is disabled.",
              "related": ["Pass"],
              "summary": "Enable or disable alpha to coverage.",
              "tag": "pipeline",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "Whether alpha to coverage should be enabled.",
                      "name": "enable",
                      "type": "boolean"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the blend mode.  When a pixel is drawn, the blend mode controls how it is mixed with the color and alpha of the pixel underneath it.",
              "key": "Pass:setBlendMode",
              "module": "lovr.graphics",
              "name": "setBlendMode",
              "notes": "The default blend mode is `alpha` with the `alphamultiply` alpha mode.",
              "related": ["Pass"],
              "summary": "Set the blend mode.",
              "tag": "pipeline",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The blend mode.",
                      "name": "blend",
                      "type": "BlendMode"
                    },
                    {
                      "description": "The alpha blend mode, used to control premultiplied alpha.",
                      "name": "alphaBlend",
                      "type": "BlendAlphaMode"
                    }
                  ],
                  "description": "Sets the blend mode for all canvas textures.",
                  "returns": {}
                },
                {
                  "arguments": {},
                  "description": "Disables blending.  When something is drawn, its pixel colors will replace any existing color in the target texture.  This can work okay for opaque objects, but won\u0027t render text or transparency properly.",
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The index of the canvas texture that will use the new blend mode.",
                      "name": "index",
                      "type": "number"
                    },
                    {
                      "description": "The blend mode.",
                      "name": "blend",
                      "type": "BlendMode"
                    },
                    {
                      "description": "The alpha blend mode, used to control premultiplied alpha.",
                      "name": "alphaBlend",
                      "type": "BlendAlphaMode"
                    }
                  ],
                  "description": "Sets the blend mode for a single canvas texture.",
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The index of the canvas texture that will use the new blend mode.",
                      "name": "index",
                      "type": "number"
                    }
                  ],
                  "description": "Disables blending for a single canvas texture.",
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the Pass\u0027s canvas.  The canvas is a set of textures that the Pass will draw to when it\u0027s submitted, along with configuration for the depth buffer and antialiasing.",
              "key": "Pass:setCanvas",
              "module": "lovr.graphics",
              "name": "setCanvas",
              "notes": "Changing the canvas will reset the pass, as though `Pass:reset` was called.\n\nAll textures must have the same dimensions, layer counts, and multisample counts.  They also must have been created with the `render` usage flag.\n\nThe number of layers in the textures determines how many views (cameras) the pass has.  Each draw will be rendered to all texture layers, as seen from the corresponding camera.  For example, VR rendering will use a canvas texture with 2 layers, one for each eye.\n\nTo render to a specific mipmap level or layer of a texture, use texture views (`lovr.graphics.newTextureView`).\n\nMipmaps will be regenerated for all of canvas textures at the end of a render pass.\n\nIf the Pass has multiple color textures, a fragment shader should be used to write a different color to each texture.  Here\u0027s an example that writes red to the first texture and blue to the second texture:\n\n    \/\/ Declare an output variable for the second texture\n    layout(location \u003d 1) out vec4 secondColor;\n\n    vec4 lovrmain() {\n      secondColor \u003d vec4(0, 0, 1, 1);\n      return vec4(1, 0, 0, 1);\n    }",
              "related": [
                "Pass:getClear",
                "Pass:setClear",
                "Pass:getWidth",
                "Pass:getHeight",
                "Pass:getDimensions",
                "Pass:getCanvas",
                "Pass"
              ],
              "summary": "Set the Pass\u0027s canvas.",
              "tag": "canvas",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "One or more color textures the pass will render to.",
                      "name": "...textures",
                      "type": "Texture"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The canvas.  Each numeric key is a color texture to render to (up to 4), along with the following keys to control depth buffer and antialiasing settings:",
                      "name": "canvas",
                      "table": [
                        {
                          "default": "d32f",
                          "description": "A `Texture` or `TextureFormat` with the depth buffer.",
                          "name": "depth",
                          "type": "*"
                        },
                        {
                          "default": "4",
                          "description": "The number of multisamples used for antialiasing (either 1 or 4).",
                          "name": "samples",
                          "type": "number"
                        }
                      ],
                      "type": "table"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": {},
                  "description": "Disable the canvas.  Any draws in the Pass will be skipped when it is submitted (compute shaders will still run though).",
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the clear values of the pass.  This controls the initial colors of the canvas texture pixels at the beginning of the render pass.  For each color texture, it can be one of the following:\n\n- A specific RGBA color value (or number for the depth texture).\n- `true`, to do a \"fast clear\" to undefined values.  This is useful if the pass is going to end\n  up drawing to all of the texture\u0027s pixels.\n- `false`, to avoid clearing and load the texture\u0027s existing pixels.  This can be slow on mobile\n  GPUs.",
              "key": "Pass:setClear",
              "module": "lovr.graphics",
              "name": "setClear",
              "notes": "If the depth clear is not given, it will be set to 0.\n\nAll clear colors will default to transparent black (all zeros) when the Pass is created.",
              "related": [
                "Pass:setCanvas",
                "Texture:clear",
                "Pass:getClear",
                "Pass"
              ],
              "summary": "Set the clear values of the Pass.",
              "tag": "canvas",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "A hexcode color to clear all color textures to.",
                      "name": "hex",
                      "type": "number"
                    }
                  ],
                  "description": "Set the clear color for all color textures, using a hexcode.",
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The red component of the clear color.",
                      "name": "r",
                      "type": "number"
                    },
                    {
                      "description": "The green component of the clear color.",
                      "name": "g",
                      "type": "number"
                    },
                    {
                      "description": "The blue component of the clear color.",
                      "name": "b",
                      "type": "number"
                    },
                    {
                      "default": "1.0",
                      "description": "The alpha component of the clear color.",
                      "name": "a",
                      "type": "number"
                    }
                  ],
                  "description": "Set the clear color for all color textures, using numbers.",
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "Whether color textures should be cleared.",
                      "name": "clear",
                      "type": "boolean"
                    }
                  ],
                  "description": "Set the clear color for all color textures, using a boolean.",
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "A table of clear values.  This can be a table of 4 numbers to use for all color textures, or it can be a list of boolean and\/or RGBA tables to use for each individual color texture.  It can also have a `depth` key with a boolean\/number for the depth texture\u0027s clear.",
                      "name": "t",
                      "type": "table"
                    }
                  ],
                  "description": "Set the clear color for all color textures using a table, or set clear values for individual textures.",
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the color used for drawing.  Color components are from 0 to 1.",
              "key": "Pass:setColor",
              "module": "lovr.graphics",
              "name": "setColor",
              "notes": "The default color is `(1, 1, 1, 1)`.",
              "related": ["Pass"],
              "summary": "Set the color.",
              "tag": "pipeline",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The red component of the color.",
                      "name": "r",
                      "type": "number"
                    },
                    {
                      "description": "The green component of the color.",
                      "name": "g",
                      "type": "number"
                    },
                    {
                      "description": "The blue component of the color.",
                      "name": "b",
                      "type": "number"
                    },
                    {
                      "default": "1.0",
                      "description": "The alpha component of the color.",
                      "name": "a",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "A table of 3 or 4 color components.",
                      "name": "t",
                      "type": "table"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "A hexcode.",
                      "name": "hex",
                      "type": "number"
                    },
                    {
                      "default": "1.0",
                      "description": "The alpha component of the color.",
                      "name": "a",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the color channels affected by drawing, on a per-channel basis.  Disabling color writes is often used to render to the depth or stencil buffer without affecting existing pixel colors.",
              "key": "Pass:setColorWrite",
              "module": "lovr.graphics",
              "name": "setColorWrite",
              "notes": "By default, color writes are enabled for all channels.",
              "related": ["Pass:setDepthWrite", "Pass:setStencilWrite", "Pass"],
              "summary": "Change the color channels affected by drawing.",
              "tag": "pipeline",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "Whether all color components should be affected by draws.",
                      "name": "enable",
                      "type": "boolean"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "Whether the red component should be affected by draws.",
                      "name": "r",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether the green component should be affected by draws.",
                      "name": "g",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether the blue component should be affected by draws.",
                      "name": "b",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether the alpha component should be affected by draws.",
                      "name": "a",
                      "type": "boolean"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The index of the canvas texture to update.",
                      "name": "index",
                      "type": "number"
                    },
                    {
                      "description": "Whether all color components should be affected by draws.",
                      "name": "enable",
                      "type": "boolean"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The index of the canvas texture to update.",
                      "name": "index",
                      "type": "number"
                    },
                    {
                      "description": "Whether the red component should be affected by draws.",
                      "name": "r",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether the green component should be affected by draws.",
                      "name": "g",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether the blue component should be affected by draws.",
                      "name": "b",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether the alpha component should be affected by draws.",
                      "name": "a",
                      "type": "boolean"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "deprecated": "This function has been replaced by `Pass:setFaceCull`.",
              "description": "Sets whether the front or back faces of triangles are culled.",
              "key": "Pass:setCullMode",
              "module": "lovr.graphics",
              "name": "setCullMode",
              "notes": "By default, face culling is disabled.",
              "related": ["Pass:setViewCull", "Pass:setWinding", "Pass"],
              "summary": "Control triangle face culling.",
              "tag": "pipeline",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "Whether `front` faces, `back` faces, or `none` of the faces should be culled.",
                      "name": "mode",
                      "type": "CullMode"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": {},
                  "description": "Disable face culling.",
                  "returns": {}
                }
              ]
            },
            {
              "description": "Enables or disables depth clamp.  Normally, when pixels fall outside of the clipping planes, they are clipped (not rendered).  Depth clamp will instead render these pixels, clamping their depth on to the clipping planes.",
              "key": "Pass:setDepthClamp",
              "module": "lovr.graphics",
              "name": "setDepthClamp",
              "notes": "This isn\\\u0027t supported on all GPUs.  Use the `depthClamp` feature of `lovr.graphics.getFeatures` to check for support.  If depth clamp is enabled when unsupported, it will silently fall back to depth clipping.\n\nDepth clamping is not enabled by default.",
              "related": [
                "Pass:setDepthTest",
                "Pass:setDepthWrite",
                "Pass:setDepthOffset",
                "Pass"
              ],
              "summary": "Enable or disable depth clamp.",
              "tag": "pipeline",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "Whether depth clamp should be enabled.",
                      "name": "enable",
                      "type": "boolean"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Set the depth offset.  This is a constant offset added to the depth value of pixels, as well as a \"sloped\" depth offset that is scaled based on the \"slope\" of the depth at the pixel.\n\nThis can be used to fix Z fighting when rendering decals or other nearly-overlapping objects, and is also useful for shadow biasing when implementing shadow mapping.",
              "key": "Pass:setDepthOffset",
              "module": "lovr.graphics",
              "name": "setDepthOffset",
              "notes": "The default depth offset is zero for both values.\n\nThis only applies to triangles, not points or lines.\n\nThe units for these offsets aren\u0027t specified very well -- they depend on the format of the depth texture, and the GPU can use them slightly differently for its depth calculations.  However, an `offset` of 1 will roughly correspond to the smallest-possible depth difference (e.g. 2^-16 for a `d16` depth texture).\n\nThe sloped depth scale is multiplied by the slope of the depth of the triangle.  For example, if pixels in the triangle all have the same depth (i.e. the triangle is facing the camera), then the slope of the depth will be zero and the sloped depth offset won\u0027t have any effect.  As the triangle starts to face away from the camera, the slope of the depth will increase and the sloped depth offset will begin to apply.  This can also be thought of corresponding to the normal vector of the triangle relative to the camera.\n\nNote that the offsets can be negative.  With L\u00d6VR\u0027s default projection matrix, depth values of zero are far away and one are close up, so positive depth offsets will push depth values \"closer\" to the viewer.  With flipped projection matrices (a depth test of `lequal`), negative depth offsets would be used instead.",
              "related": ["Pass:setDepthTest", "Pass:setDepthWrite", "Pass"],
              "summary": "Configure the depth offset.",
              "tag": "pipeline",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "0.0",
                      "description": "The depth offset.",
                      "name": "offset",
                      "type": "number"
                    },
                    {
                      "default": "0.0",
                      "description": "The sloped depth offset.",
                      "name": "sloped",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the depth test.",
              "key": "Pass:setDepthTest",
              "module": "lovr.graphics",
              "name": "setDepthTest",
              "notes": "When using L\u00d6VR\u0027s default projection (reverse Z with infinite far plane) the default depth test is `gequal`, depth values of 0.0 are on the far plane and depth values of 1.0 are on the near plane, closer to the camera.\n\nThe near and far clipping planes are set with `Pass:setProjection`.  The default is set with `lovr.headset.setClipDistance`.\n\nA depth buffer must be present to use the depth test, but this is enabled by default.",
              "related": [
                "Pass:setDepthWrite",
                "Pass:setDepthOffset",
                "Pass:setDepthClamp",
                "Pass:setStencilTest",
                "Pass:setProjection",
                "Pass"
              ],
              "summary": "Configure the depth test.",
              "tag": "pipeline",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The new depth test to use.",
                      "name": "test",
                      "type": "CompareMode"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": {},
                  "description": "Disable the depth test.",
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets whether draws write to the depth buffer.  When a pixel is drawn, if depth writes are enabled and the pixel passes the depth test, the depth buffer will be updated with the pixel\u0027s depth value.",
              "key": "Pass:setDepthWrite",
              "module": "lovr.graphics",
              "name": "setDepthWrite",
              "notes": "The default depth write is `true`.",
              "related": [
                "Pass:setStencilWrite",
                "Pass:setColorWrite",
                "Pass:setDepthTest",
                "Pass"
              ],
              "summary": "Set whether draws write to the depth buffer.",
              "tag": "pipeline",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "Whether the depth buffer should be affected by draws.",
                      "name": "write",
                      "type": "boolean"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets whether the front or back faces of triangles are culled.",
              "key": "Pass:setFaceCull",
              "module": "lovr.graphics",
              "name": "setFaceCull",
              "notes": "By default, face culling is disabled.",
              "related": ["Pass:setViewCull", "Pass:setWinding", "Pass"],
              "summary": "Control triangle face culling.",
              "tag": "pipeline",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "Whether `front` faces, `back` faces, or `none` of the faces should be culled.",
                      "name": "mode",
                      "type": "CullMode"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": {},
                  "description": "Disable face culling.",
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the font used for `Pass:text`.",
              "key": "Pass:setFont",
              "module": "lovr.graphics",
              "name": "setFont",
              "related": [
                "Pass:text",
                "lovr.graphics.newFont",
                "lovr.graphics.getDefaultFont",
                "Pass"
              ],
              "summary": "Set the font.",
              "tag": "pipeline",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The Font to use when rendering text.",
                      "name": "font",
                      "type": "Font"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the material.  This will apply to most drawing, except for text, skyboxes, and models, which use their own materials.",
              "key": "Pass:setMaterial",
              "module": "lovr.graphics",
              "name": "setMaterial",
              "related": ["Pass"],
              "summary": "Set the material.",
              "tag": "pipeline",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The material to use for drawing.",
                      "name": "material",
                      "type": "Material"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The texture to use as the material.",
                      "name": "texture",
                      "type": "Texture"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": {},
                  "description": "Use the default material.",
                  "returns": {}
                }
              ]
            },
            {
              "description": "Changes the way vertices are connected together when drawing using `Pass:mesh`.",
              "key": "Pass:setMeshMode",
              "module": "lovr.graphics",
              "name": "setMeshMode",
              "notes": "The default mesh mode is `triangles`.",
              "related": ["Pass"],
              "summary": "Change the way vertices are connected together.",
              "tag": "pipeline",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The mesh mode to use.",
                      "name": "mode",
                      "type": "DrawMode"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the projection for a single view.  4 field of view angles can be used, similar to the field of view returned by `lovr.headset.getViewAngles`.  Alternatively, a projection matrix can be used for other types of projections like orthographic, oblique, etc.\n\nUp to 6 views are supported.  The Pass returned by `lovr.headset.getPass` will have its views automatically configured to match the headset.",
              "key": "Pass:setProjection",
              "module": "lovr.graphics",
              "name": "setProjection",
              "notes": "A far clipping plane of 0.0 can be used for an infinite far plane with reversed Z range.  This is the default because it improves depth precision and reduces Z fighting.  Using a non-infinite far plane requires the depth buffer to be cleared to 1.0 instead of 0.0 and the default depth test to be changed to `lequal` instead of `gequal`.\n\nBy default, the projection is set by the headset.  Each HMD has a specific field of view given by `lovr.headset.getViewAngles`, and the clipping planes can be customized with `lovr.headset.setClipDistance`.",
              "related": [
                "lovr.headset.getViewAngles",
                "lovr.headset.getViewCount",
                "Pass:getViewPose",
                "Pass:setViewPose",
                "Pass:getProjection",
                "Pass"
              ],
              "summary": "Set the field of view.",
              "tag": "camera",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of the view to update.",
                      "name": "view",
                      "type": "number"
                    },
                    {
                      "description": "The left field of view angle, in radians.",
                      "name": "left",
                      "type": "number"
                    },
                    {
                      "description": "The right field of view angle, in radians.",
                      "name": "right",
                      "type": "number"
                    },
                    {
                      "description": "The top field of view angle, in radians.",
                      "name": "up",
                      "type": "number"
                    },
                    {
                      "description": "The bottom field of view angle, in radians.",
                      "name": "down",
                      "type": "number"
                    },
                    {
                      "default": ".01",
                      "description": "The near clipping plane distance, in meters.",
                      "name": "near",
                      "type": "number"
                    },
                    {
                      "default": "0.0",
                      "description": "The far clipping plane distance, in meters.",
                      "name": "far",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The index of the view to update.",
                      "name": "view",
                      "type": "number"
                    },
                    {
                      "description": "The projection matrix for the view.",
                      "name": "matrix",
                      "type": "Mat4"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the default `Sampler` to use when sampling textures.  It is also possible to send a custom sampler to a shader using `Pass:send` and use that instead, which allows customizing the sampler on a per-texture basis.",
              "examples": [
                {
                  "code": "function lovr.draw(pass)\n  pass:setSampler(\u0027nearest\u0027) -- activate minecraft mode\n  pass:setMaterial(rock)\n  pass:cube(x, y, z)\nend"
                }
              ],
              "key": "Pass:setSampler",
              "module": "lovr.graphics",
              "name": "setSampler",
              "notes": "The `getPixel` shader helper function will use this sampler.\n\nWhen a Pass is reset, its sampler will be reset to `linear`.\n\nThe sampler applies to all draws in the pass on submit, regardless of when the sampler is set.",
              "related": ["Pass"],
              "summary": "Set the sampler.",
              "tag": "pipeline",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "\u0027linear\u0027",
                      "description": "The default filter mode to use when sampling textures (the `repeat` wrap mode will be used).",
                      "name": "filter",
                      "type": "FilterMode"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The default sampler shaders will use when reading from textures.",
                      "name": "sampler",
                      "type": "Sampler"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the scissor rectangle.  Any pixels outside the scissor rectangle will not be drawn.",
              "key": "Pass:setScissor",
              "module": "lovr.graphics",
              "name": "setScissor",
              "notes": "`x` and `y` can not be negative.  `w` and `h` must be positive.\n\nBy default, the scissor covers the entire canvas.",
              "related": ["Pass:setViewport", "Pass"],
              "summary": "Set the scissor rectangle.",
              "tag": "camera",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The x coordinate of the upper-left corner of the scissor rectangle.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate of the upper-left corner of the scissor rectangle.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The width of the scissor rectangle.",
                      "name": "w",
                      "type": "number"
                    },
                    {
                      "description": "The height of the scissor rectangle.",
                      "name": "h",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": {},
                  "description": "Disable the scissor.",
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the active shader.  In a render pass, the Shader will affect all drawing operations until it is changed again.  In a compute pass, the Shader will be run when `Pass:compute` is called.",
              "key": "Pass:setShader",
              "module": "lovr.graphics",
              "name": "setShader",
              "notes": "Changing the shader will preserve variable values (the ones set using `Pass:send`) **unless** the new shader declares a variable with the same as one in the old shader, but a different type. The variable \"type\" means one of the following:\n\n- Uniform buffer (`uniform`).\n- Storage buffer (`buffer`).\n- Sampled texture, (`uniform texture\u003ctype\u003e`).\n- Storage texture, (`uniform image\u003ctype\u003e`).\n- Sampler (`uniform sampler`).\n\nIf there\u0027s a clash in types, the variable will be reset to use a default resource:\n\n- Buffer variables do not have well-defined behavior when they are reset like this, and may\n  return random data or even crash the GPU.\n- Texture variable will use a default texture with a single white pixel.\n- Sampler variables will use a default sampler with a `linear` filter mode and `repeat` wrap\n  mode.\n\nUniform variables with basic types like `float`, `vec3`, `mat4`, etc. will have their data preserved as long as both shaders declare the variable with the same name and type.",
              "related": ["Pass:send", "Pass:compute", "Pass"],
              "summary": "Set the active Shader.",
              "tag": "shaders",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The shader to use.",
                      "name": "shader",
                      "type": "Shader"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "One of the default shaders to use.",
                      "name": "default",
                      "type": "DefaultShader"
                    }
                  ],
                  "description": "Use one of the default shaders for drawing.",
                  "returns": {}
                },
                {
                  "arguments": {},
                  "description": "Switch back to using an automatic shader for drawing.",
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the stencil test.  Any pixels that fail the stencil test won\u0027t be drawn.  For example, setting the stencil test to `(\u0027equal\u0027, 1)` will only draw pixels that have a stencil value of 1. The stencil buffer can be modified by drawing while stencil writes are enabled with `lovr.graphics.setStencilWrite`.",
              "key": "Pass:setStencilTest",
              "module": "lovr.graphics",
              "name": "setStencilTest",
              "notes": "The stencil test is disabled by default.\n\nSetting the stencil test requires the `Pass` to have a depth texture with the `d24s8` or `d32fs8` format (the `s` means \"stencil\").  The `t.graphics.stencil` and `t.headset.stencil` flags in `lovr.conf` can be used to request a stencil format for the default window and headset passes, respectively.",
              "related": ["Pass:setStencilWrite", "Pass:setDepthTest", "Pass"],
              "summary": "Configure the stencil test.",
              "tag": "pipeline",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The new stencil test to use.",
                      "name": "test",
                      "type": "CompareMode"
                    },
                    {
                      "description": "The stencil value to compare against.",
                      "name": "value",
                      "type": "number"
                    },
                    {
                      "default": "0xff",
                      "description": "An optional mask to apply to stencil values before the comparison.",
                      "name": "mask",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": {},
                  "description": "Disable the stencil test.",
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets or disables stencil writes.  When stencil writes are enabled, any pixels drawn will update the values in the stencil buffer using the `StencilAction` set.",
              "key": "Pass:setStencilWrite",
              "module": "lovr.graphics",
              "name": "setStencilWrite",
              "notes": "By default, stencil writes are disabled.\n\nSetting the stencil test requires the `Pass` to have a depth texture with the `d24s8` or `d32fs8` format (the `s` means \"stencil\").  The `t.graphics.stencil` and `t.headset.stencil` flags in `lovr.conf` can be used to request a stencil format for the default window and headset passes, respectively.",
              "related": ["Pass:setStencilTest", "Pass:setDepthTest", "Pass"],
              "summary": "Set whether draws write to the stencil buffer.",
              "tag": "pipeline",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "How pixels drawn will update the stencil buffer.",
                      "name": "action",
                      "type": "StencilAction"
                    },
                    {
                      "default": "1",
                      "description": "When using the \u0027replace\u0027 action, this is the value to replace with.",
                      "name": "value",
                      "type": "number"
                    },
                    {
                      "default": "0xff",
                      "description": "An optional mask to apply to stencil values before writing.",
                      "name": "mask",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "A list of 3 stencil actions, used when a pixel fails the stencil test, fails the depth test, or passes the stencil test, respectively.",
                      "name": "actions",
                      "type": "table"
                    },
                    {
                      "default": "1",
                      "description": "When using the \u0027replace\u0027 action, this is the value to replace with.",
                      "name": "value",
                      "type": "number"
                    },
                    {
                      "default": "0xff",
                      "description": "An optional mask to apply to stencil values before writing.",
                      "name": "mask",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": {},
                  "description": "Disables stencil writing.",
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the Buffer where tally results will be written to.  Each time the render pass finishes, the results of all the tallies will be copied to the Buffer at the specified offset.  The buffer can be used in a later pass in a compute shader, or the data in the buffer can be read back using e.g. `Buffer:newReadback`.",
              "key": "Pass:setTallyBuffer",
              "module": "lovr.graphics",
              "name": "setTallyBuffer",
              "notes": "Each tally result is a 4-byte unsigned integer with the number of samples that passed the depth and stencil tests.\n\nIf the buffer doesn\u0027t have enough room to store all the tallies, the number of tallies copied will be clamped to the minimum number that will fit.",
              "related": [
                "Pass:beginTally",
                "Pass:finishTally",
                "Pass:getTallyBuffer",
                "Pass"
              ],
              "summary": "Set the Buffer that tally results will be written to.",
              "tag": "tally",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The buffer.",
                      "name": "buffer",
                      "type": "Buffer"
                    },
                    {
                      "description": "A byte offset where results will be written.  Must be a multiple of 4.",
                      "name": "offset",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": {},
                  "description": "Unset the tally buffer.",
                  "returns": {}
                }
              ]
            },
            {
              "description": "Enables or disables view frustum culling.  When enabled, if an object is drawn outside of the camera view, the draw will be skipped.  This can improve performance.",
              "key": "Pass:setViewCull",
              "module": "lovr.graphics",
              "name": "setViewCull",
              "notes": "View frustum culling is disabled by default.\n\nObjects will be culled against all views in the Pass.  The pose and projection for these views is controlled using `Pass:setViewPose` and `Pass:setProjection`.\n\nView frustum culling will increase CPU usage, but will reduce GPU usage depending on how many objects get culled and how many vertices they have.\n\nFor most scenes that draw objects all around the camera, frustum culling will usually result in large speedups.  However, it\u0027s always good to measure to be sure.  For example, if every object drawn is in view, then frustum culling will only make things slower, because L\u00d6VR will spend time checking if objects are in view without actually culling any of them.\n\n`Pass:getStats` will return `draws` and `drawsCulled` fields.  The `submitTime` and `gpuTime` fields (with `lovr.graphics.setTimingEnabled`) are a good way to measure the impact of culling.\n\nTo cull an object against a view frustum, L\u00d6VR needs to know the object\u0027s bounding box.  The following types of draws have bounding boxes:\n\n- `Pass:plane`\n- `Pass:roundrect`\n- `Pass:cube`\n- `Pass:box`\n- `Pass:circle`\n- `Pass:sphere`\n- `Pass:cylinder`\n- `Pass:cone`\n- `Pass:capsule`\n- `Pass:torus`\n- `Pass:draw` (see notes below for `Model` and `Mesh` objects)\n\nThe following draws do **not** currently have bounding boxes, and will not be culled:\n\n- `Pass:points`\n- `Pass:line`\n- `Pass:text`\n- `Pass:skybox`\n- `Pass:fill`\n- `Pass:mesh`\n\n`Model` objects only compute their bounding box when they\u0027re loaded, using the initial node transforms.  If a model is animated, then the bounding box will become out of sync and culling will not work properly.  View culling should be disabled when rendering animated models.\n\n`Mesh` objects will not have a bounding box by default.  Meshes with a storage type of `cpu` can compute their bounding boxes using `Mesh:computeBoundingBox`, which should be called after creating the Mesh or whenever its vertices change.  Any type of Mesh can have its bounding box set manually using `Mesh:setBoundingBox`.  This can be faster than `Mesh:computeBoundingBox` if the bounding box is already known, and is the only way to give a `gpu` Mesh a bounding box.",
              "related": [
                "Pass:setCullMode",
                "Mesh:computeBoundingBox",
                "Mesh:setBoundingBox",
                "Pass:setViewPose",
                "Pass:setProjection",
                "Pass"
              ],
              "summary": "Enable or disable view frustum culling.",
              "tag": "pipeline",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "Whether frustum culling should be enabled.",
                      "name": "enable",
                      "type": "boolean"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the pose for a single view.  Objects rendered in this view will appear as though the camera is positioned using the given pose.\n\nUp to 6 views are supported.  When rendering to the headset, views are changed to match the eye positions.  These view poses are also available using `lovr.headset.getViewPose`.",
              "key": "Pass:setViewPose",
              "module": "lovr.graphics",
              "name": "setViewPose",
              "related": [
                "lovr.headset.getViewPose",
                "lovr.headset.getViewCount",
                "Pass:getProjection",
                "Pass:setProjection",
                "Pass:getViewPose",
                "Pass"
              ],
              "summary": "Set the camera pose.",
              "tag": "camera",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of the view to update.",
                      "name": "view",
                      "type": "number"
                    },
                    {
                      "description": "The x position of the viewer, in meters.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y position of the viewer, in meters.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z position of the viewer, in meters.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The number of radians the viewer is rotated around its axis of rotation.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    }
                  ],
                  "description": "Set the pose of the view using numbers.",
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The index of the view to update.",
                      "name": "view",
                      "type": "number"
                    },
                    {
                      "description": "The position of the viewer, in meters.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "description": "The orientation of the viewer.",
                      "name": "orientation",
                      "type": "Quat"
                    }
                  ],
                  "description": "Set the pose of the view using vectors.",
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The index of the view to update.",
                      "name": "view",
                      "type": "number"
                    },
                    {
                      "description": "A matrix containing the viewer pose.",
                      "name": "matrix",
                      "type": "Mat4"
                    },
                    {
                      "description": "Whether the matrix is an inverted pose (a view matrix).",
                      "name": "inverted",
                      "type": "boolean"
                    }
                  ],
                  "description": "Set the pose of the view using a matrix.",
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the viewport.  Everything rendered will get mapped to the rectangle defined by the viewport.  More specifically, this defines the transformation from normalized device coordinates to pixel coordinates.",
              "key": "Pass:setViewport",
              "module": "lovr.graphics",
              "name": "setViewport",
              "notes": "The viewport rectangle can use floating point numbers.\n\nA negative viewport height (with a y coordinate equal to the bottom of the viewport) can be used to flip the rendering vertically.\n\nThe default viewport extends from `(0, 0)` to the dimensions of the canvas, with min depth and max depth respectively set to 0 and 1.",
              "related": ["Pass:setScissor", "Pass:getDimensions", "Pass"],
              "summary": "Set the viewport.",
              "tag": "camera",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The x coordinate of the upper-left corner of the viewport.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate of the upper-left corner of the viewport.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The width of the viewport.  Must be positive.",
                      "name": "w",
                      "type": "number"
                    },
                    {
                      "description": "The height of the viewport.  May be negative.",
                      "name": "h",
                      "type": "number"
                    },
                    {
                      "default": "0.0",
                      "description": "The min component of the depth range, between 0 and 1.",
                      "name": "dmin",
                      "type": "number"
                    },
                    {
                      "default": "1.0",
                      "description": "The max component of the depth range, between 0 and 1.",
                      "name": "dmax",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": {},
                  "description": "Disable the viewport.",
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets whether vertices in the clockwise or counterclockwise order vertices are considered the \"front\" face of a triangle.  This is used for culling with `Pass:setCullMode`.",
              "key": "Pass:setWinding",
              "module": "lovr.graphics",
              "name": "setWinding",
              "notes": "The default winding is counterclockwise.  L\u00d6VR\u0027s builtin shapes are wound counterclockwise.",
              "related": ["Pass:setCullMode", "Pass"],
              "summary": "Set the winding direction of triangle vertices.",
              "tag": "pipeline",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "Whether triangle vertices are ordered `clockwise` or `counterclockwise`.",
                      "name": "winding",
                      "type": "Winding"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Enables or disables wireframe rendering.  This will draw all triangles as lines while active. It\u0027s intended to be used for debugging, since it usually has a performance cost.",
              "key": "Pass:setWireframe",
              "module": "lovr.graphics",
              "name": "setWireframe",
              "notes": "Wireframe rendering is disabled by default.\n\nThere is currently no way to change the thickness of the lines.",
              "related": ["Pass:setMeshMode", "Pass"],
              "summary": "Enable or disable wireframe rendering.",
              "tag": "pipeline",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "Whether wireframe rendering should be enabled.",
                      "name": "enable",
                      "type": "boolean"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Draws a skybox.",
              "key": "Pass:skybox",
              "module": "lovr.graphics",
              "name": "skybox",
              "notes": "The skybox will be rotated based on the camera rotation.\n\nThe skybox is drawn using a fullscreen triangle.\n\nThe skybox uses a custom shader, so set the shader to `nil` before calling this function (unless explicitly using a custom shader).",
              "related": ["Pass"],
              "summary": "Draw a skybox.",
              "tag": "drawing",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The skybox to render.  Its `TextureType` can be `cube` to render as a cubemap, or `2d` to render as an equirectangular (spherical) 2D image.",
                      "name": "skybox",
                      "type": "Texture"
                    }
                  ],
                  "returns": {}
                },
                { "arguments": {}, "returns": {} }
              ]
            },
            {
              "description": "Draws a sphere",
              "key": "Pass:sphere",
              "module": "lovr.graphics",
              "name": "sphere",
              "notes": "The local origin of the sphere is in its center.",
              "related": ["Pass"],
              "summary": "Draw a sphere.",
              "tag": "drawing",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "0",
                      "description": "The x coordinate of the center of the sphere.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The y coordinate of the center of the sphere.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z coordinate of the center of the sphere.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The radius of the sphere.",
                      "name": "radius",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The rotation of the sphere around its rotation axis, in radians.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    },
                    {
                      "default": "48",
                      "description": "The number of \"horizontal\" segments.",
                      "name": "longitudes",
                      "type": "number"
                    },
                    {
                      "default": "longitudes \/ 2",
                      "description": "The number of \"vertical\" segments.",
                      "name": "latitudes",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The position of the sphere.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "default": "1",
                      "description": "The radius of the sphere.",
                      "name": "radius",
                      "type": "number"
                    },
                    {
                      "description": "The orientation of the sphere.",
                      "name": "orientation",
                      "type": "Quat"
                    },
                    {
                      "default": "48",
                      "description": "The number of \"horizontal\" segments.",
                      "name": "longitudes",
                      "type": "number"
                    },
                    {
                      "default": "longitudes \/ 2",
                      "description": "The number of \"vertical\" segments.",
                      "name": "latitudes",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The transform of the sphere.",
                      "name": "transform",
                      "type": "Mat4"
                    },
                    {
                      "default": "48",
                      "description": "The number of \"horizontal\" segments.",
                      "name": "longitudes",
                      "type": "number"
                    },
                    {
                      "default": "longitudes \/ 2",
                      "description": "The number of \"vertical\" segments.",
                      "name": "latitudes",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Draws text.  The font can be changed using `Pass:setFont`.",
              "key": "Pass:text",
              "module": "lovr.graphics",
              "name": "text",
              "notes": "UTF-8 encoded strings are supported.\n\nNewlines will start a new line of text.  Tabs will be rendered as four spaces.  Carriage returns are ignored.\n\nWith the default font pixel density, a scale of 1.0 makes the text height 1 meter.\n\nThe wrap value does not take into account the text\u0027s scale.\n\nText rendering requires a special shader, which will only be automatically used when the active shader is set to `nil`.\n\nBlending should be enabled when rendering text (it\u0027s on by default).\n\nThis function can draw up to 16384 visible characters at a time, and will currently throw an error if the string is too long.",
              "related": [
                "Pass:setFont",
                "lovr.graphics.getDefaultFont",
                "Pass:setShader",
                "Font:getWidth",
                "Font:getHeight",
                "Font:getLines",
                "Font:getVertices",
                "Font",
                "Pass"
              ],
              "summary": "Draw text.",
              "tag": "drawing",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The text to render.",
                      "name": "text",
                      "type": "string"
                    },
                    {
                      "default": "0",
                      "description": "The x coordinate of the text origin.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The y coordinate of the text origin.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z coordinate of the text origin.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The scale of the text (with the default pixel density, units are meters).",
                      "name": "scale",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The rotation of the text around its rotation axis, in radians.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The maximum width of each line in meters (before scale is applied).  When zero, the text will not wrap.",
                      "name": "wrap",
                      "type": "number"
                    },
                    {
                      "default": "\u0027center\u0027",
                      "description": "The horizontal alignment relative to the text origin.",
                      "name": "halign",
                      "type": "HorizontalAlign"
                    },
                    {
                      "default": "\u0027middle\u0027",
                      "description": "The vertical alignment relative to the text origin.",
                      "name": "valign",
                      "type": "VerticalAlign"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The text to render.",
                      "name": "text",
                      "type": "string"
                    },
                    {
                      "description": "The position of the text.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "default": "1",
                      "description": "The scale of the text (with the default pixel density, units are meters).",
                      "name": "scale",
                      "type": "number"
                    },
                    {
                      "description": "The orientation of the text.",
                      "name": "orientation",
                      "type": "Quat"
                    },
                    {
                      "default": "0",
                      "description": "The maximum width of each line in meters (before scale is applied).  When zero, the text will not wrap.",
                      "name": "wrap",
                      "type": "number"
                    },
                    {
                      "default": "\u0027center\u0027",
                      "description": "The horizontal alignment relative to the text origin.",
                      "name": "halign",
                      "type": "HorizontalAlign"
                    },
                    {
                      "default": "\u0027middle\u0027",
                      "description": "The vertical alignment relative to the text origin.",
                      "name": "valign",
                      "type": "VerticalAlign"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The text to render.",
                      "name": "text",
                      "type": "string"
                    },
                    {
                      "description": "The transform of the text.",
                      "name": "transform",
                      "type": "Mat4"
                    },
                    {
                      "default": "0",
                      "description": "The maximum width of each line in meters (before scale is applied).  When zero, the text will not wrap.",
                      "name": "wrap",
                      "type": "number"
                    },
                    {
                      "default": "\u0027center\u0027",
                      "description": "The horizontal alignment relative to the text origin.",
                      "name": "halign",
                      "type": "HorizontalAlign"
                    },
                    {
                      "default": "\u0027middle\u0027",
                      "description": "The vertical alignment relative to the text origin.",
                      "name": "valign",
                      "type": "VerticalAlign"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "A table of strings with colors to render, in the form `{ color1, string1, color2, string2 }`, where color is a `Vec3`, `Vec4`, hexcode, or table of numbers.",
                      "name": "colortext",
                      "type": "table"
                    },
                    {
                      "default": "0",
                      "description": "The x coordinate of the text origin.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The y coordinate of the text origin.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z coordinate of the text origin.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The scale of the text (with the default pixel density, units are meters).",
                      "name": "scale",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The rotation of the text around its rotation axis, in radians.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The maximum width of each line in meters (before scale is applied).  When zero, the text will not wrap.",
                      "name": "wrap",
                      "type": "number"
                    },
                    {
                      "default": "\u0027center\u0027",
                      "description": "The horizontal alignment relative to the text origin.",
                      "name": "halign",
                      "type": "HorizontalAlign"
                    },
                    {
                      "default": "\u0027middle\u0027",
                      "description": "The vertical alignment relative to the text origin.",
                      "name": "valign",
                      "type": "VerticalAlign"
                    }
                  ],
                  "description": "Renders multicolor text.",
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "A table of strings with colors to render, in the form `{ color1, string1, color2, string2 }`, where color is a `Vec3`, `Vec4`, hexcode, or table of numbers.",
                      "name": "colortext",
                      "type": "table"
                    },
                    {
                      "description": "The position of the text.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "default": "1",
                      "description": "The scale of the text (with the default pixel density, units are meters).",
                      "name": "scale",
                      "type": "number"
                    },
                    {
                      "description": "The orientation of the text.",
                      "name": "orientation",
                      "type": "Quat"
                    },
                    {
                      "default": "0",
                      "description": "The maximum width of each line in meters (before scale is applied).  When zero, the text will not wrap.",
                      "name": "wrap",
                      "type": "number"
                    },
                    {
                      "default": "\u0027center\u0027",
                      "description": "The horizontal alignment relative to the text origin.",
                      "name": "halign",
                      "type": "HorizontalAlign"
                    },
                    {
                      "default": "\u0027middle\u0027",
                      "description": "The vertical alignment relative to the text origin.",
                      "name": "valign",
                      "type": "VerticalAlign"
                    }
                  ],
                  "description": "Renders multicolor text.",
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "A table of strings with colors to render, in the form `{ color1, string1, color2, string2 }`, where color is a `Vec3`, `Vec4`, hexcode, or table of numbers.",
                      "name": "colortext",
                      "type": "table"
                    },
                    {
                      "description": "The transform of the text.",
                      "name": "transform",
                      "type": "Mat4"
                    },
                    {
                      "default": "0",
                      "description": "The maximum width of each line in meters (before scale is applied).  When zero, the text will not wrap.",
                      "name": "wrap",
                      "type": "number"
                    },
                    {
                      "default": "\u0027center\u0027",
                      "description": "The horizontal alignment relative to the text origin.",
                      "name": "halign",
                      "type": "HorizontalAlign"
                    },
                    {
                      "default": "\u0027middle\u0027",
                      "description": "The vertical alignment relative to the text origin.",
                      "name": "valign",
                      "type": "VerticalAlign"
                    }
                  ],
                  "description": "Renders multicolor text.",
                  "returns": {}
                }
              ]
            },
            {
              "description": "Draws a torus.",
              "key": "Pass:torus",
              "module": "lovr.graphics",
              "name": "torus",
              "notes": "The local origin is in the center of the torus, and the torus forms a circle around the local Z axis.",
              "related": ["Pass"],
              "summary": "Draw a donut.",
              "tag": "drawing",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "0",
                      "description": "The x coordinate of the center of the torus.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The y coordinate of the center of the torus.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z coordinate of the center of the torus.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The radius of the torus.",
                      "name": "radius",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The thickness of the torus.",
                      "name": "thickness",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The rotation of the torus around its rotation axis, in radians.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    },
                    {
                      "default": "64",
                      "description": "The number of toroidal (circular) segments to render.",
                      "name": "tsegments",
                      "type": "number"
                    },
                    {
                      "default": "32",
                      "description": "The number of poloidal (tubular) segments to render.",
                      "name": "psegments",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The position of the center of the torus.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "description": "The size of the torus (x and y scale the radius, z is the thickness).",
                      "name": "scale",
                      "type": "Vec3"
                    },
                    {
                      "description": "The orientation of the torus.",
                      "name": "orientation",
                      "type": "Quat"
                    },
                    {
                      "default": "64",
                      "description": "The number of toroidal (circular) segments to render.",
                      "name": "tsegments",
                      "type": "number"
                    },
                    {
                      "default": "32",
                      "description": "The number of poloidal (tubular) segments to render.",
                      "name": "psegments",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The transform of the torus.",
                      "name": "transform",
                      "type": "Mat4"
                    },
                    {
                      "default": "64",
                      "description": "The number of toroidal (circular) segments to render.",
                      "name": "tsegments",
                      "type": "number"
                    },
                    {
                      "default": "32",
                      "description": "The number of poloidal (tubular) segments to render.",
                      "name": "psegments",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Transforms the coordinate system.",
              "key": "Pass:transform",
              "module": "lovr.graphics",
              "name": "transform",
              "related": [
                "Pass:translate",
                "Pass:rotate",
                "Pass:scale",
                "Pass:origin",
                "Pass:push",
                "Pass:pop",
                "Pass"
              ],
              "summary": "Apply a general transform to the coordinate system.",
              "tag": "transform",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The x component of the translation.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the translation.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the translation.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the scale.",
                      "name": "sx",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the scale.",
                      "name": "sy",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the scale.",
                      "name": "sz",
                      "type": "number"
                    },
                    {
                      "description": "The amount to rotate the coordinate system by, in radians.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    }
                  ],
                  "description": "Transform the coordinate system using numbers.",
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The translation to apply.",
                      "name": "translation",
                      "type": "Vec3"
                    },
                    {
                      "description": "The scale to apply.",
                      "name": "scale",
                      "type": "Vec3"
                    },
                    {
                      "description": "A quaternion containing the rotation to apply.",
                      "name": "rotation",
                      "type": "Quat"
                    }
                  ],
                  "description": "Transform the coordinate system using vector types.",
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "A matrix containing the transformation to apply.",
                      "name": "transform",
                      "type": "Mat4"
                    }
                  ],
                  "description": "Transform the coordinate system using a matrix.",
                  "returns": {}
                }
              ]
            },
            {
              "description": "Translates the coordinate system.",
              "key": "Pass:translate",
              "module": "lovr.graphics",
              "name": "translate",
              "notes": "Order matters when scaling, translating, and rotating the coordinate system.",
              "related": [
                "Pass:rotate",
                "Pass:scale",
                "Pass:transform",
                "Pass:origin",
                "Pass:push",
                "Pass:pop",
                "Pass"
              ],
              "summary": "Translate the coordinate system.",
              "tag": "transform",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The x component of the translation.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the translation.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the translation.",
                      "name": "z",
                      "type": "number"
                    }
                  ],
                  "description": "Translate the coordinate system using numbers.",
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The translation.",
                      "name": "translation",
                      "type": "Vec3"
                    }
                  ],
                  "description": "Translate the coordinate system using a vector.",
                  "returns": {}
                }
              ]
            }
          ],
          "module": "lovr.graphics",
          "name": "Pass",
          "related": ["lovr.graphics"],
          "sections": [
            {
              "description": "Draw objects and shapes.",
              "name": "Drawing",
              "tag": "drawing"
            },
            {
              "description": "Manipulate the 3D coordinate system.",
              "name": "Coordinate System",
              "tag": "transform"
            },
            {
              "description": "Set render states that change the way draws appear.  Render states can be saved and restored using `Pass:push` and `Pass:pop`.",
              "name": "Render States",
              "tag": "pipeline"
            },
            {
              "description": "Change the shader used for draws or computes, and set variables in the active shader.",
              "name": "Shaders",
              "tag": "shaders"
            },
            { "name": "Compute", "tag": "compute" },
            {
              "description": "Tallies count the number of pixels that were visible for a draw.",
              "name": "Tally",
              "tag": "tally"
            },
            { "name": "Camera", "tag": "camera" },
            { "name": "Canvas", "tag": "canvas" },
            { "name": "Miscellaneous", "tag": "pass-misc" }
          ],
          "summary": "A stream of graphics commands."
        },
        {
          "constructors": ["Buffer:newReadback", "Texture:newReadback"],
          "description": "Readbacks track the progress of an asynchronous read of a `Buffer` or `Texture`.  The Readback can be polled for completion or the CPU with `Readback:isComplete`, or you can wait for it to finish using `Readback:wait`.",
          "key": "Readback",
          "methods": [
            {
              "description": "Returns the Readback\u0027s data as a Blob.",
              "key": "Readback:getBlob",
              "module": "lovr.graphics",
              "name": "getBlob",
              "notes": "If the Readback is reading back a Texture, returns `nil`.",
              "related": ["Readback:getData", "Readback:getImage", "Readback"],
              "summary": "Get Readback\u0027s data as a Blob.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The Blob.",
                      "name": "blob",
                      "type": "Blob"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the data from the Readback, as a table.  See `Buffer:getData` for the way the table is structured.",
              "key": "Readback:getData",
              "module": "lovr.graphics",
              "name": "getData",
              "notes": "This returns `nil` for readbacks of `Texture` objects.",
              "related": ["Readback:getBlob", "Readback:getImage", "Readback"],
              "summary": "Get Readback\u0027s data as a table.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "A table containing the data that was read back.",
                      "name": "data",
                      "type": "table"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the Readback\u0027s data as an Image.",
              "key": "Readback:getImage",
              "module": "lovr.graphics",
              "name": "getImage",
              "notes": "If the Readback is not reading back a Texture, returns `nil`.",
              "related": ["Readback:getData", "Readback:getBlob", "Readback"],
              "summary": "Get Readback\u0027s data as an Image.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The Image.",
                      "name": "image",
                      "type": "Image"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns whether the Readback has completed on the GPU and its data is available.",
              "key": "Readback:isComplete",
              "module": "lovr.graphics",
              "name": "isComplete",
              "related": ["Readback"],
              "summary": "Check if a Readback is complete.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "Whether the readback is complete.",
                      "name": "complete",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Blocks the CPU until the Readback is finished on the GPU.",
              "key": "Readback:wait",
              "module": "lovr.graphics",
              "name": "wait",
              "notes": "If `lovr.graphics.submit` or `lovr.graphics.wait` has not been called since the readback was created, the readback has not been submitted yet, so no wait will occur and this function will return `false`.",
              "related": ["Readback"],
              "summary": "Wait for the Readback to finish.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "Whether the CPU had to be blocked for waiting.",
                      "name": "waited",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            }
          ],
          "module": "lovr.graphics",
          "name": "Readback",
          "related": ["lovr.graphics"],
          "summary": "An asynchronous read of a GPU resource."
        },
        {
          "constructors": ["lovr.graphics.newSampler"],
          "description": "Samplers are objects that control how pixels are read from a texture.  They can control whether the pixels are smoothed, whether the texture wraps at the edge of its UVs, and more.\n\nEach `Pass` has a default sampler that will be used by default, which can be changed using `Pass:setSampler`.  Also, samplers can be declared in shaders using the following syntax:\n\n    uniform sampler mySampler;\n\nA Sampler can be sent to the variable using `Pass:send(\u0027mySampler\u0027, sampler)`.\n\nThe properties of a Sampler are immutable, and can\u0027t be changed after it\u0027s created.",
          "key": "Sampler",
          "methods": [
            {
              "description": "Returns the anisotropy level of the Sampler.  Anisotropy smooths out a texture\u0027s appearance when viewed at grazing angles.",
              "key": "Sampler:getAnisotropy",
              "module": "lovr.graphics",
              "name": "getAnisotropy",
              "notes": "Not all GPUs support anisotropy.  The maximum anisotropy level is given by the `anisotropy` limit of `lovr.graphics.getLimits`, which may be zero.  It\u0027s very common for the maximum to be 16, however.",
              "related": [
                "Sampler:getFilter",
                "Sampler:getWrap",
                "Sampler:getCompareMode",
                "Sampler:getMipmapRange",
                "Sampler"
              ],
              "summary": "Get the anisotropy level of the Sampler.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The anisotropy level of the sampler.",
                      "name": "anisotropy",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the compare mode of the Sampler.  This is a feature typically only used for shadow mapping.  Using a sampler with a compare mode requires it to be declared in a shader as a `samplerShadow` instead of a `sampler` variable, and used with a texture that has a depth format.  The result of sampling a depth texture with a shadow sampler is a number between 0 and 1, indicating the percentage of sampled pixels that passed the comparison.",
              "key": "Sampler:getCompareMode",
              "module": "lovr.graphics",
              "name": "getCompareMode",
              "related": [
                "Sampler:getFilter",
                "Sampler:getWrap",
                "Sampler:getAnisotropy",
                "Sampler:getMipmapRange",
                "Sampler"
              ],
              "summary": "Get the compare mode of the Sampler.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The compare mode of the sampler.",
                      "name": "compare",
                      "type": "CompareMode"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the filter mode of the Sampler.",
              "key": "Sampler:getFilter",
              "module": "lovr.graphics",
              "name": "getFilter",
              "related": [
                "Sampler:getWrap",
                "Sampler:getCompareMode",
                "Sampler:getAnisotropy",
                "Sampler:getMipmapRange",
                "Sampler"
              ],
              "summary": "Get the filter mode of the Sampler.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The filter mode used when the texture is minified.",
                      "name": "min",
                      "type": "FilterMode"
                    },
                    {
                      "description": "The filter mode used when the texture is magnified.",
                      "name": "mag",
                      "type": "FilterMode"
                    },
                    {
                      "description": "The filter mode used to select a mipmap level.",
                      "name": "mip",
                      "type": "FilterMode"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the mipmap range of the Sampler.  This is used to clamp the range of mipmap levels that can be accessed from a texture.",
              "key": "Sampler:getMipmapRange",
              "module": "lovr.graphics",
              "name": "getMipmapRange",
              "related": [
                "Sampler:getFilter",
                "Sampler:getWrap",
                "Sampler:getCompareMode",
                "Sampler:getAnisotropy",
                "Sampler"
              ],
              "summary": "Get the mipmap range of the Sampler.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The minimum mipmap level that will be sampled (0 is the largest image).",
                      "name": "min",
                      "type": "number"
                    },
                    {
                      "description": "The maximum mipmap level that will be sampled.",
                      "name": "max",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the wrap mode of the sampler, used to wrap or clamp texture coordinates when the extend outside of the 0-1 range.",
              "key": "Sampler:getWrap",
              "module": "lovr.graphics",
              "name": "getWrap",
              "related": [
                "Sampler:getFilter",
                "Sampler:getCompareMode",
                "Sampler:getAnisotropy",
                "Sampler:getMipmapRange",
                "Sampler"
              ],
              "summary": "Get the wrap mode of the Sampler.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The wrap mode used in the horizontal direction.",
                      "name": "x",
                      "type": "WrapMode"
                    },
                    {
                      "description": "The wrap mode used in the vertical direction.",
                      "name": "y",
                      "type": "WrapMode"
                    },
                    {
                      "description": "The wrap mode used in the \"z\" direction, for 3D textures only.",
                      "name": "z",
                      "type": "WrapMode"
                    }
                  ]
                }
              ]
            }
          ],
          "module": "lovr.graphics",
          "name": "Sampler",
          "related": ["lovr.graphics"],
          "summary": "An object that controls how texture pixels are read."
        },
        {
          "constructors": ["lovr.graphics.newShader", "Shader:clone"],
          "description": "Shaders are small GPU programs.  See the `Shaders` guide for a full introduction to Shaders.",
          "key": "Shader",
          "methods": [
            {
              "description": "Clones a shader.  This creates an inexpensive copy of it with different flags.  It can be used to create several variants of a shader with different behavior.",
              "key": "Shader:clone",
              "module": "lovr.graphics",
              "name": "clone",
              "related": ["Shader"],
              "summary": "Clone a Shader.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The Shader to clone.",
                      "name": "source",
                      "type": "Shader"
                    },
                    {
                      "description": "The flags used by the clone.",
                      "name": "flags",
                      "type": "table"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The new Shader.",
                      "name": "shader",
                      "type": "Shader"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the format of a buffer declared in shader code.  The return type matches the same syntax used by `lovr.graphics.newBuffer` and `Buffer:getFormat`, so it can be used to quickly create a Buffer that matches a variable from a Shader.",
              "examples": [
                {
                  "code": "shader \u003d lovr.graphics.newShader([[\n  uniform Transforms {\n    mat4 transforms[32];\n  };\n\n  vec4 lovrmain() {\n    return Projection * View * transforms[InstanceIndex] * VertexPosition;\n  }\n]], \u0027unlit\u0027)\n\nlocal format, length \u003d shader:getBufferFormat(\u0027Transforms\u0027)\nprint(length) --\u003e 32\nprint(format[1].name) --\u003e \u0027transforms\u0027\nprint(format[1].type) --\u003e \u0027mat4\u0027\n\n-- Can pass the 2 results directly to newBuffer:\ntransforms \u003d lovr.graphics.newBuffer(shader:getBufferFormat(\u0027Transforms\u0027))\n\n-- Or override the length with some initial data:\ntransforms \u003d lovr.graphics.newBuffer(shader:getBufferFormat(\u0027Transforms\u0027), objects)"
                }
              ],
              "key": "Shader:getBufferFormat",
              "module": "lovr.graphics",
              "name": "getBufferFormat",
              "notes": "If the buffer only has a single array field, the format will be \"unwrapped\" to an array instead of a single-field struct with an array in it.  Example:\n\n    shader \u003d lovr.graphics.newShader([[\n      buffer Numbers {\n        uint numbers[64];\n      };\n\n      void lovrmain(){}\n    ]])\n\n    shader:getBufferFormat(\u0027Numbers\u0027)\n    -- returns {{ name \u003d \u0027numbers\u0027, type \u003d \u0027u32\u0027 }}, 64\n    -- not     {{ name \u003d \u0027numbers\u0027, type \u003d \u0027u32\u0027, length \u003d 64 }}, 1\n\nSimilarly, if the buffer only has a single struct field, the format will be \"unwrapped\" to the inner struct.  This lets you use a struct for a Buffer\u0027s data without having to wrap everything in an extra namespace.  Example:\n\n    shader \u003d lovr.graphics.newShader([[\n      struct HandParams {\n        vec3 pos;\n        float grip;\n      };\n\n      buffer Hand {\n        HandParams params;\n      };\n\n      void lovrmain(){}\n    ]])\n\n    shader:getBufferFormat(\u0027Hand\u0027)\n    -- returns {{ name \u003d \u0027pos\u0027, type \u003d \u0027vec3\u0027 }, { name \u003d \u0027grip\u0027, type \u003d \u0027float\u0027 }}, 1\n    -- not     {{ name \u003d \u0027params\u0027, type \u003d {...}}}, 1",
              "related": [
                "lovr.graphics.newBuffer",
                "Buffer:getFormat",
                "Shader"
              ],
              "summary": "Get the format of a buffer in the Shader.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The name of the buffer variable to return the format of.",
                      "name": "name",
                      "type": "string"
                    }
                  ],
                  "returns": [
                    {
                      "description": "A list of fields that match the type declaration of the buffer in the shader code.  Each field has `name`, `type`, and `offset` keys.  If the field is an array, it will have `length` and `stride` keys as well.  The top-level table also has a `stride` key.  Offsets and strides are in bytes.",
                      "name": "format",
                      "type": "table"
                    },
                    {
                      "description": "The number of items in the buffer (or 1 if the buffer is not an array).",
                      "name": "length",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the debug label of the Shader, which will show up when the Shader is printed and in some graphics debugging tools.  This is set when the Shader is created, and can\u0027t be changed afterwards.",
              "key": "Shader:getLabel",
              "module": "lovr.graphics",
              "name": "getLabel",
              "related": [
                "lovr.graphics.newShader",
                "Texture:getLabel",
                "Pass:getLabel",
                "Shader"
              ],
              "summary": "Get the debug label of the Shader.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The label, or nil if none was set.",
                      "name": "label",
                      "type": "string"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns whether the shader is a graphics or compute shader.",
              "key": "Shader:getType",
              "module": "lovr.graphics",
              "name": "getType",
              "related": [
                "Shader:hasStage",
                "lovr.graphics.newShader",
                "Shader"
              ],
              "summary": "Get the type of the Shader.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The type of the Shader.",
                      "name": "type",
                      "type": "ShaderType"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the workgroup size of a compute shader.  The workgroup size defines how many times a compute shader is invoked for each workgroup dispatched by `Pass:compute`.",
              "key": "Shader:getWorkgroupSize",
              "module": "lovr.graphics",
              "name": "getWorkgroupSize",
              "notes": "For example, if the workgroup size is `8x8x1` and `16x16x16` workgroups are dispatched, then the compute shader will run `16 * 16 * 16 * (8 * 8 * 1) \u003d 262144` times.\n\nThe maximum workgroup size is hardware-specific, and is given by the `workgroupSize` and `totalWorkgroupSize` limit in `lovr.graphics.getLimits`.",
              "related": ["Pass:compute", "lovr.graphics.getLimits", "Shader"],
              "summary": "Get the workgroup size of a compute shader.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The x size of a workgroup.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y size of a workgroup.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z size of a workgroup.",
                      "name": "z",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns whether the Shader has a vertex attribute, by name or location.",
              "examples": [
                {
                  "code": "function lovr.load()\n  shader \u003d lovr.graphics.newShader([[\n    in uint coolAttribute;\n\n    vec4 lovrmain() {\n      return DefaultPosition;\n    }\n  ]], [[\n    vec4 lovrmain() {\n      return DefaultColor;\n    }\n  ]])\n\n  print(shader:hasAttribute(\u0027coolAttribute\u0027)) --\u003e true\nend"
                }
              ],
              "key": "Shader:hasAttribute",
              "module": "lovr.graphics",
              "name": "hasAttribute",
              "related": ["Shader"],
              "summary": "Check if the Shader has a given vertex attribute.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The name of an attribute.",
                      "name": "name",
                      "type": "string"
                    }
                  ],
                  "returns": [
                    {
                      "description": "Whether the Shader has the attribute.",
                      "name": "exists",
                      "type": "boolean"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The location of an attribute.",
                      "name": "location",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "Whether the Shader has the attribute.",
                      "name": "exists",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns whether the Shader has a given stage.",
              "key": "Shader:hasStage",
              "module": "lovr.graphics",
              "name": "hasStage",
              "related": ["Shader:getType", "Shader"],
              "summary": "Check if the Shader has a given stage.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The stage.",
                      "name": "stage",
                      "type": "ShaderStage"
                    }
                  ],
                  "returns": [
                    {
                      "description": "Whether the Shader has the stage.",
                      "name": "exists",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns whether the Shader has a variable.",
              "examples": [
                {
                  "code": "for key, texture in pairs(textures) do\n  if shader:hasVariable(key) then\n    pass:send(key, texture)\n  end\nend"
                }
              ],
              "key": "Shader:hasVariable",
              "module": "lovr.graphics",
              "name": "hasVariable",
              "notes": "This will return true if the variable is a buffer, texture, sampler, or other uniform variable (anything that can be sent with `Pass:send`).",
              "related": ["Pass:send", "Shader"],
              "summary": "Check if the Shader has a variable.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The name of the variable to check.",
                      "name": "name",
                      "type": "string"
                    }
                  ],
                  "returns": [
                    {
                      "description": "Whether the Shader has the variable.",
                      "name": "exists",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            }
          ],
          "module": "lovr.graphics",
          "name": "Shader",
          "related": ["lovr.graphics"],
          "summary": "GPU program."
        },
        {
          "constructors": [
            "lovr.graphics.newTexture",
            "lovr.graphics.newTextureView"
          ],
          "description": "Textures are multidimensional blocks of memory on the GPU, contrasted with `Buffer` objects which are one-dimensional.  Textures are used as the destination for rendering operations, and textures loaded from images provide surface data to `Material` objects.",
          "key": "Texture",
          "methods": [
            {
              "description": "Clears layers and mipmaps in a texture to a given color.\n\nWhen a Texture is being used as a canvas for a `Pass`, the clear color can be set with `Pass:setClear`, which a more efficient way to clear the texture before rendering.",
              "key": "Texture:clear",
              "module": "lovr.graphics",
              "name": "clear",
              "notes": "The texture must have been created with the `transfer` usage to clear it.\n\nThe clear color will be interpreted as a linear color for sRGB formats.",
              "related": [
                "Buffer:clear",
                "Texture:setPixels",
                "Pass:setClear",
                "Texture"
              ],
              "summary": "Clear the Texture to a color.",
              "tag": "texture-transfer",
              "variants": [
                {
                  "arguments": {},
                  "description": "Clear the whole texture to zero (transparent black).",
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The hexcode color to clear to.",
                      "name": "hex",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The index of the first layer to clear.",
                      "name": "layer",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "The number of layers to clear.  If nil, clears the rest of the layers.",
                      "name": "layerCount",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The index of the first mipmap to clear.",
                      "name": "mipmap",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "The number of mipmaps to clear.  If nil, clears the rest of the mipmaps.",
                      "name": "mipmapCount",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The red component of the clear color.",
                      "name": "r",
                      "type": "number"
                    },
                    {
                      "description": "The green component of the clear color.",
                      "name": "g",
                      "type": "number"
                    },
                    {
                      "description": "The blue component of the clear color.",
                      "name": "b",
                      "type": "number"
                    },
                    {
                      "description": "The alpha component of the clear color.",
                      "name": "a",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The index of the first layer to clear.",
                      "name": "layer",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "The number of layers to clear.  If nil, clears the rest of the layers.",
                      "name": "layerCount",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The index of the first mipmap to clear.",
                      "name": "mipmap",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "The number of mipmaps to clear.  If nil, clears the rest of the mipmaps.",
                      "name": "mipmapCount",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "A table with color components.",
                      "name": "t",
                      "type": "table"
                    },
                    {
                      "default": "1",
                      "description": "The index of the first layer to clear.",
                      "name": "layer",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "The number of layers to clear.  If nil, clears the rest of the layers.",
                      "name": "layerCount",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The index of the first mipmap to clear.",
                      "name": "mipmap",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "The number of mipmaps to clear.  If nil, clears the rest of the mipmaps.",
                      "name": "mipmapCount",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "A vec3 with the clear color.",
                      "name": "v3",
                      "type": "Vec3"
                    },
                    {
                      "default": "1",
                      "description": "The index of the first layer to clear.",
                      "name": "layer",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "The number of layers to clear.  If nil, clears the rest of the layers.",
                      "name": "layerCount",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The index of the first mipmap to clear.",
                      "name": "mipmap",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "The number of mipmaps to clear.  If nil, clears the rest of the mipmaps.",
                      "name": "mipmapCount",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "A vec4 with the clear color.",
                      "name": "v4",
                      "type": "Vec4"
                    },
                    {
                      "default": "1",
                      "description": "The index of the first layer to clear.",
                      "name": "layer",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "The number of layers to clear.  If nil, clears the rest of the layers.",
                      "name": "layerCount",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The index of the first mipmap to clear.",
                      "name": "mipmap",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "The number of mipmaps to clear.  If nil, clears the rest of the mipmaps.",
                      "name": "mipmapCount",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Regenerates mipmap levels of a texture.  This downscales pixels from the texture to progressively smaller sizes and saves them.  If the texture is drawn at a smaller scale later, the mipmaps are used, which smooths out the appearance and improves performance.",
              "key": "Texture:generateMipmaps",
              "module": "lovr.graphics",
              "name": "generateMipmaps",
              "notes": "Mipmaps will automatically be regenerated for textures after rendering to them in a `Pass`. This can be disabled by rendering to a single-level texture view instead.\n\nThe texture must have been created with the `transfer` usage to mipmap it.\n\nThe texture can not be multisampled.\n\nTexture views can not currently be mipmapped.",
              "related": [
                "Texture:setPixels",
                "Texture:getMipmapCount",
                "Texture"
              ],
              "summary": "Regenerate mipmaps for a Texture.",
              "tag": "texture-transfer",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "1",
                      "description": "The base mipmap level which will be used to generate subsequent mipmaps.",
                      "name": "base",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "The number of mipmap levels to generate.  If nil, the rest of the mipmaps will be generated.",
                      "name": "count",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Returns the width, height, and depth of the Texture.",
              "key": "Texture:getDimensions",
              "module": "lovr.graphics",
              "name": "getDimensions",
              "related": [
                "Texture:getWidth",
                "Texture:getHeight",
                "Texture:getLayerCount",
                "Texture"
              ],
              "summary": "Get the dimensions of the Texture.",
              "tag": "texture-metadata",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The width of the Texture.",
                      "name": "width",
                      "type": "number"
                    },
                    {
                      "description": "The height of the Texture.",
                      "name": "height",
                      "type": "number"
                    },
                    {
                      "description": "The number of layers in the Texture.",
                      "name": "layers",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the format of the texture.",
              "key": "Texture:getFormat",
              "module": "lovr.graphics",
              "name": "getFormat",
              "related": ["Texture"],
              "summary": "Get the format of the Texture.",
              "tag": "texture-metadata",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The format of the Texture.",
                      "name": "format",
                      "type": "TextureFormat"
                    },
                    {
                      "description": "Whether the format is linear or srgb.",
                      "name": "linear",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the height of the Texture, in pixels.",
              "key": "Texture:getHeight",
              "module": "lovr.graphics",
              "name": "getHeight",
              "related": [
                "Texture:getWidth",
                "Texture:getLayerCount",
                "Texture:getDimensions",
                "Texture"
              ],
              "summary": "Get the height of the Texture, in pixels.",
              "tag": "texture-metadata",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The height of the Texture, in pixels.",
                      "name": "height",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the debug label of the Texture, which will show up when the Texture is printed and in some graphics debugging tools.  This is set when the Texture is created, and can\u0027t be changed afterwards.",
              "key": "Texture:getLabel",
              "module": "lovr.graphics",
              "name": "getLabel",
              "related": [
                "lovr.graphics.newTexture",
                "Shader:getLabel",
                "Pass:getLabel",
                "Texture"
              ],
              "summary": "Get the debug label of the Texture.",
              "tag": "texture-metadata",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The label, or nil if none was set.",
                      "name": "label",
                      "type": "string"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the layer count of the Texture.  2D textures always have 1 layer and cubemaps always have a layer count divisible by 6.  3D and array textures have a variable number of layers.",
              "key": "Texture:getLayerCount",
              "module": "lovr.graphics",
              "name": "getLayerCount",
              "related": [
                "Texture:getWidth",
                "Texture:getHeight",
                "Texture:getDimensions",
                "Texture"
              ],
              "summary": "Get the layer count of the Texture.",
              "tag": "texture-metadata",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The layer count of the Texture.",
                      "name": "layers",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the number of mipmap levels in the Texture.",
              "key": "Texture:getMipmapCount",
              "module": "lovr.graphics",
              "name": "getMipmapCount",
              "related": [
                "lovr.graphics.newTexture",
                "Sampler:getMipmapRange",
                "Texture:generateMipmaps",
                "Texture"
              ],
              "summary": "Get the number of mipmap levels in the Texture.",
              "tag": "texture-metadata",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The number of mipmap levels in the Texture.",
                      "name": "mipmaps",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Creates and returns a new `Image` object with the current pixels of the Texture.  This function is very very slow because it stalls the CPU until the download is complete.  It should only be used for debugging, non-interactive scripts, etc.  For an asynchronous version that doesn\u0027t stall the CPU, see `Texture:newReadback`.",
              "key": "Texture:getPixels",
              "module": "lovr.graphics",
              "name": "getPixels",
              "notes": "The texture must have been created with the `transfer` usage.\n\nMultisampled textures can not be read back.\n\nIt is not currently possible to read back a texture view.",
              "related": [
                "Texture:newReadback",
                "Texture:setPixels",
                "Texture"
              ],
              "summary": "Get the pixels of the Texture.",
              "tag": "texture-transfer",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "0",
                      "description": "The x offset of the region to download.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The y offset of the region to download.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The index of the layer to download.",
                      "name": "layer",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The index of the mipmap level to download.",
                      "name": "mipmap",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "The width of the pixel rectangle to download.  If nil, the \"rest\" of the width will be used, based on the texture width and x offset.",
                      "name": "width",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "The height of the pixel rectangle to download.  If nil, the \"rest\" of the height will be used, based on the texture height and y offset.",
                      "name": "height",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The new image with the pixels.",
                      "name": "image",
                      "type": "Image"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the number of samples in the texture.  Multiple samples are used for multisample antialiasing when rendering to the texture.  Currently, the sample count is either 1 (not antialiased) or 4 (antialiased).",
              "key": "Texture:getSampleCount",
              "module": "lovr.graphics",
              "name": "getSampleCount",
              "related": [
                "lovr.graphics.newTexture",
                "Pass:setCanvas",
                "Texture"
              ],
              "summary": "Get the number of MSAA samples in the Texture.",
              "tag": "texture-metadata",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The number of samples in the Texture.",
                      "name": "samples",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the Sampler object previously assigned with `Texture:setSampler`.\n\nThis API is experimental, and subject to change in the future!",
              "key": "Texture:getSampler",
              "module": "lovr.graphics",
              "name": "getSampler",
              "related": ["Texture:setSampler", "Texture"],
              "summary": "Get the Sampler assigned to the Texture.",
              "tag": "texture-sampler",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The Sampler object.",
                      "name": "sampler",
                      "type": "Sampler"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the type of the texture.",
              "key": "Texture:getType",
              "module": "lovr.graphics",
              "name": "getType",
              "related": ["Texture"],
              "summary": "Get the type of the Texture.",
              "tag": "texture-metadata",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The type of the Texture.",
                      "name": "type",
                      "type": "TextureType"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the width of the Texture, in pixels.",
              "key": "Texture:getWidth",
              "module": "lovr.graphics",
              "name": "getWidth",
              "related": [
                "Texture:getHeight",
                "Texture:getLayerCount",
                "Texture:getDimensions",
                "Texture"
              ],
              "summary": "Get the width of the Texture, in pixels.",
              "tag": "texture-metadata",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The width of the Texture, in pixels.",
                      "name": "width",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns whether a Texture was created with a set of `TextureUsage` flags.  Usage flags are specified when the Texture is created, and restrict what you can do with a Texture object.  By default, only the `sample` usage is enabled.  Applying a smaller set of usage flags helps L\u00d6VR optimize things better.",
              "key": "Texture:hasUsage",
              "module": "lovr.graphics",
              "name": "hasUsage",
              "related": ["lovr.graphics.newTexture", "Texture"],
              "summary": "Check if a Texture was created with a set of usage flags.",
              "tag": "texture-metadata",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "One or more usage flags.",
                      "name": "...",
                      "type": "TextureUsage"
                    }
                  ],
                  "returns": [
                    {
                      "description": "Whether the Texture has all the provided usage flags.",
                      "name": "supported",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Creates and returns a new `Readback` that will download the pixels in the Texture from VRAM. Once the readback is complete, `Readback:getImage` returns an `Image` with a CPU copy of the data.",
              "examples": [
                {
                  "code": "local screenshot \u003d false\nlocal readback\nlocal texture\nlocal pass\n\nfunction lovr.keypressed(key)\n  if key \u003d\u003d \u0027p\u0027 then screenshot \u003d true end\nend\n\nfunction lovr.load()\n  local width, height \u003d lovr.headset.getDisplayDimensions()\n\n  texture \u003d lovr.graphics.newTexture(width, height, {\n    usage \u003d { \u0027render\u0027, \u0027transfer\u0027, \u0027sample\u0027 }\n  })\n\n  pass \u003d lovr.graphics.newPass(texture)\nend\n\nfunction lovr.update()\n  pass:reset()\n  for i \u003d 1, lovr.headset.getViewCount() do\n    pass:setViewPose(i, lovr.headset.getViewPose(i))\n    pass:setProjection(i, lovr.headset.getViewAngles(i))\n  end\n  pass:text(\u0027hellooo\u0027, 0, 1.7, -1, .1)\n  lovr.graphics.submit(pass)\n\n  if screenshot and not readback then\n    readback \u003d texture:newReadback()\n    screenshot \u003d false\n  end\n\n  if readback and readback:isComplete() then\n    local filename \u003d \u0027screenshot.png\u0027\n    lovr.filesystem.write(filename, readback:getImage():encode())\n    print(\u0027saved screenshot to \u0027 .. filename)\n    readback \u003d nil\n  end\nend\n\nfunction lovr.draw(p)\n  p:fill(texture)\nend",
                  "description": "Take a screenshot when pressing a key.  This uses an intermediate texture and render pass, to work around the fact that the window\/headset textures don\u0027t support transfers."
                }
              ],
              "key": "Texture:newReadback",
              "module": "lovr.graphics",
              "name": "newReadback",
              "notes": "The texture must have been created with the `transfer` usage.\n\nMultisampled textures can not be read back.\n\nIt is not currently possible to read back a texture view.",
              "related": ["Texture:getPixels", "Buffer:newReadback", "Texture"],
              "summary": "Read back the contents of the Texture asynchronously.",
              "tag": "texture-transfer",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "0",
                      "description": "The x offset of the region to download.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The y offset of the region to download.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The index of the layer to download.",
                      "name": "layer",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The index of the mipmap level to download.",
                      "name": "mipmap",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "The width of the pixel rectangle to download.  If nil, the \"rest\" of the width will be used, based on the texture width and x offset.",
                      "name": "width",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "The height of the pixel rectangle to download.  If nil, the \"rest\" of the height will be used, based on the texture height and y offset.",
                      "name": "height",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "A new Readback object.",
                      "name": "readback",
                      "type": "Readback"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Sets pixels in the texture.  The source data can be an `Image` with the pixels to upload, or another `Texture` object to copy from.",
              "key": "Texture:setPixels",
              "module": "lovr.graphics",
              "name": "setPixels",
              "notes": "Note that calling `Texture:setPixels(Image)` will only update the first mipmap of the texture, leaving the other mipmaps as-is.  You may want to regenerate the texture\u0027s mipmaps afterwards by calling `Texture:generateMipmaps`, or disable mipmaps entirely by setting `mipmaps` to false in `lovr.graphics.newTexture`.\n\nThe destination and source textures must have been created with the `transfer` usage.\n\nImages can\u0027t be copied to multisample textures.  Multisample textures can be copied between each other as long as there isn\u0027t any scaling.\n\nCopying between textures requires them to have the same format.\n\nWhen using different region sizes in a texture-to-texture copy:\n\n- It is not possible to mix 3D with non-3D textures.\n- Not every texture format is supported, use `lovr.graphics.isFormatSupported` to check.\n- The formats do not need to match, unless they\u0027re depth formats.",
              "related": [
                "Texture:newReadback",
                "Texture:generateMipmaps",
                "Image:paste",
                "Texture:getPixels",
                "Texture"
              ],
              "summary": "Replace pixels in the Texture.",
              "tag": "texture-transfer",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The image to copy to the texture.",
                      "name": "image",
                      "type": "Image"
                    },
                    {
                      "default": "0",
                      "description": "The x offset to copy to.",
                      "name": "dstx",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The y offset to copy to.",
                      "name": "dsty",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The index of the layer to copy to.",
                      "name": "dstlayer",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The index of the mipmap level to copy to.",
                      "name": "dstmipmap",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The x offset to copy from.",
                      "name": "srcx",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The y offset to copy from.",
                      "name": "srcy",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The index of the layer to copy from.",
                      "name": "srclayer",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The index of the mipmap level to copy from.",
                      "name": "srcmipmap",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "The width of the region of pixels to copy.  If nil, the maximum possible width will be used, based on the widths of the source\/destination and the offset parameters.",
                      "name": "width",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "The height of the region of pixels to copy.  If nil, the maximum possible height will be used, based on the heights of the source\/destination and the offset parameters.",
                      "name": "height",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "The number of layers to copy.  If nil, copies as many layers as possible.",
                      "name": "layers",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The texture to copy from.",
                      "name": "texture",
                      "type": "Texture"
                    },
                    {
                      "default": "0",
                      "description": "The x offset to copy to.",
                      "name": "dstx",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The y offset to copy to.",
                      "name": "dsty",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The index of the layer to copy to.",
                      "name": "dstlayer",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The index of the mipmap level to copy to.",
                      "name": "dstmipmap",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The x offset to copy from.",
                      "name": "srcx",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The y offset to copy from.",
                      "name": "srcy",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The index of the layer to copy from.",
                      "name": "srclayer",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The index of the mipmap level to copy from.",
                      "name": "srcmipmap",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "The width of the region of pixels to copy.  If nil, the maximum possible width will be used, based on the widths of the source\/destination and the offset parameters.",
                      "name": "width",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "The height of the region of pixels to copy.  If nil, the maximum possible height will be used, based on the heights of the source\/destination and the offset parameters.",
                      "name": "height",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "The number of layers to copy.  If nil, copies as many layers as possible.",
                      "name": "layers",
                      "type": "number"
                    },
                    {
                      "default": "width",
                      "description": "The width of the region in the source texture to copy.  If it doesn\u0027t match `width`, the copy will be scaled up or down to fit.",
                      "name": "srcwidth",
                      "type": "number"
                    },
                    {
                      "default": "width",
                      "description": "The height of the region in the source texture to copy.  If it doesn\u0027t match `height`, the copy will be scaled up or down to fit.",
                      "name": "srcheight",
                      "type": "number"
                    },
                    {
                      "default": "layers",
                      "description": "The depth of the region in the source texture to copy (`3d` textures only).",
                      "name": "srcdepth",
                      "type": "number"
                    },
                    {
                      "default": "\u0027linear\u0027",
                      "description": "The filtering mode used to scale the copy when the source and destination sizes don\u0027t match.",
                      "name": "filter",
                      "type": "FilterMode"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets sampler settings for the texture.  This can either be a `FilterMode` like `nearest`, or a `Sampler` object, which allows configuring all of the filtering and wrapping settings.\n\nThere are other ways of using custom samplers for a texture, but they have disadvantages:\n\n- `Sampler` objects can be sent to shaders and used to sample from the texture, but this\n  requires writing custom shader code and sending sampler objects with `Pass:send`, which is\n  inconvenient.\n- `Pass:setSampler` exists, but it applies to all textures in all draws in the Pass.  It doesn\u0027t\n  allow for changing filtering settings on a per-texture basis.\n\nThis API is experimental, and subject to change in the future!",
              "key": "Texture:setSampler",
              "module": "lovr.graphics",
              "name": "setSampler",
              "related": ["Texture:getSampler", "Texture"],
              "summary": "Set sampler settings for the Texture.",
              "tag": "texture-sampler",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The FilterMode shaders will use when reading pixels from the texture.",
                      "name": "mode",
                      "type": "FilterMode"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The Sampler object shaders will use when reading pixels from the texture.",
                      "name": "sampler",
                      "type": "Sampler"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": {},
                  "description": "Remove the texture\u0027s sampler, instead using the one set by `Pass:setSampler`.",
                  "returns": {}
                }
              ]
            }
          ],
          "module": "lovr.graphics",
          "name": "Texture",
          "related": ["lovr.graphics"],
          "sections": [
            { "name": "Metadata", "tag": "texture-metadata" },
            { "name": "Transfers", "tag": "texture-transfer" },
            { "name": "Sampler", "tag": "texture-sampler" }
          ],
          "summary": "A multidimensional block of memory on the GPU."
        }
      ],
      "sections": [
        { "name": "Objects", "tag": "graphics-objects" },
        { "name": "Global State", "tag": "graphics-global" },
        {
          "description": "The only way to get the GPU to do anything is to submit `Pass` objects to it.  L\u00d6VR submits the default pass automatically at the end of `lovr.draw`, but work can also be submitted manually.",
          "name": "Work Submission",
          "tag": "work-submission"
        },
        {
          "description": "Information about the GPU hardware and the features it supports.",
          "name": "System Info",
          "tag": "graphics-misc"
        }
      ],
      "summary": "Renders graphics using the GPU.",
      "tag": "modules"
    },
    {
      "description": "The `lovr.headset` module is where all the magical VR functionality is.  With it, you can access connected VR hardware and get information about the available space the player has.  Note that all units are reported in meters.  Position `(0, 0, 0)` is on the floor in the center of the play area.",
      "enums": [
        {
          "description": "Different types of input devices supported by the `lovr.headset` module.",
          "key": "Device",
          "module": "lovr.headset",
          "name": "Device",
          "notes": "The `grip` pose is used to render an object held in the user\u0027s hand.  It\u0027s positioned at the surface of the palm.  The X axis of the grip orientation is perpendicular to the palm, pointing away from the left palm or into the right palm.  If you imagine the hand holding a stick, the Z axis will be parallel to the stick.\n\n\u003cimg src\u003d\"\/img\/grip.svg\" width\u003d\"600\" alt\u003d\"Hand Grip Pose\" class\u003d\"flat\"\/\u003e\n\n*Image from the [OpenXR Specification](https:\/\/registry.khronos.org\/OpenXR\/specs\/1.0\/html\/xrspec.html#_grip_pose)*\n\n---\n\nThe `point` pose is used to aim or point at objects.  It\u0027s usually positioned slightly in front of the hand or controller, and is oriented so the -Z axis points in a natural forward direction.\n\n\u003cimg src\u003d\"\/img\/aim.svg\" width\u003d\"600\" alt\u003d\"Hand Point Pose\" class\u003d\"flat\"\/\u003e\n\n*Image from the [OpenXR Specification](https:\/\/registry.khronos.org\/OpenXR\/specs\/1.0\/html\/xrspec.html#_aim_pose)*\n\n---\n\nThe `pinch` pose is a stable point between the thumb and index finger on a hand, or a point slightly in front of a controller.  The -Z axis will point forward, away from the hand.  It\u0027s good for precise, close-range interaction.\n\n\u003cimg src\u003d\"\/img\/pinch.svg\" width\u003d\"600\" alt\u003d\"Hand Pinch Pose\" class\u003d\"flat\"\/\u003e\n\n*Image from the [OpenXR Specification](https:\/\/registry.khronos.org\/OpenXR\/specs\/1.0\/html\/xrspec.html#_pinch_pose)*\n\n---\n\nThe `poke` pose is a position located at the tip of the index finger, or a point slightly in front of a controller.  The -Z axis will point forward out of the tip of the finger, the +Y axis will be perpendicular to the fingernail.\n\n\u003cimg src\u003d\"\/img\/poke.svg\" width\u003d\"600\" alt\u003d\"Hand Poke Pose\" class\u003d\"flat\"\/\u003e\n\n*Image from the [OpenXR Specification](https:\/\/registry.khronos.org\/OpenXR\/specs\/1.0\/html\/xrspec.html#_poke_pose)*\n\n---\n\nThese \"hand pose devices\" do not report any button input with e.g. `lovr.headset.isDown`.  The main `hand\/left` and `hand\/right` devices should be used for buttons and haptics.",
          "related": [
            "DeviceAxis",
            "DeviceButton",
            "lovr.headset.getPose",
            "lovr.headset.getPosition",
            "lovr.headset.getOrientation",
            "lovr.headset.getVelocity",
            "lovr.headset.getAngularVelocity",
            "lovr.headset.getSkeleton",
            "lovr.headset.isTracked",
            "lovr.headset.isDown",
            "lovr.headset.isTouched",
            "lovr.headset.wasPressed",
            "lovr.headset.wasReleased",
            "lovr.headset.getAxis",
            "lovr.headset.vibrate",
            "lovr.headset.animate",
            "lovr.headset"
          ],
          "summary": "Different types of input devices supported by the `lovr.headset` module.",
          "values": [
            { "description": "The headset.", "name": "head" },
            {
              "description": "A device representing the floor, at the center of the play area.  The pose of this device in physical space will remain constant, even after recentering.",
              "name": "floor"
            },
            { "description": "A shorthand for hand\/left.", "name": "left" },
            { "description": "A shorthand for hand\/right.", "name": "right" },
            { "description": "The left hand.", "name": "hand\/left" },
            { "description": "The right hand.", "name": "hand\/right" },
            {
              "description": "The left hand grip pose, used for held objects.",
              "name": "hand\/left\/grip"
            },
            {
              "description": "The right hand grip pose, used for held objects.",
              "name": "hand\/right\/grip"
            },
            {
              "description": "The left hand pointer pose, used for pointing or aiming.",
              "name": "hand\/left\/point"
            },
            {
              "description": "The right hand pointer pose, used for pointing or aiming.",
              "name": "hand\/right\/point"
            },
            {
              "description": "The left hand pinch pose between the thumb and index fingers, used for precise, close-range interactions.",
              "name": "hand\/left\/pinch"
            },
            {
              "description": "The right hand pinch pose between the thumb and index fingers, used for precise, close-range interactions.",
              "name": "hand\/right\/pinch"
            },
            {
              "description": "The left hand poke pose, on the tip of the index finger or in front of a controller.",
              "name": "hand\/left\/poke"
            },
            {
              "description": "The right hand poke pose, on the tip of the index finger or in front of a controller.",
              "name": "hand\/right\/poke"
            },
            {
              "description": "A device tracking the left elbow.",
              "name": "elbow\/left"
            },
            {
              "description": "A device tracking the right elbow.",
              "name": "elbow\/right"
            },
            {
              "description": "A device tracking the left shoulder.",
              "name": "shoulder\/left"
            },
            {
              "description": "A device tracking the right shoulder.",
              "name": "shoulder\/right"
            },
            { "description": "A device tracking the chest.", "name": "chest" },
            { "description": "A device tracking the waist.", "name": "waist" },
            {
              "description": "A device tracking the left knee.",
              "name": "knee\/left"
            },
            {
              "description": "A device tracking the right knee.",
              "name": "knee\/right"
            },
            {
              "description": "A device tracking the left foot or ankle.",
              "name": "foot\/left"
            },
            {
              "description": "A device tracking the right foot or ankle.",
              "name": "foot\/right"
            },
            {
              "description": "A camera device, often used for recording \"mixed reality\" footage.",
              "name": "camera"
            },
            { "description": "A tracked keyboard.", "name": "keyboard" },
            { "description": "A tracked pen or pointer.", "name": "stylus" },
            { "description": "The left eye.", "name": "eye\/left" },
            { "description": "The right eye.", "name": "eye\/right" },
            {
              "description": "The combined eye gaze pose.  The position is between the eyes.  The orientation aligns the\n-Z axis in the direction the user is looking and the +Y axis to the head\u0027s \"up\" vector. This provides more accurate eye tracking information compared to using the individual eye devices.",
              "name": "eye\/gaze"
            }
          ]
        },
        {
          "description": "Axes on an input device.",
          "key": "DeviceAxis",
          "module": "lovr.headset",
          "name": "DeviceAxis",
          "related": ["lovr.headset.getAxis", "DeviceButton", "lovr.headset"],
          "summary": "Different axes on an input device.",
          "values": [
            { "description": "A trigger (1D).", "name": "trigger" },
            { "description": "A thumbstick (2D).", "name": "thumbstick" },
            { "description": "A touchpad (2D).", "name": "touchpad" },
            {
              "description": "A grip button or grab gesture (1D).",
              "name": "grip"
            },
            {
              "description": "The pressure sensitivity of the nib (tip) of a `stylus` device.",
              "name": "nib"
            }
          ]
        },
        {
          "description": "Buttons on an input device.",
          "key": "DeviceButton",
          "module": "lovr.headset",
          "name": "DeviceButton",
          "related": ["lovr.headset"],
          "summary": "Different buttons on an input device.",
          "values": [
            { "description": "The trigger button.", "name": "trigger" },
            { "description": "The thumbstick.", "name": "thumbstick" },
            { "description": "The thumbrest.", "name": "thumbrest" },
            { "description": "The touchpad.", "name": "touchpad" },
            { "description": "The grip button.", "name": "grip" },
            { "description": "The menu button.", "name": "menu" },
            { "description": "The A button.", "name": "a" },
            { "description": "The B button.", "name": "b" },
            { "description": "The X button.", "name": "x" },
            { "description": "The Y button.", "name": "y" },
            {
              "description": "The nib (tip) of the `stylus` device.",
              "name": "nib"
            }
          ]
        },
        {
          "description": "The different levels of foveation supported by `lovr.headset.setFoveation`.",
          "key": "FoveationLevel",
          "module": "lovr.headset",
          "name": "FoveationLevel",
          "related": ["lovr.headset"],
          "summary": "Different foveation levels.",
          "values": [
            { "description": "Low foveation.", "name": "low" },
            { "description": "Medium foveation.", "name": "medium" },
            { "description": "High foveation.", "name": "high" }
          ]
        },
        {
          "description": "These are all of the supported VR APIs that L\u00d6VR can use to power the lovr.headset module.  You can change the order of headset drivers using `lovr.conf` to prefer or exclude specific VR APIs.\n\nAt startup, L\u00d6VR searches through the list of drivers in order.",
          "key": "HeadsetDriver",
          "module": "lovr.headset",
          "name": "HeadsetDriver",
          "related": ["lovr.headset"],
          "summary": "VR APIs.",
          "values": [
            {
              "description": "A VR simulator using keyboard\/mouse.",
              "name": "simulator"
            },
            { "description": "OpenXR.", "name": "openxr" }
          ]
        },
        {
          "description": "Represents the different types of origins for coordinate spaces.  An origin of \"floor\" means that the origin is on the floor in the middle of a room-scale play area.  An origin of \"head\" means that no positional tracking is available, and consequently the origin is always at the position of the headset.",
          "key": "HeadsetOrigin",
          "module": "lovr.headset",
          "name": "HeadsetOrigin",
          "related": ["lovr.headset"],
          "summary": "Different types of coordinate space origins.",
          "values": [
            { "description": "The origin is at the head.", "name": "head" },
            { "description": "The origin is on the floor.", "name": "floor" }
          ]
        },
        {
          "description": "Different passthrough modes, set using `lovr.headset.setPassthrough`.\n\nFor best results, the `blend` and `add` modes should use a transparent background color, which can be changed with `lovr.graphics.setBackgroundColor`.",
          "key": "PassthroughMode",
          "module": "lovr.headset",
          "name": "PassthroughMode",
          "related": [
            "lovr.headset.getPassthrough",
            "lovr.headset.setPassthrough",
            "lovr.headset.getPassthroughModes",
            "lovr.headset"
          ],
          "summary": "Passthrough modes.",
          "values": [
            {
              "description": "The headset display will not blend with anything behind it.  Most VR headsets use this mode.",
              "name": "opaque"
            },
            {
              "description": "The real world will blend with the headset display using the alpha channel.  This is supported on VR headsets with camera passthrough, as well as some AR displays.",
              "name": "blend"
            },
            {
              "description": "Color values from virtual content will be added to the real world.  This is the most common mode used for AR.  Notably, black pixels will not show up at all.",
              "name": "add"
            }
          ]
        }
      ],
      "functions": [
        {
          "description": "Animates a model to match its input state.  The buttons and joysticks on a controller will move as they\u0027re pressed\/moved and hand models will move to match hand tracking joints.\n\nThe model must have been created using `lovr.headset.newModel` with the `animated` flag set to `true`.",
          "examples": [
            {
              "code": "function lovr.load()\n  models \u003d {\n    left \u003d lovr.headset.newModel(\u0027hand\/left\u0027),\n    right \u003d lovr.headset.newModel(\u0027hand\/right\u0027)\n  }\nend\n\nfunction lovr.draw(pass)\n  for hand, model in pairs(models) do\n    if lovr.headset.isTracked(hand) then\n      lovr.headset.animate(model)\n      pass:draw(model, mat4(lovr.headset.getPose(hand)))\n    end\n  end\n\n  if not next(models) then\n    pass:text(\u0027No models loaded\u0027, 0, 1.7, -1, .1)\n  end\nend"
            }
          ],
          "key": "lovr.headset.animate",
          "module": "lovr.headset",
          "name": "animate",
          "notes": "It\u0027s possible to animate a custom hand model by retargeting joint poses, see the `Interaction\/Custom_Hand_Rig` example.",
          "related": ["lovr.headset.newModel", "Model:animate", "lovr.headset"],
          "summary": "Animate a model to match its Device input state.",
          "tag": "controller-models",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The model to animate.",
                  "name": "model",
                  "type": "Model"
                }
              ],
              "returns": [
                {
                  "description": "Whether the animation was applied successfully to the Model.  If the Model was not compatible or animation data for the device was not available, this will be `false`.",
                  "name": "success",
                  "type": "boolean"
                }
              ]
            },
            {
              "arguments": [
                {
                  "default": "\u0027head\u0027",
                  "description": "The device to use for the animation data.",
                  "name": "device",
                  "type": "Device"
                },
                {
                  "description": "The model to animate.",
                  "name": "model",
                  "type": "Model"
                }
              ],
              "deprecated": true,
              "returns": [
                {
                  "description": "Whether the animation was applied successfully to the Model.  If the Model was not compatible or animation data for the device was not available, this will be `false`.",
                  "name": "success",
                  "type": "boolean"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the current angular velocity of a device.",
          "key": "lovr.headset.getAngularVelocity",
          "module": "lovr.headset",
          "name": "getAngularVelocity",
          "notes": "If the device isn\u0027t tracked, all zeroes will be returned.",
          "related": [
            "lovr.headset.getVelocity",
            "lovr.headset.getPosition",
            "lovr.headset.getOrientation",
            "lovr.headset"
          ],
          "summary": "Get the angular velocity of a device.",
          "tag": "input",
          "variants": [
            {
              "arguments": [
                {
                  "default": "\u0027head\u0027",
                  "description": "The device to get the velocity of.",
                  "name": "device",
                  "type": "Device"
                }
              ],
              "returns": [
                {
                  "description": "The x component of the angular velocity.",
                  "name": "x",
                  "type": "number"
                },
                {
                  "description": "The y component of the angular velocity.",
                  "name": "y",
                  "type": "number"
                },
                {
                  "description": "The z component of the angular velocity.",
                  "name": "z",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Get the current state of an analog axis on a device.  Some axes are multidimensional, for example a 2D touchpad or thumbstick with x\/y axes.  For multidimensional axes, this function will return multiple values, one number for each axis.  In these cases, it can be useful to use the `select` function built in to Lua to select a particular axis component.",
          "key": "lovr.headset.getAxis",
          "module": "lovr.headset",
          "name": "getAxis",
          "notes": "The axis values will be between 0 and 1 for 1D axes, and between -1 and 1 for each component of a multidimensional axis.\n\nWhen hand tracking is active, pinch strength will be mapped to the `trigger` axis.",
          "related": ["DeviceAxis", "lovr.headset.isDown", "lovr.headset"],
          "summary": "Get the state of an analog axis on a device.",
          "tag": "input",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The device.",
                  "name": "device",
                  "type": "Device"
                },
                {
                  "description": "The axis.",
                  "name": "axis",
                  "type": "DeviceAxis"
                }
              ],
              "returns": [
                {
                  "description": "The current state of the components of the axis, or `nil` if the device does not have any information about the axis.",
                  "name": "...",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the depth of the play area, in meters.",
          "key": "lovr.headset.getBoundsDepth",
          "module": "lovr.headset",
          "name": "getBoundsDepth",
          "related": [
            "lovr.headset.getBoundsWidth",
            "lovr.headset.getBoundsDimensions",
            "lovr.headset"
          ],
          "summary": "Get the depth of the play area.",
          "tag": "playArea",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The depth of the play area, in meters.",
                  "name": "depth",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the size of the play area, in meters.",
          "key": "lovr.headset.getBoundsDimensions",
          "module": "lovr.headset",
          "name": "getBoundsDimensions",
          "related": [
            "lovr.headset.getBoundsWidth",
            "lovr.headset.getBoundsDepth",
            "lovr.headset.getBoundsGeometry",
            "lovr.headset"
          ],
          "summary": "Get the size of the play area.",
          "tag": "playArea",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The width of the play area, in meters.",
                  "name": "width",
                  "type": "number"
                },
                {
                  "description": "The depth of the play area, in meters.",
                  "name": "depth",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns a list of points representing the boundaries of the play area, or `nil` if the current headset driver does not expose this information.",
          "key": "lovr.headset.getBoundsGeometry",
          "module": "lovr.headset",
          "name": "getBoundsGeometry",
          "related": ["lovr.headset.getBoundsDimensions", "lovr.headset"],
          "summary": "Get a list of points that make up the play area boundary.",
          "tag": "playArea",
          "variants": [
            {
              "arguments": [
                {
                  "default": "nil",
                  "description": "A table to fill with the points.  If `nil`, a new table will be created.",
                  "name": "t",
                  "type": "table"
                }
              ],
              "returns": [
                {
                  "description": "A flat table of 3D points representing the play area boundaries.",
                  "name": "points",
                  "type": "table"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the width of the play area, in meters.",
          "key": "lovr.headset.getBoundsWidth",
          "module": "lovr.headset",
          "name": "getBoundsWidth",
          "related": [
            "lovr.headset.getBoundsDepth",
            "lovr.headset.getBoundsDimensions",
            "lovr.headset"
          ],
          "summary": "Get the width of the play area.",
          "tag": "playArea",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The width of the play area, in meters.",
                  "name": "width",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the near and far clipping planes used to render to the headset.  Objects closer than the near clipping plane or further than the far clipping plane will be clipped out of view.",
          "key": "lovr.headset.getClipDistance",
          "module": "lovr.headset",
          "name": "getClipDistance",
          "notes": "The default near and far clipping planes are 0.01 meters and 0.0 meters.",
          "related": ["lovr.headset.setClipDistance", "lovr.headset"],
          "summary": "Get the near and far clipping planes of the headset.",
          "tag": "headset",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The distance to the near clipping plane, in meters.",
                  "name": "near",
                  "type": "number"
                },
                {
                  "description": "The distance to the far clipping plane, in meters, or 0 for an infinite far clipping plane with a reversed Z range.",
                  "name": "far",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the headset delta time, which is the difference between the current and previous predicted display times.  When the headset is active, this will be the `dt` value passed in to `lovr.update`.",
          "key": "lovr.headset.getDeltaTime",
          "module": "lovr.headset",
          "name": "getDeltaTime",
          "related": [
            "lovr.headset.getTime",
            "lovr.timer.getTime",
            "lovr.timer.getDelta",
            "lovr.headset"
          ],
          "summary": "Get the predicted delta time.",
          "tag": "headset-misc",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The delta time.",
                  "name": "dt",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the direction a device is pointing.  It will always be normalized.",
          "key": "lovr.headset.getDirection",
          "module": "lovr.headset",
          "name": "getDirection",
          "notes": "If the device isn\u0027t tracked, all zeroes will be returned.\n\nThis is the same as `quat(lovr.headset.getOrientation(device)):direction():unpack()`.",
          "related": [
            "lovr.headset.getPose",
            "lovr.headset.getOrientation",
            "lovr.headset.getVelocity",
            "lovr.headset.getAngularVelocity",
            "lovr.headset.isTracked",
            "lovr.headset.getDriver",
            "lovr.headset"
          ],
          "summary": "Get the direction a device is pointing.",
          "tag": "input",
          "variants": [
            {
              "arguments": [
                {
                  "default": "\u0027head\u0027",
                  "description": "The device to get the direction of.",
                  "name": "device",
                  "type": "Device"
                }
              ],
              "returns": [
                {
                  "description": "The x component of the direction.",
                  "name": "x",
                  "type": "number"
                },
                {
                  "description": "The y component of the direction.",
                  "name": "y",
                  "type": "number"
                },
                {
                  "description": "The z component of the direction.",
                  "name": "z",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the texture dimensions of the headset display (for one eye), in pixels.",
          "key": "lovr.headset.getDisplayDimensions",
          "module": "lovr.headset",
          "name": "getDisplayDimensions",
          "related": [
            "lovr.headset.getDisplayWidth",
            "lovr.headset.getDisplayHeight",
            "lovr.headset"
          ],
          "summary": "Get the dimensions of the headset display.",
          "tag": "headset",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The width of the display.",
                  "name": "width",
                  "type": "number"
                },
                {
                  "description": "The height of the display.",
                  "name": "height",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the height of the headset display (for one eye), in pixels.",
          "key": "lovr.headset.getDisplayHeight",
          "module": "lovr.headset",
          "name": "getDisplayHeight",
          "related": [
            "lovr.headset.getDisplayWidth",
            "lovr.headset.getDisplayDimensions",
            "lovr.headset"
          ],
          "summary": "Get the height of the headset display.",
          "tag": "headset",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The height of the display.",
                  "name": "height",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the width of the headset display (for one eye), in pixels.",
          "key": "lovr.headset.getDisplayWidth",
          "module": "lovr.headset",
          "name": "getDisplayWidth",
          "related": [
            "lovr.headset.getDisplayHeight",
            "lovr.headset.getDisplayDimensions",
            "lovr.headset"
          ],
          "summary": "Get the width of the headset display.",
          "tag": "headset",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The width of the display.",
                  "name": "width",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the `HeadsetDriver` that is currently in use, plus the name of the VR runtime.  The order of headset drivers can be changed using `lovr.conf`.",
          "key": "lovr.headset.getDriver",
          "module": "lovr.headset",
          "name": "getDriver",
          "related": ["lovr.headset.getName", "lovr.headset"],
          "summary": "Get the VR API currently in use for a device.",
          "tag": "headset-misc",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The current headset backend, e.g. `openxr` or `simulator`.",
                  "name": "driver",
                  "type": "HeadsetDriver"
                },
                {
                  "description": "The name of the VR runtime, e.g. `SteamVR\/OpenXR`.",
                  "name": "runtime",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns a table of features that are supported by the current headset runtime.",
          "key": "lovr.headset.getFeatures",
          "module": "lovr.headset",
          "name": "getFeatures",
          "related": ["lovr.headset.getName", "lovr.headset"],
          "summary": "Get the supported headset features.",
          "tag": "headset-misc",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "",
                  "name": "features",
                  "table": [
                    {
                      "description": "Whether L\u00d6VR is able to run as an overlay on top of other VR applications.  When unsupported, the `t.headset.overlay` option in `lovr.conf` will be ignored.  Currently this will also be false if `t.headset.overlay` is false.",
                      "name": "overlay",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether the headset provides access to its proximity sensor.  When unsupported, `lovr.headset.isMounted` will always return true and `lovr.mount` will never be called.",
                      "name": "proximity",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether the headset supports one of the non-opaque passthrough modes.  When unsupported, `lovr.headset.getPassthroughModes` will only return \u0027opaque\u0027.",
                      "name": "passthrough",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether the headset display supports querying and changing the refresh rate.  When unsupported, `lovr.headset.getRefreshRate` will always return nil and `lovr.headset.setRefreshRate` will always return false.",
                      "name": "refreshRate",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether `t.headset.submitdepth` in `lovr.conf` is active and supported.",
                      "name": "depthSubmission",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether the headset supports eye gaze tracking.  When unsupported, the `eye\/*` devices will always be untracked.",
                      "name": "eyeTracking",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether hand tracking is supported.  When false, `lovr.headset.getSkeleton` will always return nil.",
                      "name": "handTracking",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether the hand tracker is able to return data for the `elbow\/*` devices.",
                      "name": "handTrackingElbow",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether the system supports tracked keyboards for the `keyboard` device.",
                      "name": "keyboardTracking",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether the system supports Vive trackers.",
                      "name": "viveTrackers",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether `lovr.headset.newModel` is able to load models for the user\\\u0027s hands.",
                      "name": "handModel",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether `lovr.headset.newModel` supports loading controller models.",
                      "name": "controllerModel",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether the `t.headset.controllerskeleton` option in `lovr.conf` is supported and whether the `controller` key in the `lovr.headset.getSkeleton` table is supported.  When this is false, it is not possible to determine whether hand tracking data is coming from the user\u0027s actual hands or if it\u0027s estimated from controller button inputs.",
                      "name": "controllerSkeleton",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether `lovr.headset.setBackground` supports cubemap textures.",
                      "name": "cubeBackground",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether `lovr.headset.setBackground` supports equirectangular textures.",
                      "name": "equirectBackground",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether `Layer:setColor` is supported.",
                      "name": "layerColor",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether `Layer:setCurve` is supported.",
                      "name": "layerCurve",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether Layers are able to depth sort with the rest of the 3D scene, and with each other.  When unsupported, layers will always render on top of the 3D scene and any layers that come before them in the layer list.",
                      "name": "layerDepthTest",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether the `filter` option is supported for Layers.",
                      "name": "layerFilter",
                      "type": "boolean"
                    }
                  ],
                  "type": "table"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the current foveation settings, previously set by `lovr.headset.setFoveation`.\u0027",
          "key": "lovr.headset.getFoveation",
          "module": "lovr.headset",
          "name": "getFoveation",
          "notes": "Foveation is disabled by default.",
          "related": ["lovr.headset.setFoveation", "lovr.headset"],
          "summary": "Get the current foveation settings.",
          "tag": "headset",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The foveation level (or the maximum level when dynamic foveation is active).",
                  "name": "level",
                  "type": "FoveationLevel"
                },
                {
                  "description": "Whether dynamic foveation is active, allowing the system to reduce foveation based on GPU load.",
                  "name": "dynamic",
                  "type": "boolean"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns pointers to the OpenXR instance and session objects.\n\nThis can be used with FFI or other native plugins to integrate with other OpenXR code.",
          "key": "lovr.headset.getHandles",
          "module": "lovr.headset",
          "name": "getHandles",
          "related": ["lovr.headset"],
          "summary": "Get native pointers to OpenXR objects.",
          "tag": "headset-misc",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The OpenXR instance handle (`XrInstance`).",
                  "name": "instance",
                  "type": "lightuserdata"
                },
                {
                  "description": "The OpenXR session handle (`XrSession`).",
                  "name": "session",
                  "type": "lightuserdata"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns a table with all of the currently tracked hand devices.",
          "examples": [
            {
              "code": "function lovr.update(dt)\n  for i, hand in ipairs(lovr.headset.getHands()) do\n    print(hand, lovr.headset.getPose(hand))\n  end\nend"
            }
          ],
          "key": "lovr.headset.getHands",
          "module": "lovr.headset",
          "name": "getHands",
          "notes": "The hand paths will *always* be either `hand\/left` or `hand\/right`.",
          "related": ["lovr.headset"],
          "summary": "Get a list of currently tracked hand devices.",
          "tag": "input",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "arguments": {},
                  "description": "The currently tracked hand devices.",
                  "name": "hands",
                  "returns": {},
                  "type": "table"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the list of active `Layer` objects.  These are the layers that will be rendered in the headset\u0027s display.  They are rendered in order.",
          "key": "lovr.headset.getLayers",
          "module": "lovr.headset",
          "name": "getLayers",
          "notes": "Currently some VR systems are able to sort the layers by their Z depth, but on others layers later in the list will render on top of previous layers, regardless of depth.\n\nThere is currently a maximum of 10 layers.",
          "related": [
            "lovr.headset.newLayer",
            "Layer",
            "lovr.headset.setLayers",
            "lovr.headset"
          ],
          "summary": "Get the list of active layers.",
          "tag": "layers",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The list of layers.",
                  "name": "layers",
                  "type": "table"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the name of the headset as a string.  The exact string that is returned depends on the hardware and VR SDK that is currently in use.",
          "key": "lovr.headset.getName",
          "module": "lovr.headset",
          "name": "getName",
          "notes": "The simulator driver name will always be `Simulator`.",
          "related": ["lovr.headset"],
          "summary": "Get the name of the connected headset display.",
          "tag": "headset-misc",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The name of the headset as a string.",
                  "name": "name",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the current orientation of a device, in angle\/axis form.",
          "key": "lovr.headset.getOrientation",
          "module": "lovr.headset",
          "name": "getOrientation",
          "notes": "If the device isn\u0027t tracked, all zeroes will be returned.",
          "related": [
            "lovr.headset.getPose",
            "lovr.headset.getPosition",
            "lovr.headset.getDirection",
            "lovr.headset.getVelocity",
            "lovr.headset.getAngularVelocity",
            "lovr.headset.isTracked",
            "lovr.headset.getDriver",
            "lovr.headset"
          ],
          "summary": "Get the orientation of a device.",
          "tag": "input",
          "variants": [
            {
              "arguments": [
                {
                  "default": "\u0027head\u0027",
                  "description": "The device to get the orientation of.",
                  "name": "device",
                  "type": "Device"
                }
              ],
              "returns": [
                {
                  "description": "The amount of rotation around the axis of rotation, in radians.",
                  "name": "angle",
                  "type": "number"
                },
                {
                  "description": "The x component of the axis of rotation.",
                  "name": "ax",
                  "type": "number"
                },
                {
                  "description": "The y component of the axis of rotation.",
                  "name": "ay",
                  "type": "number"
                },
                {
                  "description": "The z component of the axis of rotation.",
                  "name": "az",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns a `Pass` that renders to the headset display.",
          "key": "lovr.headset.getPass",
          "module": "lovr.headset",
          "name": "getPass",
          "notes": "The same Pass will be returned until `lovr.headset.submit` is called.\n\nThe first time this function is called during a frame, the views of the Pass will be initialized with the headset view poses and view angles.\n\nThe pass will be cleared to the background color, which can be changed using `lovr.graphics.setBackgroundColor`.\n\nThe pass will have a depth buffer.  If `t.headset.stencil` was set to a truthy value in `lovr.conf`, the depth buffer will use the `d32fs8` format, otherwise `d32f` will be used.\n\nIf `t.headset.antialias` was set to a truthy value in `lovr.conf`, the pass will be multisampled.",
          "related": [
            "lovr.graphics.newPass",
            "lovr.graphics.getWindowPass",
            "lovr.conf",
            "lovr.headset"
          ],
          "summary": "Get a Pass that renders to the headset.",
          "tag": "headset-misc",
          "variants": [
            {
              "arguments": {},
              "returns": [
                { "description": "The pass.", "name": "pass", "type": "Pass" }
              ]
            }
          ]
        },
        {
          "description": "Returns the current passthrough mode.",
          "key": "lovr.headset.getPassthrough",
          "module": "lovr.headset",
          "name": "getPassthrough",
          "related": [
            "lovr.headset.getPassthroughModes",
            "lovr.headset.setPassthrough",
            "lovr.headset"
          ],
          "summary": "Get the current passthrough mode.",
          "tag": "headset",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The current passthrough mode.",
                  "name": "mode",
                  "type": "PassthroughMode"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the set of supported passthrough modes.",
          "key": "lovr.headset.getPassthroughModes",
          "module": "lovr.headset",
          "name": "getPassthroughModes",
          "related": [
            "lovr.headset.getPassthrough",
            "lovr.headset.setPassthrough",
            "lovr.headset"
          ],
          "summary": "Get the supported passthrough modes.",
          "tag": "headset",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The set of supported passthrough modes.  Keys will be `PassthroughMode` strings, and values will be booleans indicating whether the mode is supported.",
                  "name": "modes",
                  "type": "table"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the current position and orientation of a device.",
          "key": "lovr.headset.getPose",
          "module": "lovr.headset",
          "name": "getPose",
          "notes": "Units are in meters.\n\nIf the device isn\u0027t tracked, all zeroes will be returned.",
          "related": [
            "lovr.headset.getPosition",
            "lovr.headset.getOrientation",
            "lovr.headset.getVelocity",
            "lovr.headset.getAngularVelocity",
            "lovr.headset.getSkeleton",
            "lovr.headset.isTracked",
            "lovr.headset.getDriver",
            "lovr.headset"
          ],
          "summary": "Get the pose of a device.",
          "tag": "input",
          "variants": [
            {
              "arguments": [
                {
                  "default": "\u0027head\u0027",
                  "description": "The device to get the pose of.",
                  "name": "device",
                  "type": "Device"
                }
              ],
              "returns": [
                {
                  "description": "The x position.",
                  "name": "x",
                  "type": "number"
                },
                {
                  "description": "The y position.",
                  "name": "y",
                  "type": "number"
                },
                {
                  "description": "The z position.",
                  "name": "z",
                  "type": "number"
                },
                {
                  "description": "The amount of rotation around the axis of rotation, in radians.",
                  "name": "angle",
                  "type": "number"
                },
                {
                  "description": "The x component of the axis of rotation.",
                  "name": "ax",
                  "type": "number"
                },
                {
                  "description": "The y component of the axis of rotation.",
                  "name": "ay",
                  "type": "number"
                },
                {
                  "description": "The z component of the axis of rotation.",
                  "name": "az",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the current position of a device, in meters, relative to the play area.",
          "key": "lovr.headset.getPosition",
          "module": "lovr.headset",
          "name": "getPosition",
          "notes": "If the device isn\u0027t tracked, all zeroes will be returned.",
          "related": [
            "lovr.headset.getPose",
            "lovr.headset.getOrientation",
            "lovr.headset.getVelocity",
            "lovr.headset.getAngularVelocity",
            "lovr.headset.isTracked",
            "lovr.headset.getDriver",
            "lovr.headset"
          ],
          "summary": "Get the position of a device.",
          "tag": "input",
          "variants": [
            {
              "arguments": [
                {
                  "default": "\u0027head\u0027",
                  "description": "The device to get the position of.",
                  "name": "device",
                  "type": "Device"
                }
              ],
              "returns": [
                {
                  "description": "The x position of the device.",
                  "name": "x",
                  "type": "number"
                },
                {
                  "description": "The y position of the device.",
                  "name": "y",
                  "type": "number"
                },
                {
                  "description": "The z position of the device.",
                  "name": "z",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the refresh rate of the headset display, in Hz.",
          "key": "lovr.headset.getRefreshRate",
          "module": "lovr.headset",
          "name": "getRefreshRate",
          "related": [
            "lovr.headset.getRefreshRates",
            "lovr.headset.setRefreshRate",
            "lovr.headset"
          ],
          "summary": "Get the refresh rate of the headset display.",
          "tag": "headset",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The refresh rate of the display, or `nil` if I have no idea what it is.",
                  "name": "rate",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns a table with all the refresh rates supported by the headset display, in Hz.",
          "key": "lovr.headset.getRefreshRates",
          "module": "lovr.headset",
          "name": "getRefreshRates",
          "related": [
            "lovr.headset.getRefreshRate",
            "lovr.headset.setRefreshRate",
            "lovr.headset"
          ],
          "summary": "Get the list of refresh rates supported by the display.",
          "tag": "headset",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "A flat table of the refresh rates supported by the headset display, or nil if not supported.",
                  "name": "rates",
                  "type": "table"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns a list of joint transforms tracked by a device.  Currently, only hand devices are able to track joints.",
          "examples": [
            {
              "code": "function lovr.draw(pass)\n  for _, hand in ipairs({ \u0027left\u0027, \u0027right\u0027 }) do\n    for _, joint in ipairs(lovr.headset.getSkeleton(hand) or {}) do\n      pass:points(unpack(joint, 1, 3))\n    end\n  end\nend"
            }
          ],
          "key": "lovr.headset.getSkeleton",
          "module": "lovr.headset",
          "name": "getSkeleton",
          "notes": "If the Device does not support tracking joints or the transforms are unavailable, this function returns `nil`.\n\nThe joint orientation is similar to the graphics coordinate system: -Z is the forwards direction, pointing towards the fingertips.  The +Y direction is \"up\", pointing out of the back of the hand.  The +X direction is to the right, perpendicular to X and Z.\n\nHere\u0027s a picture, courtesy of Khronos Group:\n\n![Hand Skeleton Joints](https:\/\/lovr.org\/img\/hand-skeleton.png)\n\nHand joints are returned in the following order:\n\n\u003ctable\u003e\n  \u003cthead\u003e\n    \u003ctr\u003e\n      \u003ctd colspan\u003d\"2\"\u003eJoint\u003c\/td\u003e\n      \u003ctd\u003eIndex\u003c\/td\u003e\n    \u003c\/tr\u003e\n  \u003c\/thead\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003ctd colspan\u003d\"2\"\u003ePalm\u003c\/td\u003e\n      \u003ctd\u003e1\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd colspan\u003d\"2\"\u003eWrist\u003c\/td\u003e\n      \u003ctd\u003e2\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd rowspan\u003d\"4\"\u003eThumb\u003c\/td\u003e\n      \u003ctd\u003eMetacarpal\u003c\/td\u003e\n      \u003ctd\u003e3\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eProximal\u003c\/td\u003e\n      \u003ctd\u003e4\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eDistal\u003c\/td\u003e\n      \u003ctd\u003e5\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eTip\u003c\/td\u003e\n      \u003ctd\u003e6\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd rowspan\u003d\"5\"\u003eIndex\u003c\/td\u003e\n      \u003ctd\u003eMetacarpal\u003c\/td\u003e\n      \u003ctd\u003e7\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eProximal\u003c\/td\u003e\n      \u003ctd\u003e8\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eIntermediate\u003c\/td\u003e\n      \u003ctd\u003e9\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eDistal\u003c\/td\u003e\n      \u003ctd\u003e10\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eTip\u003c\/td\u003e\n      \u003ctd\u003e11\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd rowspan\u003d\"5\"\u003eMiddle\u003c\/td\u003e\n      \u003ctd\u003eMetacarpal\u003c\/td\u003e\n      \u003ctd\u003e12\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eProximal\u003c\/td\u003e\n      \u003ctd\u003e13\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eIntermediate\u003c\/td\u003e\n      \u003ctd\u003e14\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eDistal\u003c\/td\u003e\n      \u003ctd\u003e15\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eTip\u003c\/td\u003e\n      \u003ctd\u003e16\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd rowspan\u003d\"5\"\u003eRing\u003c\/td\u003e\n      \u003ctd\u003eMetacarpal\u003c\/td\u003e\n      \u003ctd\u003e17\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eProximal\u003c\/td\u003e\n      \u003ctd\u003e18\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eIntermediate\u003c\/td\u003e\n      \u003ctd\u003e19\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eDistal\u003c\/td\u003e\n      \u003ctd\u003e20\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eTip\u003c\/td\u003e\n      \u003ctd\u003e21\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd rowspan\u003d\"5\"\u003ePinky\u003c\/td\u003e\n      \u003ctd\u003eMetacarpal\u003c\/td\u003e\n      \u003ctd\u003e22\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eProximal\u003c\/td\u003e\n      \u003ctd\u003e23\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eIntermediate\u003c\/td\u003e\n      \u003ctd\u003e24\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eDistal\u003c\/td\u003e\n      \u003ctd\u003e25\u003c\/td\u003e\n    \u003c\/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eTip\u003c\/td\u003e\n      \u003ctd\u003e26\u003c\/td\u003e\n    \u003c\/tr\u003e\n  \u003c\/tbody\u003e \u003c\/table\u003e",
          "related": [
            "lovr.headset.getPose",
            "lovr.headset.animate",
            "lovr.headset"
          ],
          "summary": "Get skeletal joint transforms tracked by a device.",
          "tag": "input",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The hand device to query (`left` or `right`).",
                  "name": "device",
                  "type": "Device"
                }
              ],
              "returns": [
                {
                  "description": "A list of joint transforms for the device.  Each transform is a table with 3 numbers for the position of the joint, 1 number for the joint radius (in meters), and 4 numbers for the angle\/axis orientation of the joint.  There is also a `radius` key with the radius of the joint as well.",
                  "name": "transforms",
                  "type": "table"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The hand device to query (`left` or `right`).",
                  "name": "device",
                  "type": "Device"
                },
                {
                  "description": "A table to fill with the joint transforms, instead of allocating a new one.",
                  "name": "t",
                  "type": "table"
                }
              ],
              "returns": [
                {
                  "description": "A list of joint transforms for the device.  Each transform is a table with 3 numbers for the position of the joint, 1 number for the joint radius (in meters), and 4 numbers for the angle\/axis orientation of the joint.  There is also a `radius` key with the radius of the joint as well.",
                  "name": "transforms",
                  "type": "table"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns a Texture that will be submitted to the headset display.  This will be the render target used in the headset\u0027s render pass.  The texture is not guaranteed to be the same every frame, and must be called every frame to get the current texture.",
          "key": "lovr.headset.getTexture",
          "module": "lovr.headset",
          "name": "getTexture",
          "notes": "This function may return `nil` if the headset is not being rendered to this frame.",
          "related": ["lovr.headset.getPass", "lovr.mirror", "lovr.headset"],
          "summary": "Get the Texture for the headset display.",
          "tag": "headset-misc",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The headset texture.",
                  "name": "texture",
                  "type": "Texture"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the estimated time in the future at which the light from the pixels of the current frame will hit the eyes of the user.\n\nThis can be used as a replacement for `lovr.timer.getTime` for timestamps that are used for rendering to get a smoother result that is synchronized with the display of the headset.",
          "key": "lovr.headset.getTime",
          "module": "lovr.headset",
          "name": "getTime",
          "notes": "This has a different epoch than `lovr.timer.getTime`, so it is not guaranteed to be close to that value.",
          "related": [
            "lovr.headset.getDeltaTime",
            "lovr.timer.getTime",
            "lovr.headset"
          ],
          "summary": "Get the predicted display time.",
          "tag": "headset-misc",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The predicted display time, in seconds.",
                  "name": "time",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the current linear velocity of a device, in meters per second.",
          "key": "lovr.headset.getVelocity",
          "module": "lovr.headset",
          "name": "getVelocity",
          "notes": "If the device isn\u0027t tracked, all zeroes will be returned.",
          "related": [
            "lovr.headset.getAngularVelocity",
            "lovr.headset.getPose",
            "lovr.headset.getPosition",
            "lovr.headset.getOrientation",
            "lovr.headset"
          ],
          "summary": "Get the linear velocity of a device.",
          "tag": "input",
          "variants": [
            {
              "arguments": [
                {
                  "default": "\u0027head\u0027",
                  "description": "The device to get the velocity of.",
                  "name": "device",
                  "type": "Device"
                }
              ],
              "returns": [
                {
                  "description": "The x component of the linear velocity.",
                  "name": "vx",
                  "type": "number"
                },
                {
                  "description": "The y component of the linear velocity.",
                  "name": "vy",
                  "type": "number"
                },
                {
                  "description": "The z component of the linear velocity.",
                  "name": "vz",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the view angles of one of the headset views.\n\nThese can be used with `Mat4:fov` to create a projection matrix.\n\nIf tracking data is unavailable for the view or the index is invalid, `nil` is returned.",
          "key": "lovr.headset.getViewAngles",
          "module": "lovr.headset",
          "name": "getViewAngles",
          "related": [
            "lovr.headset.getViewCount",
            "lovr.headset.getViewPose",
            "lovr.headset"
          ],
          "summary": "Get the field of view angles of a view.",
          "tag": "headset",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The view index.",
                  "name": "view",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "The left view angle, in radians.",
                  "name": "left",
                  "type": "number"
                },
                {
                  "description": "The right view angle, in radians.",
                  "name": "right",
                  "type": "number"
                },
                {
                  "description": "The top view angle, in radians.",
                  "name": "top",
                  "type": "number"
                },
                {
                  "description": "The bottom view angle, in radians.",
                  "name": "bottom",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the number of views used for rendering.  Each view consists of a pose in space and a set of angle values that determine the field of view.\n\nThis is usually 2 for stereo rendering configurations, but it can also be different.  For example, one way of doing foveated rendering uses 2 views for each eye -- one low quality view with a wider field of view, and a high quality view with a narrower field of view.",
          "key": "lovr.headset.getViewCount",
          "module": "lovr.headset",
          "name": "getViewCount",
          "related": [
            "lovr.headset.getViewPose",
            "lovr.headset.getViewAngles",
            "lovr.headset"
          ],
          "summary": "Get the number of views used for rendering.",
          "tag": "headset",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The number of views.",
                  "name": "count",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the pose of one of the headset views.  This info can be used to create view matrices or do other eye-dependent calculations.\n\nIf tracking data is unavailable for the view or the index is invalid, `nil` is returned.",
          "key": "lovr.headset.getViewPose",
          "module": "lovr.headset",
          "name": "getViewPose",
          "related": [
            "lovr.headset.getViewCount",
            "lovr.headset.getViewAngles",
            "lovr.headset"
          ],
          "summary": "Get the pose of one of the views.",
          "tag": "headset",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The view index.",
                  "name": "view",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "The x coordinate of the view position, in meters.",
                  "name": "x",
                  "type": "number"
                },
                {
                  "description": "The y coordinate of the view position, in meters.",
                  "name": "y",
                  "type": "number"
                },
                {
                  "description": "The z coordinate of the view position, in meters.",
                  "name": "z",
                  "type": "number"
                },
                {
                  "description": "The amount of rotation around the rotation axis, in radians.",
                  "name": "angle",
                  "type": "number"
                },
                {
                  "description": "The x component of the axis of rotation.",
                  "name": "ax",
                  "type": "number"
                },
                {
                  "description": "The y component of the axis of rotation.",
                  "name": "ay",
                  "type": "number"
                },
                {
                  "description": "The z component of the axis of rotation.",
                  "name": "az",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns whether a headset session is active.  When true, there is an active connection to the VR hardware.  When false, most headset methods will not work properly until `lovr.headset.start` is used to start a session.",
          "key": "lovr.headset.isActive",
          "module": "lovr.headset",
          "name": "isActive",
          "related": [
            "lovr.headset.start",
            "lovr.headset.stop",
            "lovr.headset"
          ],
          "summary": "Check if the headset session is active.",
          "tag": "headset-misc",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "Whether the headset session is active.",
                  "name": "active",
                  "type": "boolean"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns whether a button on a device is pressed.",
          "key": "lovr.headset.isDown",
          "module": "lovr.headset",
          "name": "isDown",
          "notes": "When hand tracking is active, pinching will be mapped to the `trigger` button.",
          "related": [
            "DeviceButton",
            "lovr.headset.wasPressed",
            "lovr.headset.wasReleased",
            "lovr.headset.isTouched",
            "lovr.headset.getAxis",
            "lovr.headset"
          ],
          "summary": "Get the state of a button on a device.",
          "tag": "input",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The device.",
                  "name": "device",
                  "type": "Device"
                },
                {
                  "description": "The button.",
                  "name": "button",
                  "type": "DeviceButton"
                }
              ],
              "returns": [
                {
                  "description": "Whether the button on the device is currently pressed, or `nil` if the device does not have the specified button.",
                  "name": "down",
                  "type": "boolean"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns whether L\u00d6VR has VR input focus.  Focus is lost when the VR system menu is shown.  The `lovr.focus` callback can be used to detect when this changes.",
          "key": "lovr.headset.isFocused",
          "module": "lovr.headset",
          "name": "isFocused",
          "related": ["lovr.focus", "lovr.headset"],
          "summary": "Check if L\u00d6VR has VR input focus.",
          "tag": "headset-misc",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "Whether the application is focused.",
                  "name": "focused",
                  "type": "boolean"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns whether the headset is mounted.  Usually this uses a proximity sensor on the headset to detect whether someone is wearing the headset.",
          "key": "lovr.headset.isMounted",
          "module": "lovr.headset",
          "name": "isMounted",
          "related": [
            "lovr.mount",
            "lovr.headset.isFocused",
            "lovr.headset.isVisible",
            "lovr.headset"
          ],
          "summary": "Check if the headset is \"mounted\" (worn on a head).",
          "tag": "headset-misc",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "Whether the headset is mounted.",
                  "name": "mounted",
                  "type": "boolean"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns whether the headset coordinate space is in seated mode.\n\nSeated mode is enabled by setting `t.headset.seated` to true in `lovr.conf`.  In seated mode, `y\u003d0` will be at eye level, instead of on the floor like in standing-scale experiences.\n\nThe seated coordinate space can be more convenient for applications that are rendering a simple interface in front of the user (like a video player) instead of a roomscale 3D scene.  y\u003d0 will also be at the correct height at startup, whether the user is sitting or standing.",
          "key": "lovr.headset.isSeated",
          "module": "lovr.headset",
          "name": "isSeated",
          "related": ["lovr.conf", "lovr.recenter", "lovr.headset"],
          "summary": "Check if the coordinate space is standing or seated.",
          "tag": "playArea",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "Whether the experience is seated.",
                  "name": "seated",
                  "type": "boolean"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns whether a button on a device is currently touched.",
          "key": "lovr.headset.isTouched",
          "module": "lovr.headset",
          "name": "isTouched",
          "related": [
            "DeviceButton",
            "lovr.headset.isDown",
            "lovr.headset.getAxis",
            "lovr.headset"
          ],
          "summary": "Check if a button on a device is touched.",
          "tag": "input",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The device.",
                  "name": "device",
                  "type": "Device"
                },
                {
                  "description": "The button.",
                  "name": "button",
                  "type": "DeviceButton"
                }
              ],
              "returns": [
                {
                  "description": "Whether the button on the device is currently touched, or `nil` if the device does not have the button or it isn\u0027t touch-sensitive.",
                  "name": "touched",
                  "type": "boolean"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns whether any active headset driver is currently returning pose information for a device.",
          "key": "lovr.headset.isTracked",
          "module": "lovr.headset",
          "name": "isTracked",
          "notes": "If a device is tracked, it is guaranteed to return a valid pose until the next call to `lovr.headset.update`.",
          "related": ["lovr.headset"],
          "summary": "Check if a device is currently tracked.",
          "tag": "input",
          "variants": [
            {
              "arguments": [
                {
                  "default": "\u0027head\u0027",
                  "description": "The device to get the pose of.",
                  "name": "device",
                  "type": "Device"
                }
              ],
              "returns": [
                {
                  "description": "Whether the device is currently tracked.",
                  "name": "tracked",
                  "type": "boolean"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns whether L\u00d6VR\u0027s content is being presented to the headset display.  Normally this will be true, but some VR runtimes allow applications to be hidden or \"minimized\", similar to desktop windows.",
          "key": "lovr.headset.isVisible",
          "module": "lovr.headset",
          "name": "isVisible",
          "notes": "`lovr.draw` may still be called even when the application is invisible, and apps should continue to render the scene normally because the VR system may use this for timing info.  If the VR system decides that the application no longer needs to render, L\u00d6VR will stop calling `lovr.draw`.",
          "related": [
            "lovr.visible",
            "lovr.headset.isFocused",
            "lovr.focus",
            "lovr.headset"
          ],
          "summary": "Check if content is being shown in the headset display.",
          "tag": "headset-misc",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "Whether the application is visible.",
                  "name": "visible",
                  "type": "boolean"
                }
              ]
            }
          ]
        },
        {
          "description": "Creates a new `Layer`.",
          "key": "lovr.headset.newLayer",
          "module": "lovr.headset",
          "name": "newLayer",
          "related": [
            "lovr.headset.getLayers",
            "lovr.headset.setLayers",
            "lovr.headset"
          ],
          "summary": "Create a new Layer.",
          "tag": "layers",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The width of the Layer texture, in pixels.",
                  "name": "width",
                  "type": "number"
                },
                {
                  "description": "The height of the Layer texture, in pixels.",
                  "name": "height",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "The new Layer.",
                  "name": "layer",
                  "type": "Layer"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns a new Model for the specified device.",
          "examples": [
            {
              "code": "local models \u003d {}\n\nfunction lovr.draw(pass)\n  for i, hand in ipairs(lovr.headset.getHands()) do\n    models[hand] \u003d models[hand] or lovr.headset.newModel(hand)\n\n    if models[hand] then\n      local x, y, z, angle, ax, ay, az \u003d lovr.headset.getPose(hand)\n      pass:draw(models[hand], x, y, z, 1, angle, ax, ay, az)\n    end\n  end\nend"
            }
          ],
          "key": "lovr.headset.newModel",
          "module": "lovr.headset",
          "name": "newModel",
          "notes": "Currently this is only implemented for hand models on the Oculus Quest.",
          "related": ["lovr.headset.animate", "lovr.headset"],
          "summary": "Get a Model for a device.",
          "tag": "controller-models",
          "variants": [
            {
              "arguments": [
                {
                  "default": "\u0027head\u0027",
                  "description": "The device to load a model for.",
                  "name": "device",
                  "type": "Device"
                },
                {
                  "default": "{}",
                  "description": "Options for loading the model.",
                  "name": "options",
                  "table": [
                    {
                      "default": "false",
                      "description": "Whether an animatable model should be loaded, for use with `lovr.headset.animate`.",
                      "name": "animated",
                      "type": "boolean"
                    }
                  ],
                  "type": "table"
                }
              ],
              "returns": [
                {
                  "description": "The new Model, or `nil` if a model could not be loaded.",
                  "name": "model",
                  "type": "Model"
                }
              ]
            }
          ]
        },
        {
          "description": "Sets a background layer.  This will render behind any transparent pixels in the main 3D content. It works similarly to other `Layer` objects, but using a cubemap or equirectangular texture.\n\nThe background texture is sent to the VR runtime once, and the runtime is responsible for compositing it behind the rest of the scene.  This can improve performance greatly, since the background doesn\u0027t need to be re-rendered every frame.  It also ensures the background remains tracked smoothly even if L\u00d6VR is struggling to render at a high frame rate.",
          "key": "lovr.headset.setBackground",
          "module": "lovr.headset",
          "name": "setBackground",
          "notes": "There is no `lovr.headset.getBackground` because L\u00d6VR does not store the Image or Texture after setting it as a background, to save memory.",
          "related": ["Layer", "Pass:skybox", "lovr.headset"],
          "summary": "Set the background layer.",
          "tag": "layers",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The Texture to use for the background.  It can be a `cube` texture which will be rendered as a cubemap, or a `2d` texture interpreted as equirectangular (sometimes called panoramic or spherical) coordinates.\n\nThe texture can have any color format, but it will be converted to `rgba8` before getting copied to the VR runtime.",
                  "name": "texture",
                  "type": "Texture"
                }
              ],
              "returns": {}
            },
            {
              "arguments": [
                {
                  "description": "The Image to use for the background.  It can have 1 layer for an equirectangular background, or 6 layers for a cubemap.  Currently, it must have a format of `rgba8`.",
                  "name": "image",
                  "type": "Image"
                }
              ],
              "returns": {}
            },
            {
              "arguments": [
                {
                  "description": "A table of 1 or 6 images to use for the background.  They must be the same size and they currently must use the `rgba8` format.",
                  "name": "images",
                  "type": "table"
                }
              ],
              "returns": {}
            },
            {
              "arguments": {},
              "description": "Disables any previously set background.",
              "returns": {}
            }
          ]
        },
        {
          "description": "Sets the near and far clipping planes used to render to the headset.  Objects closer than the near clipping plane or further than the far clipping plane will be clipped out of view.",
          "key": "lovr.headset.setClipDistance",
          "module": "lovr.headset",
          "name": "setClipDistance",
          "notes": "The default clip distances are 0.01 and 0.0.",
          "related": ["lovr.headset"],
          "summary": "Set the near and far clipping planes of the headset.",
          "tag": "headset",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The distance to the near clipping plane, in meters.",
                  "name": "near",
                  "type": "number"
                },
                {
                  "description": "The distance to the far clipping plane, in meters, or 0 for an infinite far clipping plane with a reversed Z range.",
                  "name": "far",
                  "type": "number"
                }
              ],
              "returns": {}
            }
          ]
        },
        {
          "description": "Sets foveated rendering settings.  Currently only fixed foveated rendering is supported.  This renders the edges of the screen at a lower resolution to improve GPU performance.  Higher foveation levels will save more GPU time, but make the edges of the screen more blocky.",
          "key": "lovr.headset.setFoveation",
          "module": "lovr.headset",
          "name": "setFoveation",
          "notes": "Foveation is disabled by default.",
          "related": ["lovr.headset"],
          "summary": "Set foveated rendering settings.",
          "tag": "headset",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The foveation level (or the maximum level when dynamic foveation is active).",
                  "name": "level",
                  "type": "FoveationLevel"
                },
                {
                  "default": "true",
                  "description": "Whether the system is allowed to dynamically adjust the foveation level based on GPU load.",
                  "name": "dynamic",
                  "type": "boolean"
                }
              ],
              "returns": [
                {
                  "description": "Whether foveation was enabled successfully.",
                  "name": "success",
                  "type": "boolean"
                }
              ]
            },
            {
              "arguments": {},
              "description": "Disables foveation.",
              "returns": [
                {
                  "description": "Whether foveation was enabled successfully.",
                  "name": "success",
                  "type": "boolean"
                }
              ]
            }
          ]
        },
        {
          "description": "Sets the list of active `Layer` objects.  These are the layers that will be rendered in the headset\u0027s display.  They are rendered in order.",
          "key": "lovr.headset.setLayers",
          "module": "lovr.headset",
          "name": "setLayers",
          "notes": "Currently some VR systems are able to sort the layers by their Z depth, but on others layers later in the list will render on top of previous layers, regardless of depth.\n\nThere is currently a maximum of 10 layers.",
          "related": ["lovr.headset.newLayer", "Layer", "lovr.headset"],
          "summary": "Set the list of active layers.",
          "tag": "layers",
          "variants": [
            {
              "arguments": [
                {
                  "description": "Zero or more layers to render in the headset.",
                  "name": "...layers",
                  "type": "Layer"
                }
              ],
              "returns": {}
            },
            {
              "arguments": [
                {
                  "description": "A table with zero or more layers starting at index 1.",
                  "name": "t",
                  "type": "table"
                }
              ],
              "returns": {}
            }
          ]
        },
        {
          "description": "Sets a new passthrough mode.  Not all headsets support all passthrough modes.  Use `lovr.headset.getPassthroughModes` to see which modes are supported.",
          "key": "lovr.headset.setPassthrough",
          "module": "lovr.headset",
          "name": "setPassthrough",
          "notes": "When using one of the transparent passthrough modes, be sure to set the alpha of the background color to zero using `lovr.graphics.setBackgroundColor`, so the background shows through.\n\nQuest Link currently requires some extra steps to enable passthrough, see [this article](https:\/\/developers.meta.com\/horizon\/documentation\/native\/android\/mobile-passthrough-over-link) for details.",
          "related": ["lovr.headset.getPassthroughModes", "lovr.headset"],
          "summary": "Change current passthrough mode.",
          "tag": "headset",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The passthrough mode to request.",
                  "name": "mode",
                  "type": "PassthroughMode"
                }
              ],
              "returns": [
                {
                  "description": "Whether the passthrough mode was supported and successfully enabled.",
                  "name": "success",
                  "type": "boolean"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "Whether the headset should use a transparent passthrough mode.  When false, this will request the `opaque` mode.  When true, either `blend` or `add` will be requested, based on what the VR runtime supports.",
                  "name": "transparent",
                  "type": "boolean"
                }
              ],
              "returns": [
                {
                  "description": "Whether the passthrough mode was supported and successfully enabled.",
                  "name": "success",
                  "type": "boolean"
                }
              ]
            },
            {
              "arguments": {},
              "description": "Switch to the headset\u0027s default passthrough mode.",
              "returns": [
                {
                  "description": "Whether the passthrough mode was supported and successfully enabled.",
                  "name": "success",
                  "type": "boolean"
                }
              ]
            }
          ]
        },
        {
          "description": "Sets the display refresh rate, in Hz.",
          "key": "lovr.headset.setRefreshRate",
          "module": "lovr.headset",
          "name": "setRefreshRate",
          "notes": "Changing the display refresh-rate usually also changes the frequency of lovr.update() and lovr.draw() as they depend on the refresh rate.  However, it\u0027s ultimately up to the VR runtime to decide how often the application gets to render, based on available resources.",
          "related": ["lovr.headset.getRefreshRates", "lovr.headset"],
          "summary": "Set the display refresh rate.",
          "tag": "headset",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The new refresh rate, in Hz.",
                  "name": "rate",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "Whether the display refresh rate was successfully set.",
                  "name": "success",
                  "type": "boolean"
                }
              ]
            }
          ]
        },
        {
          "description": "Starts the headset session.  This must be called after the graphics module is initialized. Normally it is called automatically by `boot.lua`, but this can be disabled by setting `t.headset.start` to false in `lovr.conf`.",
          "key": "lovr.headset.start",
          "module": "lovr.headset",
          "name": "start",
          "related": [
            "lovr.headset.stop",
            "lovr.headset.isActive",
            "lovr.headset"
          ],
          "summary": "Starts the headset session.",
          "tag": "headset-misc",
          "variants": [{ "arguments": {}, "returns": {} }]
        },
        {
          "description": "Stops the headset session.  This tears down the connection to the VR runtime and hardware. `lovr.draw` will instead start rendering to the desktop window, as though the headset module was disabled.  However, certain information about the headset can still be queried, such as its name, supported passthrough modes, display size, etc.  A headset session can be started later using `lovr.headset.start`.",
          "key": "lovr.headset.stop",
          "module": "lovr.headset",
          "name": "stop",
          "notes": "The headset module behaves in the following manner when there is no headset session:\n\n- `lovr.headset.isActive` returns `false`.\n- `lovr.headset.getPass` returns `nil`.\n- All devices will be untracked.",
          "related": [
            "lovr.headset.start",
            "lovr.headset.isActive",
            "lovr.headset"
          ],
          "summary": "Stop the headset session.",
          "tag": "headset-misc",
          "variants": [{ "arguments": {}, "returns": {} }]
        },
        {
          "description": "Causes the device to stop any active haptics vibration.",
          "key": "lovr.headset.stopVibration",
          "module": "lovr.headset",
          "name": "stopVibration",
          "related": ["lovr.headset.vibrate", "lovr.headset"],
          "summary": "Stop vibration on a device.",
          "tag": "input",
          "variants": [
            {
              "arguments": [
                {
                  "default": "\u0027head\u0027",
                  "description": "The device to stop the vibration on.",
                  "name": "device",
                  "type": "Device"
                }
              ],
              "returns": {}
            }
          ]
        },
        {
          "description": "Submits the current headset texture to the VR display.  This should be called after calling `lovr.graphics.submit` with the headset render pass.  Normally this is taken care of by `lovr.run`.",
          "key": "lovr.headset.submit",
          "module": "lovr.headset",
          "name": "submit",
          "related": [
            "lovr.headset.getPass",
            "lovr.headset.getTexture",
            "lovr.headset"
          ],
          "summary": "Submit a frame to the headset display.",
          "tag": "headset-misc",
          "variants": [{ "arguments": {}, "returns": {} }]
        },
        {
          "description": "Updates the headset module, blocking until it is time to start a new frame and polling new input states.  This should only be called once at the beginning of a frame, and is normally taken care of by the default `lovr.run` implementation.",
          "key": "lovr.headset.update",
          "module": "lovr.headset",
          "name": "update",
          "related": ["lovr.headset.submit", "lovr.run", "lovr.headset"],
          "summary": "Update the headset module.",
          "tag": "headset-misc",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The delta time since the last frame.  This is the same value returned by `lovr.headset.getDeltaTime`, and is used by boot.lua.",
                  "name": "dt",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Causes the device to vibrate with a custom strength, duration, and frequency, if possible.",
          "key": "lovr.headset.vibrate",
          "module": "lovr.headset",
          "name": "vibrate",
          "related": ["lovr.headset.stopVibration", "lovr.headset"],
          "summary": "Make a device go BZZZ!",
          "tag": "input",
          "variants": [
            {
              "arguments": [
                {
                  "default": "\u0027head\u0027",
                  "description": "The device to vibrate.",
                  "name": "device",
                  "type": "Device"
                },
                {
                  "default": "1",
                  "description": "The strength of the vibration (amplitude), between 0 and 1.",
                  "name": "strength",
                  "type": "number"
                },
                {
                  "default": ".5",
                  "description": "The duration of the vibration, in seconds.",
                  "name": "duration",
                  "type": "number"
                },
                {
                  "default": "0",
                  "description": "The frequency of the vibration, in hertz.  0 will use a default frequency.",
                  "name": "frequency",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "Whether the vibration was successfully triggered by an active headset driver.",
                  "name": "vibrated",
                  "type": "boolean"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns whether a button on a device was pressed this frame.",
          "key": "lovr.headset.wasPressed",
          "module": "lovr.headset",
          "name": "wasPressed",
          "notes": "Some headset backends are not able to return pressed\/released information.  These drivers will always return false for `lovr.headset.wasPressed` and `lovr.headset.wasReleased`.\n\nTypically the internal `lovr.headset.update` function will update pressed\/released status.",
          "related": [
            "DeviceButton",
            "lovr.headset.isDown",
            "lovr.headset.wasReleased",
            "lovr.headset.isTouched",
            "lovr.headset.getAxis",
            "lovr.headset"
          ],
          "summary": "Check if a button was just pressed.",
          "tag": "input",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The device.",
                  "name": "device",
                  "type": "Device"
                },
                {
                  "description": "The button to check.",
                  "name": "button",
                  "type": "DeviceButton"
                }
              ],
              "returns": [
                {
                  "description": "Whether the button on the device was pressed this frame.",
                  "name": "pressed",
                  "type": "boolean"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns whether a button on a device was released this frame.",
          "key": "lovr.headset.wasReleased",
          "module": "lovr.headset",
          "name": "wasReleased",
          "notes": "Some headset backends are not able to return pressed\/released information.  These drivers will always return false for `lovr.headset.wasPressed` and `lovr.headset.wasReleased`.\n\nTypically the internal `lovr.headset.update` function will update pressed\/released status.",
          "related": [
            "DeviceButton",
            "lovr.headset.isDown",
            "lovr.headset.wasPressed",
            "lovr.headset.isTouched",
            "lovr.headset.getAxis",
            "lovr.headset"
          ],
          "summary": "Check if a button was just released.",
          "tag": "input",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The device.",
                  "name": "device",
                  "type": "Device"
                },
                {
                  "description": "The button to check.",
                  "name": "button",
                  "type": "DeviceButton"
                }
              ],
              "returns": [
                {
                  "description": "Whether the button on the device was released this frame.",
                  "name": "released",
                  "type": "boolean"
                }
              ]
            }
          ]
        }
      ],
      "key": "lovr.headset",
      "name": "headset",
      "objects": [
        {
          "constructors": ["lovr.headset.newLayer"],
          "description": "A Layer is a textured plane placed in 3D space.  Layers are sent directly to the VR runtime and composited along with the rest of the 3D content.  This has several advantages compared to rendering the texture into the 3D scene with `Pass:draw`:\n\n- Better tracking.  The VR runtime composites the texture later in the rendering process, using a more accurate head pose.\n- Better resolution, less shimmery.  Regular 3D content must have lens distortion correction\n  applied to it, whereas layers are composited after distortion correction, meaning they have a\n  higher pixel density.  The layer can also use a higher resolution than the main headset\n  texture, allowing for extra resolution on the 2D content without having to supersample all of\n  the 3D rendering.\n- Supersampling and sharpening effects.  Some headset runtimes (currently just Quest) can also\n  supersample and sharpen layers.\n\nCombined, all of this makes a massive difference in quality when rendering 2D content on a Layer, especially improving text readability.\n\nNote that currently the VR simulator does not support layers.",
          "key": "Layer",
          "methods": [
            {
              "description": "Returns the color of the layer.  This will tint the contents of its texture.  It can be used to fade the layer without re-rendering its texture, which is especially useful for layers created with the `static` option.",
              "key": "Layer:getColor",
              "module": "lovr.headset",
              "name": "getColor",
              "notes": "The default color is white (all 1s).\n\nNot every headset system supports layer colors.  See the `layerColor` property of `lovr.headset.getFeatures` to check for support.",
              "related": ["Layer:setColor", "Layer"],
              "summary": "Get the color of the layer.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The red component of the color.",
                      "name": "r",
                      "type": "number"
                    },
                    {
                      "description": "The green component of the color.",
                      "name": "g",
                      "type": "number"
                    },
                    {
                      "description": "The blue component of the color.",
                      "name": "b",
                      "type": "number"
                    },
                    {
                      "description": "The alpha component of the color.",
                      "name": "a",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the curve of the layer.  Curving a layer renders it on a piece of a cylinder instead of a plane. The radius of the cylinder is `1 \/ curve` meters, so increasing the curve decreases the radius of the cylinder.",
              "key": "Layer:getCurve",
              "module": "lovr.headset",
              "name": "getCurve",
              "notes": "When a layer is created, its curve is zero.\n\nNot every headset system supports curved layers.  See the `layerCurve` property of `lovr.headset.getFeatures` to check for support.\n\nNo matter what the curve is, the center of the layer texture will always get rendered at the layer\u0027s pose.\n\nThe largest possible curve is `2 * math.pi \/ width`, where `width` is the width of the layer in meters.  This would cause the cylinder to fully wrap around.",
              "related": ["Layer:setCurve", "Layer"],
              "summary": "Get the curve of the layer.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The curve of the layer.",
                      "name": "curve",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the width and height of the layer.  This is the size of the Layer\u0027s plane in meters, not the resolution of the layer\u0027s texture in pixels.",
              "key": "Layer:getDimensions",
              "module": "lovr.headset",
              "name": "getDimensions",
              "notes": "When a layer is created, its width and height are 1 meter.",
              "related": ["Layer:setDimensions", "Layer"],
              "summary": "Get the size of the layer.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The width of the layer, in meters.",
                      "name": "width",
                      "type": "number"
                    },
                    {
                      "description": "The height of the layer, in meters.",
                      "name": "height",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the orientation of the layer.",
              "key": "Layer:getOrientation",
              "module": "lovr.headset",
              "name": "getOrientation",
              "related": [
                "Layer:getPosition",
                "Layer:setPosition",
                "Layer:getPose",
                "Layer:setPose",
                "Layer:setOrientation",
                "Layer"
              ],
              "summary": "Get the orientation of the layer.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The amount of rotation around the axis of rotation, in radians.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the render pass for the layer.  This can be used to render to the layer.",
              "key": "Layer:getPass",
              "module": "lovr.headset",
              "name": "getPass",
              "notes": "This function will reset the Layer\u0027s render pass when it is called, as though `Pass:reset` was called.\n\nThe Pass will have its background color cleared to the background color, set using `lovr.graphics.setBackgroundColor`.\n\nThe Pass will have its view matrix set to the origin, and its projection will be set to an orthographic matrix where the top left of the texture is at the origin and the bottom right of the texture will be at `(width, height)` in pixels.",
              "related": ["Layer:getTexture", "Layer"],
              "summary": "Get the render pass for the layer.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The layer\u0027s render pass.",
                      "name": "pass",
                      "type": "Pass"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the position and orientation of the layer.",
              "key": "Layer:getPose",
              "module": "lovr.headset",
              "name": "getPose",
              "notes": "Units are in meters.",
              "related": [
                "Layer:getPosition",
                "Layer:setPosition",
                "Layer:getOrientation",
                "Layer:setOrientation",
                "Layer:setPose",
                "Layer"
              ],
              "summary": "Get the pose of the layer.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The x position.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y position.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z position.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The amount of rotation around the axis of rotation, in radians.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the position of the layer, in meters.",
              "key": "Layer:getPosition",
              "module": "lovr.headset",
              "name": "getPosition",
              "related": [
                "Layer:getOrientation",
                "Layer:setOrientation",
                "Layer:getPose",
                "Layer:setPose",
                "Layer:setPosition",
                "Layer"
              ],
              "summary": "Get the position of the layer.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The x position of the layer.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y position of the layer.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z position of the layer.",
                      "name": "z",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the texture for the layer.  This is the texture that will be pasted onto the layer.",
              "key": "Layer:getTexture",
              "module": "lovr.headset",
              "name": "getTexture",
              "notes": "This function may return a different `Texture` object each frame.  The return value should not be cached.\n\nThe texture will have the `rgba8` format, with `sample` and `render` usage flags.",
              "related": ["Layer:getPass", "Layer"],
              "summary": "Get the texture for the layer.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The layer\u0027s texture.",
                      "name": "texture",
                      "type": "Texture"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the viewport of the layer.  The viewport is a 2D region of pixels that the layer will display within its plane.",
              "key": "Layer:getViewport",
              "module": "lovr.headset",
              "name": "getViewport",
              "related": ["Layer:setViewport", "Layer"],
              "summary": "Get the viewport of the layer.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The x coordinate of the upper-left corner of the viewport.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate of the upper-left corner of the viewport.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The width of the viewport, in pixels.",
                      "name": "w",
                      "type": "number"
                    },
                    {
                      "description": "The height of the viewport, in pixels.",
                      "name": "h",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Sets the color of the layer.  This will tint the contents of its texture.  It can be used to fade the layer without re-rendering its texture, which is especially useful for layers created with the `static` option.",
              "key": "Layer:setColor",
              "module": "lovr.headset",
              "name": "setColor",
              "notes": "The default color is white (all 1s).\n\nNot every headset system supports layer colors.  See the `layerColor` property of `lovr.headset.getFeatures` to check for support.",
              "related": ["Layer:getColor", "Layer"],
              "summary": "Set the color of the layer.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The red component of the color.",
                      "name": "r",
                      "type": "number"
                    },
                    {
                      "description": "The green component of the color.",
                      "name": "g",
                      "type": "number"
                    },
                    {
                      "description": "The blue component of the color.",
                      "name": "b",
                      "type": "number"
                    },
                    {
                      "default": "1.0",
                      "description": "The alpha component of the color.",
                      "name": "a",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "A table of 3 or 4 color components.",
                      "name": "t",
                      "type": "table"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "A hexcode.",
                      "name": "hex",
                      "type": "number"
                    },
                    {
                      "default": "1.0",
                      "description": "The alpha component of the color.",
                      "name": "a",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the curve of the layer.  Curving a layer renders it on a piece of a cylinder instead of a plane. The radius of the cylinder is `1 \/ curve` meters, so increasing the curve decreases the radius of the cylinder.",
              "key": "Layer:setCurve",
              "module": "lovr.headset",
              "name": "setCurve",
              "notes": "When a layer is created, its curve is zero.\n\nNot every headset system supports curved layers.  See the `layerCurve` property of `lovr.headset.getFeatures` to check for support.  If curved layers are not supported, this function will do nothing.\n\nNo matter what the curve is, the center of the layer texture will always get rendered at the layer\u0027s pose.\n\nThe largest possible curve is `2 * math.pi \/ width`, where `width` is the width of the layer in meters.  This would cause the cylinder to fully wrap around.",
              "related": ["Layer:getCurve", "Layer"],
              "summary": "Set the curve of the layer.",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "0",
                      "description": "The curve of the layer.  Negative values or zero means no curve.",
                      "name": "curve",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the width and height of the layer.  This is the size of the Layer\u0027s plane in meters, not not the resolution of the layer\u0027s texture in pixels.",
              "key": "Layer:setDimensions",
              "module": "lovr.headset",
              "name": "setDimensions",
              "notes": "When a layer is created, its width and height are 1 meter.",
              "related": ["Layer:getDimensions", "Layer"],
              "summary": "Set the size of the layer.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The width of the layer, in meters.",
                      "name": "width",
                      "type": "number"
                    },
                    {
                      "description": "The height of the layer, in meters.",
                      "name": "height",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the orientation of the layer.",
              "key": "Layer:setOrientation",
              "module": "lovr.headset",
              "name": "setOrientation",
              "related": [
                "Layer:getPosition",
                "Layer:setPosition",
                "Layer:getPose",
                "Layer:setPose",
                "Layer:getOrientation",
                "Layer"
              ],
              "summary": "Set the orientation of the layer.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The amount of rotation around the axis of rotation, in radians.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The orientation of the layer.",
                      "name": "orientation",
                      "type": "Quat"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the position and orientation of the layer.",
              "key": "Layer:setPose",
              "module": "lovr.headset",
              "name": "setPose",
              "notes": "Units are in meters.",
              "related": [
                "Layer:getPosition",
                "Layer:setPosition",
                "Layer:getOrientation",
                "Layer:setOrientation",
                "Layer:getPose",
                "Layer"
              ],
              "summary": "Set the pose of the layer.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The x position.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y position.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z position.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The amount of rotation around the axis of rotation, in radians.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The position of the layer.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "description": "The orientation of the layer.",
                      "name": "orientation",
                      "type": "Quat"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the position of the layer, in meters.",
              "key": "Layer:setPosition",
              "module": "lovr.headset",
              "name": "setPosition",
              "related": [
                "Layer:getOrientation",
                "Layer:setOrientation",
                "Layer:getPose",
                "Layer:setPose",
                "Layer:getPosition",
                "Layer"
              ],
              "summary": "Set the position of the layer.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The x position of the layer.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y position of the layer.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z position of the layer.",
                      "name": "z",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the viewport of the layer.  The viewport is a 2D region of pixels that the layer will display within its plane.",
              "key": "Layer:setViewport",
              "module": "lovr.headset",
              "name": "setViewport",
              "related": ["Layer:getViewport", "Layer"],
              "summary": "Set the viewport of the layer.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The x coordinate of the upper-left corner of the viewport.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate of the upper-left corner of the viewport.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The width of the viewport, in pixels.",
                      "name": "w",
                      "type": "number"
                    },
                    {
                      "description": "The height of the viewport, in pixels.",
                      "name": "h",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            }
          ],
          "module": "lovr.headset",
          "name": "Layer",
          "related": ["lovr.headset"],
          "summary": "A quad in 3D space."
        }
      ],
      "sections": [
        {
          "description": "Functions for accessing input devices, like controllers, hands, trackers, or gamepads.",
          "name": "Input",
          "tag": "input"
        },
        { "name": "Controller Models", "tag": "controller-models" },
        {
          "description": "Functions that return information about the active head mounted display (HMD).",
          "name": "Display",
          "tag": "headset"
        },
        {
          "description": "Retrieve information about the size and shape of the room the player is in, and provides information about the \"chaperone\", a visual indicator that appears whenever a player is about to run into a wall.",
          "name": "Play area",
          "tag": "playArea"
        },
        {
          "description": "Layers are 2D textured quads that can be placed in 3D space.  They are higher quality than rendering regular planes in the 3D scene.",
          "name": "Layers",
          "tag": "layers"
        },
        {
          "description": "Functions that are internal or return information about the VR session.",
          "name": "Miscellaneous",
          "tag": "headset-misc"
        }
      ],
      "summary": "Connects to VR hardware.",
      "tag": "modules"
    },
    {
      "description": "The `lovr.math` module provides math helpers commonly used for 3D applications.",
      "enums": {},
      "functions": [
        {
          "description": "Drains the temporary vector pool, invalidating existing temporary vectors.\n\nThis is called automatically at the end of each frame.",
          "key": "lovr.math.drain",
          "module": "lovr.math",
          "name": "drain",
          "related": ["lovr.math"],
          "summary": "Drain the temporary vector pool.",
          "tag": "vectors",
          "variants": [{ "arguments": {}, "returns": {} }]
        },
        {
          "description": "Converts a color from gamma space to linear space.",
          "key": "lovr.math.gammaToLinear",
          "module": "lovr.math",
          "name": "gammaToLinear",
          "related": ["lovr.math.linearToGamma", "lovr.math"],
          "summary": "Convert a color from gamma space to linear space.",
          "tag": "mathOther",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The red component of the gamma-space color.",
                  "name": "gr",
                  "type": "number"
                },
                {
                  "description": "The green component of the gamma-space color.",
                  "name": "gg",
                  "type": "number"
                },
                {
                  "description": "The blue component of the gamma-space color.",
                  "name": "gb",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "The red component of the resulting linear-space color.",
                  "name": "lr",
                  "type": "number"
                },
                {
                  "description": "The green component of the resulting linear-space color.",
                  "name": "lg",
                  "type": "number"
                },
                {
                  "description": "The blue component of the resulting linear-space color.",
                  "name": "lb",
                  "type": "number"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "A table containing the components of a gamma-space color.",
                  "name": "color",
                  "type": "table"
                }
              ],
              "description": "A table can also be used.",
              "returns": [
                {
                  "description": "The red component of the resulting linear-space color.",
                  "name": "lr",
                  "type": "number"
                },
                {
                  "description": "The green component of the resulting linear-space color.",
                  "name": "lg",
                  "type": "number"
                },
                {
                  "description": "The blue component of the resulting linear-space color.",
                  "name": "lb",
                  "type": "number"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The color channel to convert.",
                  "name": "x",
                  "type": "number"
                }
              ],
              "description": "Convert a single color channel.",
              "returns": [
                {
                  "description": "The converted color channel.",
                  "name": "y",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Get the seed used to initialize the random generator.",
          "key": "lovr.math.getRandomSeed",
          "module": "lovr.math",
          "name": "getRandomSeed",
          "related": ["lovr.math.setRandomSeed", "lovr.math"],
          "summary": "Get the random seed.",
          "tag": "random",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The new seed.",
                  "name": "seed",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Converts a color from linear space to gamma space.",
          "key": "lovr.math.linearToGamma",
          "module": "lovr.math",
          "name": "linearToGamma",
          "related": ["lovr.math.gammaToLinear", "lovr.math"],
          "summary": "Convert a color from linear space to gamma space.",
          "tag": "mathOther",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The red component of the linear-space color.",
                  "name": "lr",
                  "type": "number"
                },
                {
                  "description": "The green component of the linear-space color.",
                  "name": "lg",
                  "type": "number"
                },
                {
                  "description": "The blue component of the linear-space color.",
                  "name": "lb",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "The red component of the resulting gamma-space color.",
                  "name": "gr",
                  "type": "number"
                },
                {
                  "description": "The green component of the resulting gamma-space color.",
                  "name": "gg",
                  "type": "number"
                },
                {
                  "description": "The blue component of the resulting gamma-space color.",
                  "name": "gb",
                  "type": "number"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "A table containing the components of a linear-space color.",
                  "name": "color",
                  "type": "table"
                }
              ],
              "description": "A table can also be used.",
              "returns": [
                {
                  "description": "The red component of the resulting gamma-space color.",
                  "name": "gr",
                  "type": "number"
                },
                {
                  "description": "The green component of the resulting gamma-space color.",
                  "name": "gg",
                  "type": "number"
                },
                {
                  "description": "The blue component of the resulting gamma-space color.",
                  "name": "gb",
                  "type": "number"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The color channel to convert.",
                  "name": "x",
                  "type": "number"
                }
              ],
              "description": "Convert a single color channel.",
              "returns": [
                {
                  "description": "The converted color channel.",
                  "name": "y",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Creates a temporary 4D matrix.  This function takes the same arguments as `Mat4:set`.",
          "key": "lovr.math.mat4",
          "module": "lovr.math",
          "name": "mat4",
          "related": ["lovr.math.newMat4", "Mat4", "Vectors", "lovr.math"],
          "summary": "Create a temporary Mat4.",
          "tag": "vectors",
          "variants": [
            {
              "arguments": {},
              "description": "Sets the matrix to the identity matrix.",
              "returns": [
                {
                  "description": "The new matrix.",
                  "name": "m",
                  "type": "Mat4"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "An existing matrix to copy the values from.",
                  "name": "n",
                  "type": "Mat4"
                }
              ],
              "description": "Copies the values from an existing matrix.",
              "returns": [
                {
                  "description": "The new matrix.",
                  "name": "m",
                  "type": "Mat4"
                }
              ]
            },
            {
              "arguments": [
                {
                  "default": "0, 0, 0",
                  "description": "The translation of the matrix.",
                  "name": "position",
                  "type": "Vec3"
                },
                {
                  "default": "1, 1, 1",
                  "description": "The scale of the matrix.",
                  "name": "scale",
                  "type": "Vec3"
                },
                {
                  "default": "0, 0, 0, 1",
                  "description": "The rotation of the matrix.",
                  "name": "rotation",
                  "type": "Quat"
                }
              ],
              "returns": [
                {
                  "description": "The new matrix.",
                  "name": "m",
                  "type": "Mat4"
                }
              ]
            },
            {
              "arguments": [
                {
                  "default": "0, 0, 0",
                  "description": "The translation of the matrix.",
                  "name": "position",
                  "type": "Vec3"
                },
                {
                  "default": "0, 0, 0, 1",
                  "description": "The rotation of the matrix.",
                  "name": "rotation",
                  "type": "Quat"
                }
              ],
              "returns": [
                {
                  "description": "The new matrix.",
                  "name": "m",
                  "type": "Mat4"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "16 numbers to use as the raw values of the matrix (column-major).",
                  "name": "...",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "The new matrix.",
                  "name": "m",
                  "type": "Mat4"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "A number to use for the diagonal elements.",
                  "name": "d",
                  "type": "number"
                }
              ],
              "description": "Sets the diagonal values to a number and everything else to 0.",
              "returns": [
                {
                  "description": "The new matrix.",
                  "name": "m",
                  "type": "Mat4"
                }
              ]
            }
          ]
        },
        {
          "description": "Creates a new `Curve` from a list of control points.",
          "key": "lovr.math.newCurve",
          "module": "lovr.math",
          "name": "newCurve",
          "related": ["lovr.math"],
          "summary": "Create a new Curve.",
          "tag": "mathOther",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The x coordinate of the first control point.",
                  "name": "x",
                  "type": "number"
                },
                {
                  "description": "The y coordinate of the first control point.",
                  "name": "y",
                  "type": "number"
                },
                {
                  "description": "The z coordinate of the first control point.",
                  "name": "z",
                  "type": "number"
                },
                {
                  "description": "Additional control points.",
                  "name": "...",
                  "type": "*"
                }
              ],
              "description": "Create a Curve from a set of initial control points.",
              "returns": [
                {
                  "description": "The new Curve.",
                  "name": "curve",
                  "type": "Curve"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The first control point.",
                  "name": "v",
                  "type": "Vec3"
                },
                {
                  "description": "Additional control points.",
                  "name": "...",
                  "type": "*"
                }
              ],
              "description": "Create a Curve from a set of initial control points, using vectors.",
              "returns": [
                {
                  "description": "The new Curve.",
                  "name": "curve",
                  "type": "Curve"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "A table of control points, formatted as numbers or `Vec3` objects.",
                  "name": "points",
                  "type": "table"
                }
              ],
              "description": "Create a Curve from control points in a table.  The table values can be numbers or `Vec3` objects.",
              "returns": [
                {
                  "description": "The new Curve.",
                  "name": "curve",
                  "type": "Curve"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The number of points to reserve for the Curve.",
                  "name": "n",
                  "type": "number"
                }
              ],
              "description": "Create an empty Curve, reserving space ahead of time for a certain number of control points.",
              "returns": [
                {
                  "description": "The new Curve.",
                  "name": "curve",
                  "type": "Curve"
                }
              ]
            }
          ]
        },
        {
          "description": "Creates a new 4D matrix.  This function takes the same arguments as `Mat4:set`.",
          "key": "lovr.math.newMat4",
          "module": "lovr.math",
          "name": "newMat4",
          "related": ["lovr.math.mat4", "Mat4", "Vectors", "lovr.math"],
          "summary": "Create a new Mat4.",
          "tag": "vectors",
          "variants": [
            {
              "arguments": {},
              "description": "Sets the matrix to the identity matrix.",
              "returns": [
                {
                  "description": "The new matrix.",
                  "name": "m",
                  "type": "Mat4"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "An existing matrix to copy the values from.",
                  "name": "n",
                  "type": "Mat4"
                }
              ],
              "description": "Copies the values from an existing matrix.",
              "returns": [
                {
                  "description": "The new matrix.",
                  "name": "m",
                  "type": "Mat4"
                }
              ]
            },
            {
              "arguments": [
                {
                  "default": "0, 0, 0",
                  "description": "The translation of the matrix.",
                  "name": "position",
                  "type": "Vec3"
                },
                {
                  "default": "1, 1, 1",
                  "description": "The scale of the matrix.",
                  "name": "scale",
                  "type": "Vec3"
                },
                {
                  "default": "0, 0, 0, 1",
                  "description": "The rotation of the matrix.",
                  "name": "rotation",
                  "type": "Quat"
                }
              ],
              "returns": [
                {
                  "description": "The new matrix.",
                  "name": "m",
                  "type": "Mat4"
                }
              ]
            },
            {
              "arguments": [
                {
                  "default": "0, 0, 0",
                  "description": "The translation of the matrix.",
                  "name": "position",
                  "type": "Vec3"
                },
                {
                  "default": "0, 0, 0, 1",
                  "description": "The rotation of the matrix.",
                  "name": "rotation",
                  "type": "Quat"
                }
              ],
              "returns": [
                {
                  "description": "The new matrix.",
                  "name": "m",
                  "type": "Mat4"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "16 numbers to use as the raw values of the matrix (column-major).",
                  "name": "...",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "The new matrix.",
                  "name": "m",
                  "type": "Mat4"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "A number to use for the diagonal elements.",
                  "name": "d",
                  "type": "number"
                }
              ],
              "description": "Sets the diagonal values to a number and everything else to 0.",
              "returns": [
                {
                  "description": "The new matrix.",
                  "name": "m",
                  "type": "Mat4"
                }
              ]
            }
          ]
        },
        {
          "description": "Creates a new quaternion.  This function takes the same arguments as `Quat:set`.",
          "key": "lovr.math.newQuat",
          "module": "lovr.math",
          "name": "newQuat",
          "related": ["lovr.math.quat", "Quat", "Vectors", "lovr.math"],
          "summary": "Create a new Quat.",
          "tag": "vectors",
          "variants": [
            {
              "arguments": [
                {
                  "default": "0",
                  "description": "An angle to use for the rotation, in radians.",
                  "name": "angle",
                  "type": "number"
                },
                {
                  "default": "0",
                  "description": "The x component of the axis of rotation.",
                  "name": "ax",
                  "type": "number"
                },
                {
                  "default": "0",
                  "description": "The y component of the axis of rotation.",
                  "name": "ay",
                  "type": "number"
                },
                {
                  "default": "0",
                  "description": "The z component of the axis of rotation.",
                  "name": "az",
                  "type": "number"
                },
                {
                  "default": "false",
                  "description": "Whether the components should be interpreted as raw `(x, y, z, w)` components.",
                  "name": "raw",
                  "type": "boolean"
                }
              ],
              "returns": [
                {
                  "description": "The new quaternion.",
                  "name": "q",
                  "type": "Quat"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "An existing quaternion to copy the values from.",
                  "name": "r",
                  "type": "Quat"
                }
              ],
              "returns": [
                {
                  "description": "The new quaternion.",
                  "name": "q",
                  "type": "Quat"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "A normalized direction vector.",
                  "name": "v",
                  "type": "Vec3"
                }
              ],
              "description": "Uses the direction of a vector.",
              "returns": [
                {
                  "description": "The new quaternion.",
                  "name": "q",
                  "type": "Quat"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "A normalized direction vector.",
                  "name": "v",
                  "type": "Vec3"
                },
                {
                  "description": "Another normalized direction vector.",
                  "name": "u",
                  "type": "Vec3"
                }
              ],
              "description": "Sets the rotation to represent the rotation between two vectors.",
              "returns": [
                {
                  "description": "The new quaternion.",
                  "name": "q",
                  "type": "Quat"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "A matrix to use the rotation from.",
                  "name": "m",
                  "type": "Mat4"
                }
              ],
              "returns": [
                {
                  "description": "The new quaternion.",
                  "name": "q",
                  "type": "Quat"
                }
              ]
            },
            {
              "arguments": {},
              "description": "Set the quaternion to the identity (0, 0, 0, 1).",
              "returns": [
                {
                  "description": "The new quaternion.",
                  "name": "q",
                  "type": "Quat"
                }
              ]
            }
          ]
        },
        {
          "description": "Creates a new `RandomGenerator`, which can be used to generate random numbers. If you just want some random numbers, you can use `lovr.math.random`. Individual RandomGenerator objects are useful if you need more control over the random sequence used or need a random generator isolated from other instances.",
          "key": "lovr.math.newRandomGenerator",
          "module": "lovr.math",
          "name": "newRandomGenerator",
          "related": ["lovr.math"],
          "summary": "Create a new RandomGenerator.",
          "tag": "random",
          "variants": [
            {
              "arguments": {},
              "description": "Create a RandomGenerator with a default seed.",
              "returns": [
                {
                  "description": "The new RandomGenerator.",
                  "name": "randomGenerator",
                  "type": "RandomGenerator"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The initial seed for the RandomGenerator.",
                  "name": "seed",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "The new RandomGenerator.",
                  "name": "randomGenerator",
                  "type": "RandomGenerator"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The lower 32 bits of the seed.",
                  "name": "low",
                  "type": "number"
                },
                {
                  "description": "The upper 32 bits of the seed.",
                  "name": "high",
                  "type": "number"
                }
              ],
              "description": "This variant allows creation of random generators with precise 64-bit seed values, since Lua\u0027s number format loses precision with really big numbers.",
              "returns": [
                {
                  "description": "The new RandomGenerator.",
                  "name": "randomGenerator",
                  "type": "RandomGenerator"
                }
              ]
            }
          ]
        },
        {
          "description": "Creates a new 2D vector.  This function takes the same arguments as `Vec2:set`.",
          "key": "lovr.math.newVec2",
          "module": "lovr.math",
          "name": "newVec2",
          "related": ["lovr.math.vec2", "Vec2", "Vectors", "lovr.math"],
          "summary": "Create a new Vec2.",
          "tag": "vectors",
          "variants": [
            {
              "arguments": [
                {
                  "default": "0",
                  "description": "The x value of the vector.",
                  "name": "x",
                  "type": "number"
                },
                {
                  "default": "x",
                  "description": "The y value of the vector.",
                  "name": "y",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "The new vector.",
                  "name": "v",
                  "type": "Vec2"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "A vector to copy the values from.",
                  "name": "u",
                  "type": "Vec2"
                }
              ],
              "returns": [
                {
                  "description": "The new vector.",
                  "name": "v",
                  "type": "Vec2"
                }
              ]
            }
          ]
        },
        {
          "description": "Creates a new 3D vector.  This function takes the same arguments as `Vec3:set`.",
          "key": "lovr.math.newVec3",
          "module": "lovr.math",
          "name": "newVec3",
          "related": ["lovr.math.vec3", "Vec3", "Vectors", "lovr.math"],
          "summary": "Create a new Vec3.",
          "tag": "vectors",
          "variants": [
            {
              "arguments": [
                {
                  "default": "0",
                  "description": "The x value of the vector.",
                  "name": "x",
                  "type": "number"
                },
                {
                  "default": "x",
                  "description": "The y value of the vector.",
                  "name": "y",
                  "type": "number"
                },
                {
                  "default": "x",
                  "description": "The z value of the vector.",
                  "name": "z",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "The new vector.",
                  "name": "v",
                  "type": "Vec3"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "A vector to copy the values from.",
                  "name": "u",
                  "type": "Vec3"
                }
              ],
              "returns": [
                {
                  "description": "The new vector.",
                  "name": "v",
                  "type": "Vec3"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "A matrix to use the position of.",
                  "name": "m",
                  "type": "Mat4"
                }
              ],
              "returns": [
                {
                  "description": "The new vector.",
                  "name": "v",
                  "type": "Vec3"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "A quat to use the direction of.",
                  "name": "q",
                  "type": "Quat"
                }
              ],
              "returns": [
                {
                  "description": "The new vector.",
                  "name": "v",
                  "type": "Vec3"
                }
              ]
            }
          ]
        },
        {
          "description": "Creates a new 4D vector.  This function takes the same arguments as `Vec4:set`.",
          "key": "lovr.math.newVec4",
          "module": "lovr.math",
          "name": "newVec4",
          "related": ["lovr.math.vec4", "Vec4", "Vectors", "lovr.math"],
          "summary": "Create a new Vec4.",
          "tag": "vectors",
          "variants": [
            {
              "arguments": [
                {
                  "default": "0",
                  "description": "The x value of the vector.",
                  "name": "x",
                  "type": "number"
                },
                {
                  "default": "x",
                  "description": "The y value of the vector.",
                  "name": "y",
                  "type": "number"
                },
                {
                  "default": "x",
                  "description": "The z value of the vector.",
                  "name": "z",
                  "type": "number"
                },
                {
                  "default": "x",
                  "description": "The w value of the vector.",
                  "name": "w",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "The new vector.",
                  "name": "v",
                  "type": "Vec4"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "A vector to copy the values from.",
                  "name": "u",
                  "type": "Vec4"
                }
              ],
              "returns": [
                {
                  "description": "The new vector.",
                  "name": "v",
                  "type": "Vec4"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns a 1D, 2D, 3D, or 4D simplex noise value.  The number will be between 0 and 1.",
          "key": "lovr.math.noise",
          "module": "lovr.math",
          "name": "noise",
          "related": ["lovr.math.random", "lovr.math"],
          "summary": "Generate simplex noise.",
          "tag": "random",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The x coordinate of the input.",
                  "name": "x",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "The noise value, between 0 and 1.",
                  "name": "noise",
                  "type": "number"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The x coordinate of the input.",
                  "name": "x",
                  "type": "number"
                },
                {
                  "description": "The y coordinate of the input.",
                  "name": "y",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "The noise value, between 0 and 1.",
                  "name": "noise",
                  "type": "number"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The x coordinate of the input.",
                  "name": "x",
                  "type": "number"
                },
                {
                  "description": "The y coordinate of the input.",
                  "name": "y",
                  "type": "number"
                },
                {
                  "description": "The z coordinate of the input.",
                  "name": "z",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "The noise value, between 0 and 1.",
                  "name": "noise",
                  "type": "number"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The x coordinate of the input.",
                  "name": "x",
                  "type": "number"
                },
                {
                  "description": "The y coordinate of the input.",
                  "name": "y",
                  "type": "number"
                },
                {
                  "description": "The z coordinate of the input.",
                  "name": "z",
                  "type": "number"
                },
                {
                  "description": "The w coordinate of the input.",
                  "name": "w",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "The noise value, between 0 and 1.",
                  "name": "noise",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Creates a temporary quaternion.  This function takes the same arguments as `Quat:set`.",
          "key": "lovr.math.quat",
          "module": "lovr.math",
          "name": "quat",
          "related": ["lovr.math.newQuat", "Quat", "Vectors", "lovr.math"],
          "summary": "Create a temporary Quat.",
          "tag": "vectors",
          "variants": [
            {
              "arguments": [
                {
                  "default": "0",
                  "description": "An angle to use for the rotation, in radians.",
                  "name": "angle",
                  "type": "number"
                },
                {
                  "default": "0",
                  "description": "The x component of the axis of rotation.",
                  "name": "ax",
                  "type": "number"
                },
                {
                  "default": "0",
                  "description": "The y component of the axis of rotation.",
                  "name": "ay",
                  "type": "number"
                },
                {
                  "default": "0",
                  "description": "The z component of the axis of rotation.",
                  "name": "az",
                  "type": "number"
                },
                {
                  "default": "false",
                  "description": "Whether the components should be interpreted as raw `(x, y, z, w)` components.",
                  "name": "raw",
                  "type": "boolean"
                }
              ],
              "returns": [
                {
                  "description": "The new quaternion.",
                  "name": "q",
                  "type": "Quat"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "An existing quaternion to copy the values from.",
                  "name": "r",
                  "type": "Quat"
                }
              ],
              "returns": [
                {
                  "description": "The new quaternion.",
                  "name": "q",
                  "type": "Quat"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "A normalized direction vector.",
                  "name": "v",
                  "type": "Vec3"
                }
              ],
              "description": "Uses the direction of a vector.",
              "returns": [
                {
                  "description": "The new quaternion.",
                  "name": "q",
                  "type": "Quat"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "A normalized direction vector.",
                  "name": "v",
                  "type": "Vec3"
                },
                {
                  "description": "Another normalized direction vector.",
                  "name": "u",
                  "type": "Vec3"
                }
              ],
              "description": "Sets the rotation to represent the rotation between two vectors.",
              "returns": [
                {
                  "description": "The new quaternion.",
                  "name": "q",
                  "type": "Quat"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "A matrix to use the rotation from.",
                  "name": "m",
                  "type": "Mat4"
                }
              ],
              "returns": [
                {
                  "description": "The new quaternion.",
                  "name": "q",
                  "type": "Quat"
                }
              ]
            },
            {
              "arguments": {},
              "description": "Set the quaternion to the identity (0, 0, 0, 1).",
              "returns": [
                {
                  "description": "The new quaternion.",
                  "name": "q",
                  "type": "Quat"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns a uniformly distributed pseudo-random number.  This function has improved randomness over Lua\u0027s `math.random` and also guarantees that the sequence of random numbers will be the same on all platforms (given the same seed).",
          "key": "lovr.math.random",
          "module": "lovr.math",
          "name": "random",
          "notes": "You can set the random seed using `lovr.math.setRandomSeed`.",
          "related": [
            "lovr.math.randomNormal",
            "RandomGenerator",
            "lovr.math.noise",
            "lovr.math"
          ],
          "summary": "Get a random number.",
          "tag": "random",
          "variants": [
            {
              "arguments": {},
              "description": "Generate a pseudo-random floating point number in the range `[0,1)`",
              "returns": [
                {
                  "description": "A pseudo-random number.",
                  "name": "x",
                  "type": "number"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The maximum number to generate.",
                  "name": "high",
                  "type": "number"
                }
              ],
              "description": "Generate a pseudo-random integer in the range `[1,high]`",
              "returns": [
                {
                  "description": "A pseudo-random number.",
                  "name": "x",
                  "type": "number"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The minimum number to generate.",
                  "name": "low",
                  "type": "number"
                },
                {
                  "description": "The maximum number to generate.",
                  "name": "high",
                  "type": "number"
                }
              ],
              "description": "Generate a pseudo-random integer in the range `[low,high]`",
              "returns": [
                {
                  "description": "A pseudo-random number.",
                  "name": "x",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns a pseudo-random number from a normal distribution (a bell curve).  You can control the center of the bell curve (the mean value) and the overall width (sigma, or standard deviation).",
          "key": "lovr.math.randomNormal",
          "module": "lovr.math",
          "name": "randomNormal",
          "related": ["lovr.math.random", "RandomGenerator", "lovr.math"],
          "summary": "Get a random number from a normal distribution.",
          "tag": "random",
          "variants": [
            {
              "arguments": [
                {
                  "default": "1",
                  "description": "The standard deviation of the distribution.  This can be thought of how \"wide\" the range of numbers is or how much variability there is.",
                  "name": "sigma",
                  "type": "number"
                },
                {
                  "default": "0",
                  "description": "The average value returned.",
                  "name": "mu",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "A normally distributed pseudo-random number.",
                  "name": "x",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Seed the random generator with a new seed.  Each seed will cause `lovr.math.random` and `lovr.math.randomNormal` to produce a unique sequence of random numbers.  This is done once automatically at startup by `lovr.run`.",
          "key": "lovr.math.setRandomSeed",
          "module": "lovr.math",
          "name": "setRandomSeed",
          "related": ["lovr.math.getRandomSeed", "lovr.math"],
          "summary": "Set the random seed.",
          "tag": "random",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The new seed.",
                  "name": "seed",
                  "type": "number"
                }
              ],
              "returns": {}
            }
          ]
        },
        {
          "description": "Creates a temporary 2D vector.  This function takes the same arguments as `Vec2:set`.",
          "key": "lovr.math.vec2",
          "module": "lovr.math",
          "name": "vec2",
          "related": ["lovr.math.newVec2", "Vec2", "Vectors", "lovr.math"],
          "summary": "Create a temporary Vec2.",
          "tag": "vectors",
          "variants": [
            {
              "arguments": [
                {
                  "default": "0",
                  "description": "The x value of the vector.",
                  "name": "x",
                  "type": "number"
                },
                {
                  "default": "x",
                  "description": "The y value of the vector.",
                  "name": "y",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "The new vector.",
                  "name": "v",
                  "type": "Vec2"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "A vector to copy the values from.",
                  "name": "u",
                  "type": "Vec2"
                }
              ],
              "returns": [
                {
                  "description": "The new vector.",
                  "name": "v",
                  "type": "Vec2"
                }
              ]
            }
          ]
        },
        {
          "description": "Creates a temporary 3D vector.  This function takes the same arguments as `Vec3:set`.",
          "key": "lovr.math.vec3",
          "module": "lovr.math",
          "name": "vec3",
          "related": ["lovr.math.newVec3", "Vec3", "Vectors", "lovr.math"],
          "summary": "Create a temporary Vec3.",
          "tag": "vectors",
          "variants": [
            {
              "arguments": [
                {
                  "default": "0",
                  "description": "The x value of the vector.",
                  "name": "x",
                  "type": "number"
                },
                {
                  "default": "x",
                  "description": "The y value of the vector.",
                  "name": "y",
                  "type": "number"
                },
                {
                  "default": "x",
                  "description": "The z value of the vector.",
                  "name": "z",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "The new vector.",
                  "name": "v",
                  "type": "Vec3"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "A vector to copy the values from.",
                  "name": "u",
                  "type": "Vec3"
                }
              ],
              "returns": [
                {
                  "description": "The new vector.",
                  "name": "v",
                  "type": "Vec3"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "A matrix to use the position of.",
                  "name": "m",
                  "type": "Mat4"
                }
              ],
              "returns": [
                {
                  "description": "The new vector.",
                  "name": "v",
                  "type": "Vec3"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "A quat to use the direction of.",
                  "name": "q",
                  "type": "Quat"
                }
              ],
              "returns": [
                {
                  "description": "The new vector.",
                  "name": "v",
                  "type": "Vec3"
                }
              ]
            }
          ]
        },
        {
          "description": "Creates a temporary 4D vector.  This function takes the same arguments as `Vec4:set`.",
          "key": "lovr.math.vec4",
          "module": "lovr.math",
          "name": "vec4",
          "related": ["lovr.math.newVec4", "Vec4", "Vectors", "lovr.math"],
          "summary": "Create a temporary Vec4.",
          "tag": "vectors",
          "variants": [
            {
              "arguments": [
                {
                  "default": "0",
                  "description": "The x value of the vector.",
                  "name": "x",
                  "type": "number"
                },
                {
                  "default": "x",
                  "description": "The y value of the vector.",
                  "name": "y",
                  "type": "number"
                },
                {
                  "default": "x",
                  "description": "The z value of the vector.",
                  "name": "z",
                  "type": "number"
                },
                {
                  "default": "x",
                  "description": "The w value of the vector.",
                  "name": "w",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "The new vector.",
                  "name": "v",
                  "type": "Vec4"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "A vector to copy the values from.",
                  "name": "u",
                  "type": "Vec4"
                }
              ],
              "returns": [
                {
                  "description": "The new vector.",
                  "name": "v",
                  "type": "Vec4"
                }
              ]
            }
          ]
        }
      ],
      "key": "lovr.math",
      "name": "math",
      "objects": [
        {
          "constructors": ["lovr.math.newCurve", "Curve:slice"],
          "description": "A Curve is an object that represents a B\u00e9zier curve in three dimensions.  Curves are defined by an arbitrary number of control points (note that the curve only passes through the first and last control point).\n\nOnce a Curve is created with `lovr.math.newCurve`, you can use `Curve:evaluate` to get a point on the curve or `Curve:render` to get a list of all of the points on the curve.  These points can be passed directly to `Pass:points` or `Pass:line` to render the curve.\n\nNote that for longer or more complicated curves (like in a drawing application) it can be easier to store the path as several Curve objects.",
          "key": "Curve",
          "methods": [
            {
              "description": "Inserts a new control point into the Curve at the specified index.",
              "key": "Curve:addPoint",
              "module": "lovr.math",
              "name": "addPoint",
              "notes": "An error will be thrown if the index is less than one or more than the number of control points.",
              "related": [
                "Curve:getPointCount",
                "Curve:getPoint",
                "Curve:setPoint",
                "Curve:removePoint",
                "Curve"
              ],
              "summary": "Add a new control point to the Curve.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The x coordinate of the control point.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate of the control point.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z coordinate of the control point.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "The index to insert the control point at.  If nil, the control point is added to the end of the list of control points.",
                      "name": "index",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Returns a point on the Curve given a parameter `t` from 0 to 1.  0 will return the first control point, 1 will return the last point, .5 will return a point in the \"middle\" of the Curve, etc.",
              "key": "Curve:evaluate",
              "module": "lovr.math",
              "name": "evaluate",
              "notes": "An error will be thrown if `t` is not between 0 and 1, or if the Curve has less than two points.",
              "related": [
                "Curve:getTangent",
                "Curve:render",
                "Curve:slice",
                "Curve"
              ],
              "summary": "Turn a number from 0 to 1 into a point on the Curve.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The parameter to evaluate the Curve at.",
                      "name": "t",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The x position of the point.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y position of the point.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z position of the point.",
                      "name": "z",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns a control point of the Curve.",
              "key": "Curve:getPoint",
              "module": "lovr.math",
              "name": "getPoint",
              "notes": "An error will be thrown if the index is less than one or more than the number of control points.",
              "related": [
                "Curve:getPointCount",
                "Curve:setPoint",
                "Curve:addPoint",
                "Curve:removePoint",
                "Curve:setPoint",
                "Curve"
              ],
              "summary": "Get a control point of the Curve.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index to retrieve.",
                      "name": "index",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The x coordinate of the control point.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate of the control point.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z coordinate of the control point.",
                      "name": "z",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the number of control points in the Curve.",
              "key": "Curve:getPointCount",
              "module": "lovr.math",
              "name": "getPointCount",
              "related": [
                "Curve:getPoint",
                "Curve:setPoint",
                "Curve:addPoint",
                "Curve:removePoint",
                "Curve"
              ],
              "summary": "Get the number of control points in the Curve.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The number of control points.",
                      "name": "count",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns a direction vector for the Curve given a parameter `t` from 0 to 1.  0 will return the direction at the first control point, 1 will return the direction at the last point, .5 will return the direction at the \"middle\" of the Curve, etc.",
              "key": "Curve:getTangent",
              "module": "lovr.math",
              "name": "getTangent",
              "notes": "The direction vector returned by this function will have a length of one.",
              "related": [
                "Curve:evaluate",
                "Curve:render",
                "Curve:slice",
                "Curve"
              ],
              "summary": "Get the direction of the Curve at a point.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "Where on the Curve to compute the direction.",
                      "name": "t",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The x position of the point.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y position of the point.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z position of the point.",
                      "name": "z",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Removes a control point from the Curve.",
              "key": "Curve:removePoint",
              "module": "lovr.math",
              "name": "removePoint",
              "notes": "An error will be thrown if the index is less than one or more than the number of control points.",
              "related": [
                "Curve:getPointCount",
                "Curve:getPoint",
                "Curve:setPoint",
                "Curve:addPoint",
                "Curve"
              ],
              "summary": "Remove a control point from the Curve.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of the control point to remove.",
                      "name": "index",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Returns a list of points on the Curve.  The number of points can be specified to get a more or less detailed representation, and it is also possible to render a subsection of the Curve.",
              "key": "Curve:render",
              "module": "lovr.math",
              "name": "render",
              "notes": "This function will always return 2 points if the Curve is a line with only 2 control points.",
              "related": [
                "Curve:evaluate",
                "Curve:slice",
                "Pass:points",
                "Pass:line",
                "Pass:mesh",
                "Curve"
              ],
              "summary": "Get a list of points on the Curve.",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "32",
                      "description": "The number of points to use.",
                      "name": "n",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "How far along the curve to start rendering.",
                      "name": "t1",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "How far along the curve to stop rendering.",
                      "name": "t2",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "A (flat) table of 3D points along the curve.",
                      "name": "t",
                      "type": "table"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Changes the position of a control point on the Curve.",
              "key": "Curve:setPoint",
              "module": "lovr.math",
              "name": "setPoint",
              "notes": "An error will be thrown if the index is less than one or more than the number of control points.",
              "related": [
                "Curve:getPointCount",
                "Curve:getPoint",
                "Curve:addPoint",
                "Curve:removePoint",
                "Curve:getPoint",
                "Curve"
              ],
              "summary": "Set a control point of the Curve.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index to modify.",
                      "name": "index",
                      "type": "number"
                    },
                    {
                      "description": "The new x coordinate.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The new y coordinate.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The new z coordinate.",
                      "name": "z",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Returns a new Curve created by slicing the Curve at the specified start and end points.",
              "key": "Curve:slice",
              "module": "lovr.math",
              "name": "slice",
              "notes": "The new Curve will have the same number of control points as the existing curve.\n\nAn error will be thrown if t1 or t2 are not between 0 and 1, or if the Curve has less than two points.",
              "related": ["Curve:evaluate", "Curve:render", "Curve"],
              "summary": "Get a new Curve from a slice of an existing one.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The starting point to slice at.",
                      "name": "t1",
                      "type": "number"
                    },
                    {
                      "description": "The ending point to slice at.",
                      "name": "t2",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "A new Curve.",
                      "name": "curve",
                      "type": "Curve"
                    }
                  ]
                }
              ]
            }
          ],
          "module": "lovr.math",
          "name": "Curve",
          "related": ["lovr.math"],
          "summary": "A B\u00e9zier curve."
        },
        {
          "constructors": ["lovr.math.newMat4", "lovr.math.mat4"],
          "description": "A `mat4` is a math type that holds 16 values in a 4x4 grid.",
          "key": "Mat4",
          "methods": [
            {
              "description": "Returns whether a matrix is approximately equal to another matrix.",
              "key": "Mat4:equals",
              "module": "lovr.math",
              "name": "equals",
              "related": [
                "Vec2:equals",
                "Vec3:equals",
                "Vec4:equals",
                "Quat:equals",
                "Mat4"
              ],
              "summary": "Check if a matrix equals another matrix.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The other matrix.",
                      "name": "n",
                      "type": "Mat4"
                    }
                  ],
                  "returns": [
                    {
                      "description": "Whether the 2 matrices approximately equal each other.",
                      "name": "equal",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Sets a projection matrix using raw projection angles and clipping planes.\n\nThis can be used for asymmetric or oblique projections.",
              "key": "Mat4:fov",
              "module": "lovr.math",
              "name": "fov",
              "related": [
                "Mat4:orthographic",
                "Mat4:perspective",
                "Pass:setProjection",
                "Mat4"
              ],
              "summary": "Set a projection using raw field of view angles.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The left half-angle of the projection, in radians.",
                      "name": "left",
                      "type": "number"
                    },
                    {
                      "description": "The right half-angle of the projection, in radians.",
                      "name": "right",
                      "type": "number"
                    },
                    {
                      "description": "The top half-angle of the projection, in radians.",
                      "name": "up",
                      "type": "number"
                    },
                    {
                      "description": "The bottom half-angle of the projection, in radians.",
                      "name": "down",
                      "type": "number"
                    },
                    {
                      "description": "The near plane of the projection.",
                      "name": "near",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The far plane.  Zero is a special value that will set an infinite far plane with a reversed Z range, which improves depth buffer precision and is the default.",
                      "name": "far",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified matrix.",
                      "name": "self",
                      "type": "Mat4"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the angle\/axis rotation of the matrix.",
              "key": "Mat4:getOrientation",
              "module": "lovr.math",
              "name": "getOrientation",
              "related": [
                "Mat4:getPosition",
                "Mat4:getScale",
                "Mat4:getPose",
                "Mat4:unpack",
                "Mat4:set",
                "Mat4"
              ],
              "summary": "Get the angle\/axis rotation of the matrix.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The number of radians the matrix rotates around its rotation axis.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the position and rotation of the matrix.",
              "key": "Mat4:getPose",
              "module": "lovr.math",
              "name": "getPose",
              "related": [
                "Mat4:getPosition",
                "Mat4:getOrientation",
                "Mat4:getScale",
                "Mat4:unpack",
                "Mat4:set",
                "Mat4"
              ],
              "summary": "Get the position and rotation of the matrix.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The x translation.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y translation.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z translation.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The number of radians the matrix rotates around its rotation axis.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the translation of the matrix.  This is the last column of the matrix.",
              "key": "Mat4:getPosition",
              "module": "lovr.math",
              "name": "getPosition",
              "related": [
                "Mat4:getOrientation",
                "Mat4:getScale",
                "Mat4:getPose",
                "Mat4:unpack",
                "Mat4:set",
                "Mat4"
              ],
              "summary": "Get the translation of the matrix.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The x translation.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y translation.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z translation.",
                      "name": "z",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the scale factor of the matrix.",
              "key": "Mat4:getScale",
              "module": "lovr.math",
              "name": "getScale",
              "related": [
                "Mat4:getPosition",
                "Mat4:getOrientation",
                "Mat4:getPose",
                "Mat4:unpack",
                "Mat4:set",
                "Mat4"
              ],
              "summary": "Get the scale factor of the matrix.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The x scale.",
                      "name": "sx",
                      "type": "number"
                    },
                    {
                      "description": "The y scale.",
                      "name": "sy",
                      "type": "number"
                    },
                    {
                      "description": "The z scale.",
                      "name": "sz",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Resets the matrix to the identity, effectively setting its translation to zero, its scale to 1, and clearing any rotation.",
              "key": "Mat4:identity",
              "module": "lovr.math",
              "name": "identity",
              "related": ["Pass:origin", "Mat4"],
              "summary": "Reset the matrix to the identity.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The modified matrix.",
                      "name": "self",
                      "type": "Mat4"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Inverts the matrix, causing it to represent the opposite of its old transform.",
              "key": "Mat4:invert",
              "module": "lovr.math",
              "name": "invert",
              "related": ["Mat4"],
              "summary": "Invert the matrix.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The inverted matrix.",
                      "name": "self",
                      "type": "Mat4"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Sets a view transform matrix that moves and orients camera to look at a target point.\n\nThis is useful for changing camera position and orientation.\n\nThe lookAt() function produces same result as target() after matrix inversion.",
              "examples": [
                {
                  "code": "function lovr.draw(pass)\n  pass:setViewPose(1, mat4():lookAt(cameraPos, playerPos), true)\n\n  -- draw scene\nend"
                }
              ],
              "key": "Mat4:lookAt",
              "module": "lovr.math",
              "name": "lookAt",
              "related": ["Mat4:target", "Quat:direction", "Mat4"],
              "summary": "Create a view transform that looks from a position to target position.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The position of the viewer.",
                      "name": "from",
                      "type": "Vec3"
                    },
                    {
                      "description": "The position of the target.",
                      "name": "to",
                      "type": "Vec3"
                    },
                    {
                      "default": "Vec3(0, 1, 0)",
                      "description": "The up vector of the viewer.",
                      "name": "up",
                      "type": "Vec3"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified matrix.",
                      "name": "self",
                      "type": "Mat4"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Multiplies this matrix by another value.  Multiplying by a matrix combines their two transforms together.  Multiplying by a vector applies the transformation from the matrix to the vector and returns the vector.",
              "key": "Mat4:mul",
              "module": "lovr.math",
              "name": "mul",
              "notes": "When multiplying by a vec4, the vector is treated as either a point if its w component is 1, or a direction vector if the w is 0 (the matrix translation won\u0027t be applied).",
              "related": [
                "Mat4:translate",
                "Mat4:rotate",
                "Mat4:scale",
                "Mat4"
              ],
              "summary": "Multiply a matrix with another matrix or a vector.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The matrix.",
                      "name": "n",
                      "type": "Mat4"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified matrix.",
                      "name": "self",
                      "type": "Mat4"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A 3D vector, treated as a point.",
                      "name": "v3",
                      "type": "Vec3"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The transformed vector.",
                      "name": "v3",
                      "type": "Vec3"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A 4D vector.",
                      "name": "v4",
                      "type": "Vec4"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The transformed vector.",
                      "name": "v4",
                      "type": "Vec4"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Sets this matrix to represent an orthographic projection, useful for 2D\/isometric rendering.\n\nThis can be used with `Pass:setProjection`, or it can be sent to a `Shader` for use in GLSL.",
              "key": "Mat4:orthographic",
              "module": "lovr.math",
              "name": "orthographic",
              "related": [
                "Mat4:perspective",
                "Mat4:fov",
                "Pass:setProjection",
                "Mat4"
              ],
              "summary": "Turn the matrix into an orthographic projection.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The left edge of the projection.",
                      "name": "left",
                      "type": "number"
                    },
                    {
                      "description": "The right edge of the projection.",
                      "name": "right",
                      "type": "number"
                    },
                    {
                      "description": "The bottom edge of the projection.",
                      "name": "bottom",
                      "type": "number"
                    },
                    {
                      "description": "The top edge of the projection.",
                      "name": "top",
                      "type": "number"
                    },
                    {
                      "description": "The position of the near clipping plane.",
                      "name": "near",
                      "type": "number"
                    },
                    {
                      "description": "The position of the far clipping plane.",
                      "name": "far",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified matrix.",
                      "name": "self",
                      "type": "Mat4"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The width of the projection.",
                      "name": "width",
                      "type": "number"
                    },
                    {
                      "description": "The height of the projection.",
                      "name": "height",
                      "type": "number"
                    },
                    {
                      "description": "The position of the near clipping plane.",
                      "name": "near",
                      "type": "number"
                    },
                    {
                      "description": "The position of the far clipping plane.",
                      "name": "far",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified matrix.",
                      "name": "self",
                      "type": "Mat4"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Sets this matrix to represent a perspective projection.\n\nThis can be used with `Pass:setProjection`, or it can be sent to a `Shader` for use in GLSL.",
              "key": "Mat4:perspective",
              "module": "lovr.math",
              "name": "perspective",
              "related": [
                "Mat4:orthographic",
                "Mat4:fov",
                "Pass:setProjection",
                "Mat4"
              ],
              "summary": "Turn the matrix into a perspective projection.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The vertical field of view (in radians).",
                      "name": "fov",
                      "type": "number"
                    },
                    {
                      "description": "The horizontal aspect ratio of the projection (width \/ height).",
                      "name": "aspect",
                      "type": "number"
                    },
                    {
                      "description": "The near plane.",
                      "name": "near",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The far plane.  Zero is a special value that will set an infinite far plane with a reversed Z range, which improves depth buffer precision and is the default.",
                      "name": "far",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified matrix.",
                      "name": "self",
                      "type": "Mat4"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Turns the matrix into a reflection matrix that transforms values as though they were reflected across a plane.",
              "key": "Mat4:reflect",
              "module": "lovr.math",
              "name": "reflect",
              "related": ["Mat4"],
              "summary": "Create a matrix that reflects across a plane.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The position of the plane.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "description": "The normal vector of the plane.",
                      "name": "normal",
                      "type": "Vec3"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The reflected matrix.",
                      "name": "self",
                      "type": "Mat4"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Rotates the matrix using a quaternion or an angle\/axis rotation.",
              "key": "Mat4:rotate",
              "module": "lovr.math",
              "name": "rotate",
              "related": [
                "Mat4:translate",
                "Mat4:scale",
                "Mat4:identity",
                "Mat4"
              ],
              "summary": "Rotate the matrix.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The rotation to apply to the matrix.",
                      "name": "q",
                      "type": "Quat"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The rotated matrix.",
                      "name": "self",
                      "type": "Mat4"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The angle component of the angle\/axis rotation (radians).",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The rotated matrix.",
                      "name": "self",
                      "type": "Mat4"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Scales the matrix.",
              "key": "Mat4:scale",
              "module": "lovr.math",
              "name": "scale",
              "related": [
                "Mat4:translate",
                "Mat4:rotate",
                "Mat4:identity",
                "Mat4"
              ],
              "summary": "Scale the matrix.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The 3D scale to apply.",
                      "name": "scale",
                      "type": "Vec3"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified matrix.",
                      "name": "self",
                      "type": "Mat4"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The x component of the scale to apply.",
                      "name": "sx",
                      "type": "number"
                    },
                    {
                      "default": "sx",
                      "description": "The y component of the scale to apply.",
                      "name": "sy",
                      "type": "number"
                    },
                    {
                      "default": "sx",
                      "description": "The z component of the scale to apply.",
                      "name": "sz",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified matrix.",
                      "name": "self",
                      "type": "Mat4"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Sets the components of the matrix from separate position, rotation, and scale arguments or an existing matrix.",
              "key": "Mat4:set",
              "module": "lovr.math",
              "name": "set",
              "related": ["Mat4:unpack", "Mat4"],
              "summary": "Set the components of the matrix.",
              "variants": [
                {
                  "arguments": {},
                  "description": "Resets the matrix to the identity matrix, without any translation, rotation, or scale.",
                  "returns": [
                    {
                      "description": "The input matrix.",
                      "name": "m",
                      "type": "Mat4"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "An existing matrix to copy the values from.",
                      "name": "n",
                      "type": "Mat4"
                    }
                  ],
                  "description": "Copies the values from an existing matrix.",
                  "returns": [
                    {
                      "description": "The input matrix.",
                      "name": "m",
                      "type": "Mat4"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The x component of the translation.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the translation.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the translation.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the scale.",
                      "name": "sx",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the scale.",
                      "name": "sy",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the scale.",
                      "name": "sz",
                      "type": "number"
                    },
                    {
                      "description": "The angle of the rotation, in radians.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    }
                  ],
                  "description": "Sets the position, scale, and rotation of the matrix using numbers.",
                  "returns": [
                    {
                      "description": "The input matrix.",
                      "name": "m",
                      "type": "Mat4"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The x component of the translation.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the translation.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the translation.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The angle of the rotation, in radians.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    }
                  ],
                  "description": "Sets the pose (position and orientation) of the matrix using numbers.  The scale is set to 1 on all axes.",
                  "returns": [
                    {
                      "description": "The input matrix.",
                      "name": "m",
                      "type": "Mat4"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The translation of the matrix.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "description": "The scale of the matrix.",
                      "name": "scale",
                      "type": "Vec3"
                    },
                    {
                      "description": "The rotation of the matrix.",
                      "name": "rotation",
                      "type": "Quat"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The input matrix.",
                      "name": "m",
                      "type": "Mat4"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The translation of the matrix.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "description": "The rotation of the matrix.",
                      "name": "rotation",
                      "type": "Quat"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The input matrix.",
                      "name": "m",
                      "type": "Mat4"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The raw values of the matrix, in column-major order.",
                      "name": "...",
                      "type": "number"
                    }
                  ],
                  "description": "Sets the raw components of the matrix using 16 numbers in column-major order.",
                  "returns": [
                    {
                      "description": "The input matrix.",
                      "name": "m",
                      "type": "Mat4"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A number to use for the diagonal elements.",
                      "name": "d",
                      "type": "number"
                    }
                  ],
                  "description": "Sets the diagonal values to a number and everything else to 0.",
                  "returns": [
                    {
                      "description": "The input matrix.",
                      "name": "m",
                      "type": "Mat4"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Sets a model transform matrix that moves to `from` and orients model towards `to` point.\n\nThis is used when rendered model should always point towards a point of interest. The resulting Mat4 object can be used as model pose.\n\nThe target() function produces same result as lookAt() after matrix inversion.",
              "key": "Mat4:target",
              "module": "lovr.math",
              "name": "target",
              "related": ["Mat4:lookAt", "Quat:direction", "Mat4"],
              "summary": "Create a model transform that targets from a position to target position.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The position of the viewer.",
                      "name": "from",
                      "type": "Vec3"
                    },
                    {
                      "description": "The position of the target.",
                      "name": "to",
                      "type": "Vec3"
                    },
                    {
                      "default": "Vec3(0, 1, 0)",
                      "description": "The up vector of the viewer.",
                      "name": "up",
                      "type": "Vec3"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified matrix.",
                      "name": "self",
                      "type": "Mat4"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Translates the matrix.",
              "key": "Mat4:translate",
              "module": "lovr.math",
              "name": "translate",
              "related": ["Mat4:rotate", "Mat4:scale", "Mat4:identity", "Mat4"],
              "summary": "Translate the matrix.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The translation vector.",
                      "name": "v",
                      "type": "Vec3"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The translated matrix.",
                      "name": "self",
                      "type": "Mat4"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The x component of the translation.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the translation.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the translation.",
                      "name": "z",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The translated matrix.",
                      "name": "self",
                      "type": "Mat4"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Transposes the matrix, mirroring its values along the diagonal.",
              "key": "Mat4:transpose",
              "module": "lovr.math",
              "name": "transpose",
              "related": ["Mat4"],
              "summary": "Transpose the matrix.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The transposed matrix.",
                      "name": "self",
                      "type": "Mat4"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the components of matrix, either as 10 separated numbers representing the position, scale, and rotation, or as 16 raw numbers representing the individual components of the matrix in column-major order.",
              "key": "Mat4:unpack",
              "module": "lovr.math",
              "name": "unpack",
              "related": [
                "Mat4:set",
                "Mat4:getPosition",
                "Mat4:getOrientation",
                "Mat4:getScale",
                "Mat4:getPose",
                "Mat4"
              ],
              "summary": "Get the individual components of the matrix.",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "false",
                      "description": "Whether to return the 16 raw components.",
                      "name": "raw",
                      "type": "boolean"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The requested components of the matrix.",
                      "name": "...",
                      "type": "number"
                    }
                  ]
                }
              ]
            }
          ],
          "module": "lovr.math",
          "name": "Mat4",
          "related": ["Vec3", "Quat", "Vectors", "lovr.math"],
          "summary": "A 4x4 matrix."
        },
        {
          "constructors": ["lovr.math.newQuat", "lovr.math.quat"],
          "description": "A `quat` is a math type that represents a 3D rotation, stored as four numbers.",
          "key": "Quat",
          "methods": [
            {
              "description": "Conjugates the input quaternion in place, returning the input.  If the quaternion is normalized, this is the same as inverting it.  It negates the (x, y, z) components of the quaternion.",
              "key": "Quat:conjugate",
              "module": "lovr.math",
              "name": "conjugate",
              "related": ["Quat"],
              "summary": "Conjugate (invert) the quaternion.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The inverted quaternion.",
                      "name": "self",
                      "type": "Quat"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Creates a new temporary vec3 facing the forward direction, rotates it by this quaternion, and returns the vector.",
              "key": "Quat:direction",
              "module": "lovr.math",
              "name": "direction",
              "related": ["Mat4:lookAt", "Quat"],
              "summary": "Get the direction of the quaternion.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The direction vector.",
                      "name": "v",
                      "type": "Vec3"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns whether a quaternion is approximately equal to another quaternion.",
              "key": "Quat:equals",
              "module": "lovr.math",
              "name": "equals",
              "related": [
                "Vec2:equals",
                "Vec3:equals",
                "Vec4:equals",
                "Mat4:equals",
                "Quat"
              ],
              "summary": "Check if a quaternion equals another quaternion.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The other quaternion.",
                      "name": "r",
                      "type": "Quat"
                    }
                  ],
                  "returns": [
                    {
                      "description": "Whether the 2 quaternions approximately equal each other.",
                      "name": "equal",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the euler angles of the quaternion, in YXZ order.",
              "key": "Quat:getEuler",
              "module": "lovr.math",
              "name": "getEuler",
              "related": ["Quat:setEuler", "Quat"],
              "summary": "Get the euler angles of the quaternion.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The pitch (x axis rotation).",
                      "name": "pitch",
                      "type": "number"
                    },
                    {
                      "description": "The yaw (y axis rotation).",
                      "name": "yaw",
                      "type": "number"
                    },
                    {
                      "description": "The roll (z axis rotation).",
                      "name": "roll",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the length of the quaternion.",
              "key": "Quat:length",
              "module": "lovr.math",
              "name": "length",
              "related": ["Quat:normalize", "Quat"],
              "summary": "Get the length of the quaternion.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The length of the quaternion.",
                      "name": "length",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Multiplies this quaternion by another value.  If the value is a quaternion, the rotations in the two quaternions are applied sequentially and the result is stored in the first quaternion.  If the value is a vector, then the input vector is rotated by the quaternion and returned.",
              "key": "Quat:mul",
              "module": "lovr.math",
              "name": "mul",
              "related": ["Quat"],
              "summary": "Multiply a quaternion by another quaternion or a vector.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "A quaternion to combine with the original.",
                      "name": "r",
                      "type": "Quat"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified quaternion.",
                      "name": "self",
                      "type": "Quat"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A vector to rotate.",
                      "name": "v3",
                      "type": "Vec3"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The rotated vector.",
                      "name": "v3",
                      "type": "Vec3"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Adjusts the values in the quaternion so that its length becomes 1.",
              "key": "Quat:normalize",
              "module": "lovr.math",
              "name": "normalize",
              "notes": "A common source of bugs with quaternions is to forget to normalize them after performing a series of operations on them.  Try normalizing a quaternion if some of the calculations aren\u0027t working quite right!",
              "related": ["Quat:length", "Quat"],
              "summary": "Normalize the length of the quaternion to 1.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The normalized quaternion.",
                      "name": "self",
                      "type": "Quat"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Sets the components of the quaternion.  There are lots of different ways to specify the new components, the summary is:\n\n- Four numbers can be used to specify an angle\/axis rotation, similar to other L\u00d6VR functions.\n- Four numbers plus the fifth `raw` flag can be used to set the raw values of the quaternion.\n- An existing quaternion can be passed in to copy its values.\n- A single direction vector can be specified to turn its direction (relative to the default\n  forward direction of \"negative z\") into a rotation.\n- Two direction vectors can be specified to set the quaternion equal to the rotation between the\n  two vectors.\n- A matrix can be passed in to extract the rotation of the matrix into a quaternion.",
              "key": "Quat:set",
              "module": "lovr.math",
              "name": "set",
              "related": ["Quat:unpack", "Quat"],
              "summary": "Set the components of the quaternion.",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "0",
                      "description": "The angle to use for the rotation, in radians.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    },
                    {
                      "default": "false",
                      "description": "Whether the components should be interpreted as raw `(x, y, z, w)` components.",
                      "name": "raw",
                      "type": "boolean"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified quaternion.",
                      "name": "self",
                      "type": "Quat"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "An existing quaternion to copy the values from.",
                      "name": "r",
                      "type": "Quat"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified quaternion.",
                      "name": "self",
                      "type": "Quat"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A normalized direction vector.",
                      "name": "v",
                      "type": "Vec3"
                    }
                  ],
                  "description": "Sets the values from a direction vector.",
                  "returns": [
                    {
                      "description": "The modified quaternion.",
                      "name": "self",
                      "type": "Quat"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A normalized direction vector.",
                      "name": "v",
                      "type": "Vec3"
                    },
                    {
                      "description": "Another normalized direction vector.",
                      "name": "u",
                      "type": "Vec3"
                    }
                  ],
                  "description": "Sets the values to represent the rotation between two vectors.",
                  "returns": [
                    {
                      "description": "The modified quaternion.",
                      "name": "self",
                      "type": "Quat"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A matrix to use the rotation from.",
                      "name": "m",
                      "type": "Mat4"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified quaternion.",
                      "name": "self",
                      "type": "Quat"
                    }
                  ]
                },
                {
                  "arguments": {},
                  "description": "Reset the quaternion to the identity (0, 0, 0, 1).",
                  "returns": [
                    {
                      "description": "The modified quaternion.",
                      "name": "self",
                      "type": "Quat"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Sets the value of the quaternion using euler angles.  The rotation order is YXZ.",
              "key": "Quat:setEuler",
              "module": "lovr.math",
              "name": "setEuler",
              "related": ["Quat:getEuler", "Quat"],
              "summary": "Set the value of the quaternion using euler angles.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The pitch (x axis rotation).",
                      "name": "pitch",
                      "type": "number"
                    },
                    {
                      "description": "The yaw (y axis rotation).",
                      "name": "yaw",
                      "type": "number"
                    },
                    {
                      "description": "The roll (z axis rotation).",
                      "name": "roll",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified quaternion.",
                      "name": "self",
                      "type": "Quat"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Performs a spherical linear interpolation between this quaternion and another one, which can be used for smoothly animating between two rotations.\n\nThe amount of interpolation is controlled by a parameter `t`.  A `t` value of zero leaves the original quaternion unchanged, whereas a `t` of one sets the original quaternion exactly equal to the target.  A value between `0` and `1` returns a rotation between the two based on the value.",
              "key": "Quat:slerp",
              "module": "lovr.math",
              "name": "slerp",
              "related": ["Vec3:lerp", "Quat"],
              "summary": "Moves this quaternion some amount towards another one.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The quaternion to slerp towards.",
                      "name": "r",
                      "type": "Quat"
                    },
                    {
                      "description": "The lerping parameter.",
                      "name": "t",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified quaternion, containing the new lerped values.",
                      "name": "self",
                      "type": "Quat"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the components of the quaternion as numbers, either in an angle\/axis representation or as raw quaternion values.",
              "key": "Quat:unpack",
              "module": "lovr.math",
              "name": "unpack",
              "related": ["Quat:set", "Quat"],
              "summary": "Get the components of the quaternion.",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "false",
                      "description": "Whether the values should be returned as raw values instead of angle\/axis.",
                      "name": "raw",
                      "type": "boolean"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The angle in radians, or the x value.",
                      "name": "a",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the rotation axis or the y value.",
                      "name": "b",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the rotation axis or the z value.",
                      "name": "c",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the rotation axis or the w value.",
                      "name": "d",
                      "type": "number"
                    }
                  ]
                }
              ]
            }
          ],
          "module": "lovr.math",
          "name": "Quat",
          "related": ["Vec3", "Mat4", "Vectors", "lovr.math"],
          "summary": "A quaternion."
        },
        {
          "constructors": ["lovr.math.newRandomGenerator"],
          "description": "A RandomGenerator is a standalone object that can be used to independently generate pseudo-random numbers. If you just need basic randomness, you can use `lovr.math.random` without needing to create a random generator.",
          "key": "RandomGenerator",
          "methods": [
            {
              "description": "Returns the seed used to initialize the RandomGenerator.",
              "key": "RandomGenerator:getSeed",
              "module": "lovr.math",
              "name": "getSeed",
              "notes": "Since the seed is a 64 bit integer, each 32 bits of the seed are returned separately to avoid precision issues.",
              "related": [
                "lovr.math.newRandomGenerator",
                "RandomGenerator:setSeed",
                "RandomGenerator"
              ],
              "summary": "Get the seed value of the RandomGenerator.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The lower 32 bits of the seed.",
                      "name": "low",
                      "type": "number"
                    },
                    {
                      "description": "The upper 32 bits of the seed.",
                      "name": "high",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the current state of the RandomGenerator.  This can be used with `RandomGenerator:setState` to reliably restore a previous state of the generator.",
              "key": "RandomGenerator:getState",
              "module": "lovr.math",
              "name": "getState",
              "notes": "The seed represents the starting state of the RandomGenerator, whereas the state represents the current state of the generator.",
              "related": ["RandomGenerator:setState", "RandomGenerator"],
              "summary": "Get the current state of the RandomGenerator.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The serialized state.",
                      "name": "state",
                      "type": "string"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the next uniformly distributed pseudo-random number from the RandomGenerator\u0027s sequence.",
              "key": "RandomGenerator:random",
              "module": "lovr.math",
              "name": "random",
              "related": [
                "lovr.math.random",
                "RandomGenerator:randomNormal",
                "RandomGenerator"
              ],
              "summary": "Get a random number.",
              "variants": [
                {
                  "arguments": {},
                  "description": "Generate a pseudo-random floating point number in the range `[0,1)`",
                  "returns": [
                    {
                      "description": "A pseudo-random number.",
                      "name": "x",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The maximum number to generate.",
                      "name": "high",
                      "type": "number"
                    }
                  ],
                  "description": "Generate a pseudo-random integer in the range `[1,high]`",
                  "returns": [
                    {
                      "description": "A pseudo-random number.",
                      "name": "x",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The minimum number to generate.",
                      "name": "low",
                      "type": "number"
                    },
                    {
                      "description": "The maximum number to generate.",
                      "name": "high",
                      "type": "number"
                    }
                  ],
                  "description": "Generate a pseudo-random integer in the range `[low,high]`",
                  "returns": [
                    {
                      "description": "A pseudo-random number.",
                      "name": "x",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns a pseudo-random number from a normal distribution (a bell curve).  You can control the center of the bell curve (the mean value) and the overall width (sigma, or standard deviation).",
              "key": "RandomGenerator:randomNormal",
              "module": "lovr.math",
              "name": "randomNormal",
              "related": [
                "lovr.math.randomNormal",
                "RandomGenerator:random",
                "RandomGenerator"
              ],
              "summary": "Get a random number from a normal distribution.",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "1",
                      "description": "The standard deviation of the distribution.  This can be thought of how \"wide\" the range of numbers is or how much variability there is.",
                      "name": "sigma",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The average value returned.",
                      "name": "mu",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "A normally distributed pseudo-random number.",
                      "name": "x",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Seed the RandomGenerator with a new seed.  Each seed will cause the RandomGenerator to produce a unique sequence of random numbers.",
              "key": "RandomGenerator:setSeed",
              "module": "lovr.math",
              "name": "setSeed",
              "notes": "For precise 64 bit seeds, you should specify the lower and upper 32 bits of the seed separately. Otherwise, seeds larger than 2^53 will start to lose precision.",
              "related": ["RandomGenerator:getSeed", "RandomGenerator"],
              "summary": "Reinitialize the RandomGenerator with a new seed.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The random seed.",
                      "name": "seed",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The lower 32 bits of the seed.",
                      "name": "low",
                      "type": "number"
                    },
                    {
                      "description": "The upper 32 bits of the seed.",
                      "name": "high",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the state of the RandomGenerator, as previously obtained using `RandomGenerator:getState`. This can be used to reliably restore a previous state of the generator.",
              "key": "RandomGenerator:setState",
              "module": "lovr.math",
              "name": "setState",
              "notes": "The seed represents the starting state of the RandomGenerator, whereas the state represents the current state of the generator.",
              "related": ["RandomGenerator:getState", "RandomGenerator"],
              "summary": "Set the state of the RandomGenerator.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The serialized state.",
                      "name": "state",
                      "type": "string"
                    }
                  ],
                  "returns": {}
                }
              ]
            }
          ],
          "module": "lovr.math",
          "name": "RandomGenerator",
          "related": ["lovr.math"],
          "summary": "A pseudo-random number generator."
        },
        {
          "constructors": ["lovr.math.newVec2", "lovr.math.vec2"],
          "description": "A vector object that holds two numbers.",
          "key": "Vec2",
          "methods": [
            {
              "description": "Adds a vector or a number to the vector.",
              "key": "Vec2:add",
              "module": "lovr.math",
              "name": "add",
              "related": ["Vec2:sub", "Vec2:mul", "Vec2:div", "Vec2"],
              "summary": "Add a vector or a number to the vector.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The other vector.",
                      "name": "u",
                      "type": "Vec2"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified vector.",
                      "name": "self",
                      "type": "Vec2"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A value to add to x component.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "x",
                      "description": "A value to add to y component.",
                      "name": "y",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified vector.",
                      "name": "self",
                      "type": "Vec2"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the angle between vectors.",
              "key": "Vec2:angle",
              "module": "lovr.math",
              "name": "angle",
              "notes": "If any of the two vectors have a length of zero, the angle between them is not well defined.  In this case the function returns `math.pi \/ 2`.",
              "related": ["Vec2:distance", "Vec2:length", "Vec2"],
              "summary": "Get the angle to another vector.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The other vector.",
                      "name": "u",
                      "type": "Vec2"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The angle to the other vector, in radians.",
                      "name": "angle",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The x component of the other vector.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the other vector.",
                      "name": "y",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The angle to the other vector, in radians.",
                      "name": "angle",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the distance to another vector.",
              "key": "Vec2:distance",
              "module": "lovr.math",
              "name": "distance",
              "related": ["Vec2:angle", "Vec2:length", "Vec2"],
              "summary": "Get the distance to another vector.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The vector to measure the distance to.",
                      "name": "u",
                      "type": "Vec2"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The distance to `u`.",
                      "name": "distance",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A value of x component to measure distance to.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "A value of y component to measure distance to.",
                      "name": "y",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The distance to `u`.",
                      "name": "distance",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Divides the vector by a vector or a number.",
              "key": "Vec2:div",
              "module": "lovr.math",
              "name": "div",
              "related": ["Vec2:add", "Vec2:sub", "Vec2:mul", "Vec2"],
              "summary": "Divides the vector by a vector or a number.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The other vector to divide the components by.",
                      "name": "u",
                      "type": "Vec2"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified vector.",
                      "name": "self",
                      "type": "Vec2"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A value to divide x component by.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "x",
                      "description": "A value to divide y component by.",
                      "name": "y",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified vector.",
                      "name": "self",
                      "type": "Vec2"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the dot product between this vector and another one.",
              "key": "Vec2:dot",
              "module": "lovr.math",
              "name": "dot",
              "notes": "This is computed as:\n\n    dot \u003d v.x * u.x + v.y * u.y\n\nThe vectors are not normalized before computing the dot product.",
              "related": ["Vec2"],
              "summary": "Get the dot product with another vector.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The vector to compute the dot product with.",
                      "name": "u",
                      "type": "Vec2"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The dot product between `v` and `u`.",
                      "name": "dot",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A value of x component to compute the dot product with.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "A value of y component to compute the dot product with.",
                      "name": "y",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The dot product between `v` and `u`.",
                      "name": "dot",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns whether a vector is approximately equal to another vector.",
              "key": "Vec2:equals",
              "module": "lovr.math",
              "name": "equals",
              "notes": "To handle floating point precision issues, this function returns true as long as the squared distance between the vectors is below `1e-10`.",
              "related": [
                "Vec3:equals",
                "Vec4:equals",
                "Quat:equals",
                "Mat4:equals",
                "Vec2"
              ],
              "summary": "Check if a vector equals another vector.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The other vector.",
                      "name": "u",
                      "type": "Vec2"
                    }
                  ],
                  "returns": [
                    {
                      "description": "Whether the 2 vectors approximately equal each other.",
                      "name": "equal",
                      "type": "boolean"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The x component of the other vector.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the other vector.",
                      "name": "y",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "Whether the 2 vectors approximately equal each other.",
                      "name": "equal",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the length of the vector.",
              "key": "Vec2:length",
              "module": "lovr.math",
              "name": "length",
              "notes": "The length is equivalent to this:\n\n    math.sqrt(v.x * v.x + v.y * v.y)",
              "related": ["Vec2:normalize", "Vec2:distance", "Vec2"],
              "summary": "Get the length of the vector.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The length of the vector.",
                      "name": "length",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Performs a linear interpolation between this vector and another one, which can be used to smoothly animate between two vectors, based on a parameter value.  A parameter value of `0` will leave the vector unchanged, a parameter value of `1` will set the vector to be equal to the input vector, and a value of `.5` will set the components to be halfway between the two vectors.",
              "key": "Vec2:lerp",
              "module": "lovr.math",
              "name": "lerp",
              "related": ["Quat:slerp", "Vec2"],
              "summary": "Moves this vector some amount towards another one.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The vector to lerp towards.",
                      "name": "u",
                      "type": "Vec2"
                    },
                    {
                      "description": "The lerping parameter.",
                      "name": "t",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The interpolated vector.",
                      "name": "self",
                      "type": "Vec2"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A value of x component to lerp towards.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "A value of y component to lerp towards.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The lerping parameter.",
                      "name": "t",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The interpolated vector.",
                      "name": "self",
                      "type": "Vec2"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Multiplies the vector by a vector or a number.",
              "key": "Vec2:mul",
              "module": "lovr.math",
              "name": "mul",
              "related": ["Vec2:add", "Vec2:sub", "Vec2:div", "Vec2"],
              "summary": "Multiply the vector by a vector or a number.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The other vector to multiply the components by.",
                      "name": "u",
                      "type": "Vec2"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified vector.",
                      "name": "self",
                      "type": "Vec2"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A value to multiply x component by.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "x",
                      "description": "A value to multiply y component by.",
                      "name": "y",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified vector.",
                      "name": "self",
                      "type": "Vec2"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Adjusts the values in the vector so that its direction stays the same but its length becomes 1.",
              "key": "Vec2:normalize",
              "module": "lovr.math",
              "name": "normalize",
              "related": ["Vec2:length", "Vec2"],
              "summary": "Normalize the length of the vector to 1.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The normalized vector.",
                      "name": "self",
                      "type": "Vec2"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Sets the components of the vector, either from numbers or an existing vector.",
              "key": "Vec2:set",
              "module": "lovr.math",
              "name": "set",
              "related": ["Vec2:unpack", "Vec2"],
              "summary": "Set the components of the vector.",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "0",
                      "description": "The new x value of the vector.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "x",
                      "description": "The new y value of the vector.",
                      "name": "y",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The input vector.",
                      "name": "v",
                      "type": "Vec2"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The vector to copy the values from.",
                      "name": "u",
                      "type": "Vec2"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The input vector.",
                      "name": "v",
                      "type": "Vec2"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Subtracts a vector or a number from the vector.",
              "key": "Vec2:sub",
              "module": "lovr.math",
              "name": "sub",
              "related": ["Vec2:add", "Vec2:mul", "Vec2:div", "Vec2"],
              "summary": "Subtract a vector or a number from the vector.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The other vector.",
                      "name": "u",
                      "type": "Vec2"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified vector.",
                      "name": "self",
                      "type": "Vec2"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A value to subtract from x component.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "x",
                      "description": "A value to subtract from y component.",
                      "name": "y",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified vector.",
                      "name": "self",
                      "type": "Vec2"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the 2 components of the vector as numbers.",
              "key": "Vec2:unpack",
              "module": "lovr.math",
              "name": "unpack",
              "related": ["Vec2:set", "Vec2"],
              "summary": "Get the components of the vector.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The x value.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y value.",
                      "name": "y",
                      "type": "number"
                    }
                  ]
                }
              ]
            }
          ],
          "module": "lovr.math",
          "name": "Vec2",
          "related": ["Vec3", "Vec4", "Vectors", "lovr.math"],
          "summary": "A 2D vector."
        },
        {
          "constructors": ["lovr.math.newVec3", "lovr.math.vec3"],
          "description": "A vector object that holds three numbers.",
          "key": "Vec3",
          "methods": [
            {
              "description": "Adds a vector or a number to the vector.",
              "key": "Vec3:add",
              "module": "lovr.math",
              "name": "add",
              "related": ["Vec3:sub", "Vec3:mul", "Vec3:div", "Vec3"],
              "summary": "Add a vector or a number to the vector.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The other vector.",
                      "name": "u",
                      "type": "Vec3"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified vector.",
                      "name": "self",
                      "type": "Vec3"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A value to add to x component.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "x",
                      "description": "A value to add to y component.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "default": "x",
                      "description": "A value to add to z component.",
                      "name": "z",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified vector.",
                      "name": "self",
                      "type": "Vec3"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the angle between vectors.",
              "key": "Vec3:angle",
              "module": "lovr.math",
              "name": "angle",
              "notes": "If any of the two vectors have a length of zero, the angle between them is not well defined.  In this case the function returns `math.pi \/ 2`.",
              "related": ["Vec3:distance", "Vec3:length", "Vec3"],
              "summary": "Get the angle to another vector.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The other vector.",
                      "name": "u",
                      "type": "Vec3"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The angle to the other vector, in radians.",
                      "name": "angle",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The x component of the other vector.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the other vector.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the other vector.",
                      "name": "z",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The angle to the other vector, in radians.",
                      "name": "angle",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Sets this vector to be equal to the cross product between this vector and another one.  The new `v` will be perpendicular to both the old `v` and `u`.",
              "key": "Vec3:cross",
              "module": "lovr.math",
              "name": "cross",
              "notes": "The vectors are not normalized before or after computing the cross product.",
              "related": ["Vec3:dot", "Vec3"],
              "summary": "Get the cross product with another vector.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The vector to compute the cross product with.",
                      "name": "u",
                      "type": "Vec3"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified vector.",
                      "name": "self",
                      "type": "Vec3"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A value of x component to compute cross product with.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "A value of y component to compute cross product with.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "A value of z component to compute cross product with.",
                      "name": "z",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified vector.",
                      "name": "self",
                      "type": "Vec3"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the distance to another vector.",
              "key": "Vec3:distance",
              "module": "lovr.math",
              "name": "distance",
              "related": ["Vec3:angle", "Vec3:length", "Vec3"],
              "summary": "Get the distance to another vector.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The vector to measure the distance to.",
                      "name": "u",
                      "type": "Vec3"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The distance to `u`.",
                      "name": "distance",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A value of x component to measure distance to.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "A value of y component to measure distance to.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "A value of z component to measure distance to.",
                      "name": "z",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The distance to `u`.",
                      "name": "distance",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Divides the vector by a vector or a number.",
              "key": "Vec3:div",
              "module": "lovr.math",
              "name": "div",
              "related": ["Vec3:add", "Vec3:sub", "Vec3:mul", "Vec3"],
              "summary": "Divides the vector by a vector or a number.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The other vector to divide the components by.",
                      "name": "u",
                      "type": "Vec3"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified vector.",
                      "name": "self",
                      "type": "Vec3"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A value to divide x component by.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "x",
                      "description": "A value to divide y component by.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "default": "x",
                      "description": "A value to divide z component by.",
                      "name": "z",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified vector.",
                      "name": "self",
                      "type": "Vec3"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the dot product between this vector and another one.",
              "key": "Vec3:dot",
              "module": "lovr.math",
              "name": "dot",
              "notes": "This is computed as:\n\n    dot \u003d v.x * u.x + v.y * u.y + v.z * u.z\n\nThe vectors are not normalized before computing the dot product.",
              "related": ["Vec3:cross", "Vec3"],
              "summary": "Get the dot product with another vector.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The vector to compute the dot product with.",
                      "name": "u",
                      "type": "Vec3"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The dot product between `v` and `u`.",
                      "name": "dot",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A value of x component to compute the dot product with.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "A value of y component to compute the dot product with.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "A value of z component to compute the dot product with.",
                      "name": "z",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The dot product between `v` and `u`.",
                      "name": "dot",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns whether a vector is approximately equal to another vector.",
              "key": "Vec3:equals",
              "module": "lovr.math",
              "name": "equals",
              "notes": "To handle floating point precision issues, this function returns true as long as the squared distance between the vectors is below `1e-10`.",
              "related": [
                "Vec2:equals",
                "Vec4:equals",
                "Quat:equals",
                "Mat4:equals",
                "Vec3"
              ],
              "summary": "Check if a vector equals another vector.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The other vector.",
                      "name": "u",
                      "type": "Vec3"
                    }
                  ],
                  "returns": [
                    {
                      "description": "Whether the 2 vectors approximately equal each other.",
                      "name": "equal",
                      "type": "boolean"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The x component of the other vector.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the other vector.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the other vector.",
                      "name": "z",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "Whether the 2 vectors approximately equal each other.",
                      "name": "equal",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the length of the vector.",
              "key": "Vec3:length",
              "module": "lovr.math",
              "name": "length",
              "notes": "The length is equivalent to this:\n\n    math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z)",
              "related": ["Vec3:normalize", "Vec3:distance", "Vec3"],
              "summary": "Get the length of the vector.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The length of the vector.",
                      "name": "length",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Performs a linear interpolation between this vector and another one, which can be used to smoothly animate between two vectors, based on a parameter value.  A parameter value of `0` will leave the vector unchanged, a parameter value of `1` will set the vector to be equal to the input vector, and a value of `.5` will set the components to be halfway between the two vectors.",
              "key": "Vec3:lerp",
              "module": "lovr.math",
              "name": "lerp",
              "related": ["Quat:slerp", "Vec3"],
              "summary": "Moves this vector some amount towards another one.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The vector to lerp towards.",
                      "name": "u",
                      "type": "Vec3"
                    },
                    {
                      "description": "The lerping parameter.",
                      "name": "t",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The interpolated vector.",
                      "name": "self",
                      "type": "Vec3"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A value of x component to lerp towards.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "A value of y component to lerp towards.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "A value of z component to lerp towards.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The lerping parameter.",
                      "name": "t",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The interpolated vector.",
                      "name": "self",
                      "type": "Vec3"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Multiplies the vector by a vector or a number.",
              "key": "Vec3:mul",
              "module": "lovr.math",
              "name": "mul",
              "related": ["Vec3:add", "Vec3:sub", "Vec3:div", "Vec3"],
              "summary": "Multiply the vector by a vector or a number.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The other vector to multiply the components by.",
                      "name": "u",
                      "type": "Vec3"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified vector.",
                      "name": "self",
                      "type": "Vec3"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A value to multiply x component by.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "x",
                      "description": "A value to multiply y component by.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "default": "x",
                      "description": "A value to multiply z component by.",
                      "name": "z",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified vector.",
                      "name": "self",
                      "type": "Vec3"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Adjusts the values in the vector so that its direction stays the same but its length becomes 1.",
              "key": "Vec3:normalize",
              "module": "lovr.math",
              "name": "normalize",
              "related": ["Vec3:length", "Vec3"],
              "summary": "Normalize the length of the vector to 1.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The normalized vector.",
                      "name": "self",
                      "type": "Vec3"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Applies a rotation to the vector, using a `Quat` or an angle\/axis rotation.",
              "key": "Vec3:rotate",
              "module": "lovr.math",
              "name": "rotate",
              "related": ["Quat:mul", "Vec3"],
              "summary": "Apply a rotation to the vector.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The quaternion to apply.",
                      "name": "q",
                      "type": "Quat"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified vector.",
                      "name": "self",
                      "type": "Vec3"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The number of radians to rotate.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis to rotate around.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis to rotate around.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis to rotate around.",
                      "name": "az",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified vector.",
                      "name": "self",
                      "type": "Vec3"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Sets the components of the vector, either from numbers or an existing vector.",
              "key": "Vec3:set",
              "module": "lovr.math",
              "name": "set",
              "related": ["Vec3:unpack", "Vec3"],
              "summary": "Set the components of the vector.",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "0",
                      "description": "The new x value of the vector.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "x",
                      "description": "The new y value of the vector.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "default": "x",
                      "description": "The new z value of the vector.",
                      "name": "z",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The input vector.",
                      "name": "v",
                      "type": "Vec3"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The vector to copy the values from.",
                      "name": "u",
                      "type": "Vec3"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The input vector.",
                      "name": "v",
                      "type": "Vec3"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A quat to use the direction of.",
                      "name": "q",
                      "type": "Quat"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The input vector.",
                      "name": "v",
                      "type": "Vec3"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The matrix to use the position of.",
                      "name": "m",
                      "type": "Mat4"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The input vector.",
                      "name": "v",
                      "type": "Vec3"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Subtracts a vector or a number from the vector.",
              "key": "Vec3:sub",
              "module": "lovr.math",
              "name": "sub",
              "related": ["Vec3:add", "Vec3:mul", "Vec3:div", "Vec3"],
              "summary": "Subtract a vector or a number from the vector.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The other vector.",
                      "name": "u",
                      "type": "Vec3"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified vector.",
                      "name": "self",
                      "type": "Vec3"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A value to subtract from x component.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "x",
                      "description": "A value to subtract from y component.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "default": "x",
                      "description": "A value to subtract from z component.",
                      "name": "z",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified vector.",
                      "name": "self",
                      "type": "Vec3"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Applies a transform (translation, rotation, scale) to the vector using a `Mat4` or numbers. This is the same as multiplying the vector by a matrix.  This treats the vector as a point.",
              "key": "Vec3:transform",
              "module": "lovr.math",
              "name": "transform",
              "related": ["Mat4:mul", "Vec4:transform", "Vec3:rotate", "Vec3"],
              "summary": "Apply a transform to the vector.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The matrix to apply.",
                      "name": "m",
                      "type": "Mat4"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The original vector, with transformed components.",
                      "name": "self",
                      "type": "Vec3"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "default": "0",
                      "description": "The x component of the translation.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The y component of the translation.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z component of the translation.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The scale factor.",
                      "name": "scale",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The number of radians to rotate around the rotation axis.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The original vector, with transformed components.",
                      "name": "self",
                      "type": "Vec3"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The translation to apply.",
                      "name": "translation",
                      "type": "Vec3"
                    },
                    {
                      "default": "1",
                      "description": "The scale factor.",
                      "name": "scale",
                      "type": "number"
                    },
                    {
                      "description": "The rotation to apply.",
                      "name": "rotation",
                      "type": "Quat"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The original vector, with transformed components.",
                      "name": "self",
                      "type": "Vec3"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the 3 components of the vector as numbers.",
              "key": "Vec3:unpack",
              "module": "lovr.math",
              "name": "unpack",
              "related": ["Vec3:set", "Vec3"],
              "summary": "Get the components of the vector.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The x value.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y value.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z value.",
                      "name": "z",
                      "type": "number"
                    }
                  ]
                }
              ]
            }
          ],
          "module": "lovr.math",
          "name": "Vec3",
          "related": ["Vec2", "Vec4", "Vectors", "lovr.math"],
          "summary": "A 3D vector."
        },
        {
          "constructors": ["lovr.math.newVec4", "lovr.math.vec4"],
          "description": "A vector object that holds four numbers.",
          "key": "Vec4",
          "methods": [
            {
              "description": "Adds a vector or a number to the vector.",
              "key": "Vec4:add",
              "module": "lovr.math",
              "name": "add",
              "related": ["Vec4:sub", "Vec4:mul", "Vec4:div", "Vec4"],
              "summary": "Add a vector or a number to the vector.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The other vector.",
                      "name": "u",
                      "type": "Vec4"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified vector.",
                      "name": "self",
                      "type": "Vec4"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A value to add to x component.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "x",
                      "description": "A value to add to y component.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "default": "x",
                      "description": "A value to add to z component.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "default": "x",
                      "description": "A value to add to w component.",
                      "name": "w",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified vector.",
                      "name": "self",
                      "type": "Vec4"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the angle between vectors.",
              "key": "Vec4:angle",
              "module": "lovr.math",
              "name": "angle",
              "notes": "If any of the two vectors have a length of zero, the angle between them is not well defined.  In this case the function returns `math.pi \/ 2`.",
              "related": ["Vec4:distance", "Vec4:length", "Vec4"],
              "summary": "Get the angle to another vector.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The other vector.",
                      "name": "u",
                      "type": "Vec4"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The angle to other vector, in radians.",
                      "name": "angle",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The x component of the other vector.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the other vector.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the other vector.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The w component of the other vector.",
                      "name": "w",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The angle to other vector, in radians.",
                      "name": "angle",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the distance to another vector.",
              "key": "Vec4:distance",
              "module": "lovr.math",
              "name": "distance",
              "related": ["Vec4:angle", "Vec4:length", "Vec4"],
              "summary": "Get the distance to another vector.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The vector to measure the distance to.",
                      "name": "u",
                      "type": "Vec4"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The distance to `u`.",
                      "name": "distance",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A value of x component to measure distance to.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "A value of y component to measure distance to.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "A value of z component to measure distance to.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "A value of w component to measure distance to.",
                      "name": "w",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The distance to `u`.",
                      "name": "distance",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Divides the vector by a vector or a number.",
              "key": "Vec4:div",
              "module": "lovr.math",
              "name": "div",
              "related": ["Vec4:add", "Vec4:sub", "Vec4:mul", "Vec4"],
              "summary": "Divides the vector by a vector or a number.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The other vector to divide the components by.",
                      "name": "u",
                      "type": "Vec4"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified vector.",
                      "name": "self",
                      "type": "Vec4"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A value to divide x component by.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "x",
                      "description": "A value to divide y component by.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "default": "x",
                      "description": "A value to divide z component by.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "default": "x",
                      "description": "A value to divide w component by.",
                      "name": "w",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified vector.",
                      "name": "self",
                      "type": "Vec4"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the dot product between this vector and another one.",
              "key": "Vec4:dot",
              "module": "lovr.math",
              "name": "dot",
              "notes": "This is computed as:\n\n    dot \u003d v.x * u.x + v.y * u.y + v.z * u.z + v.w * u.w\n\nThe vectors are not normalized before computing the dot product.",
              "related": ["Vec4"],
              "summary": "Get the dot product with another vector.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The vector to compute the dot product with.",
                      "name": "u",
                      "type": "Vec4"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The dot product between `v` and `u`.",
                      "name": "dot",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A value of x component to compute the dot product with.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "A value of y component to compute the dot product with.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "A value of z component to compute the dot product with.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "A value of w component to compute the dot product with.",
                      "name": "w",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The dot product between `v` and `u`.",
                      "name": "dot",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns whether a vector is approximately equal to another vector.",
              "key": "Vec4:equals",
              "module": "lovr.math",
              "name": "equals",
              "notes": "To handle floating point precision issues, this function returns true as long as the squared distance between the vectors is below `1e-10`.",
              "related": [
                "Vec2:equals",
                "Vec3:equals",
                "Quat:equals",
                "Mat4:equals",
                "Vec4"
              ],
              "summary": "Check if a vector equals another vector.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The other vector.",
                      "name": "u",
                      "type": "Vec4"
                    }
                  ],
                  "returns": [
                    {
                      "description": "Whether the 2 vectors approximately equal each other.",
                      "name": "equal",
                      "type": "boolean"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The x component of the other vector.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the other vector.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the other vector.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The w component of the other vector.",
                      "name": "w",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "Whether the 2 vectors approximately equal each other.",
                      "name": "equal",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the length of the vector.",
              "key": "Vec4:length",
              "module": "lovr.math",
              "name": "length",
              "notes": "The length is equivalent to this:\n\n    math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z + v.w * v.w)",
              "related": ["Vec4:normalize", "Vec4:distance", "Vec4"],
              "summary": "Get the length of the vector.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The length of the vector.",
                      "name": "length",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Performs a linear interpolation between this vector and another one, which can be used to smoothly animate between two vectors, based on a parameter value.  A parameter value of `0` will leave the vector unchanged, a parameter value of `1` will set the vector to be equal to the input vector, and a value of `.5` will set the components to be halfway between the two vectors.",
              "key": "Vec4:lerp",
              "module": "lovr.math",
              "name": "lerp",
              "related": ["Quat:slerp", "Vec4"],
              "summary": "Moves this vector some amount towards another one.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The vector to lerp towards.",
                      "name": "u",
                      "type": "Vec4"
                    },
                    {
                      "description": "The lerping parameter.",
                      "name": "t",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The interpolated vector.",
                      "name": "self",
                      "type": "Vec4"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A value of x component to lerp towards.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "A value of y component to lerp towards.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "A value of z component to lerp towards.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "A value of w component to lerp towards.",
                      "name": "w",
                      "type": "number"
                    },
                    {
                      "description": "The lerping parameter.",
                      "name": "t",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The interpolated vector.",
                      "name": "self",
                      "type": "Vec4"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Multiplies the vector by a vector or a number.",
              "key": "Vec4:mul",
              "module": "lovr.math",
              "name": "mul",
              "related": ["Vec4:add", "Vec4:sub", "Vec4:div", "Vec4"],
              "summary": "Multiply the vector by a vector or a number.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The other vector to multiply the components by.",
                      "name": "u",
                      "type": "Vec4"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified vector.",
                      "name": "self",
                      "type": "Vec4"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A value to multiply x component by.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "x",
                      "description": "A value to multiply y component by.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "default": "x",
                      "description": "A value to multiply z component by.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "default": "x",
                      "description": "A value to multiply w component by.",
                      "name": "w",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified vector.",
                      "name": "self",
                      "type": "Vec4"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Adjusts the values in the vector so that its direction stays the same but its length becomes 1.",
              "key": "Vec4:normalize",
              "module": "lovr.math",
              "name": "normalize",
              "related": ["Vec4:length", "Vec4"],
              "summary": "Normalize the length of the vector to 1.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The normalized vector.",
                      "name": "self",
                      "type": "Vec4"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Sets the components of the vector, either from numbers or an existing vector.",
              "key": "Vec4:set",
              "module": "lovr.math",
              "name": "set",
              "related": ["Vec4:unpack", "Vec4"],
              "summary": "Set the components of the vector.",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "0",
                      "description": "The new x value of the vector.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "x",
                      "description": "The new y value of the vector.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "default": "x",
                      "description": "The new z value of the vector.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "default": "x",
                      "description": "The new w value of the vector.",
                      "name": "w",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The input vector.",
                      "name": "v",
                      "type": "Vec4"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The vector to copy the values from.",
                      "name": "u",
                      "type": "Vec4"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The input vector.",
                      "name": "v",
                      "type": "Vec4"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Subtracts a vector or a number from the vector.",
              "key": "Vec4:sub",
              "module": "lovr.math",
              "name": "sub",
              "related": ["Vec4:add", "Vec4:mul", "Vec4:div", "Vec4"],
              "summary": "Subtract a vector or a number from the vector.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The other vector.",
                      "name": "u",
                      "type": "Vec4"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified vector.",
                      "name": "self",
                      "type": "Vec4"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A value to subtract from x component.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "x",
                      "description": "A value to subtract from y component.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "default": "x",
                      "description": "A value to subtract from z component.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "default": "x",
                      "description": "A value to subtract from w component.",
                      "name": "w",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The modified vector.",
                      "name": "self",
                      "type": "Vec4"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Applies a transform (translation, rotation, scale) to the vector using a `Mat4` or numbers. This is the same as multiplying the vector by a matrix.",
              "key": "Vec4:transform",
              "module": "lovr.math",
              "name": "transform",
              "related": ["Mat4:mul", "Vec3:transform", "Vec4"],
              "summary": "Apply a transform to the vector.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The matrix to apply.",
                      "name": "m",
                      "type": "Mat4"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The original vector, with transformed components.",
                      "name": "self",
                      "type": "Vec4"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "default": "0",
                      "description": "The x component of the translation.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The y component of the translation.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z component of the translation.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The scale factor.",
                      "name": "scale",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The number of radians to rotate around the rotation axis.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The original vector, with transformed components.",
                      "name": "self",
                      "type": "Vec4"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The translation to apply.",
                      "name": "translation",
                      "type": "Vec3"
                    },
                    {
                      "default": "1",
                      "description": "The scale factor.",
                      "name": "scale",
                      "type": "number"
                    },
                    {
                      "description": "The rotation to apply.",
                      "name": "rotation",
                      "type": "Quat"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The original vector, with transformed components.",
                      "name": "self",
                      "type": "Vec4"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the 4 components of the vector as numbers.",
              "key": "Vec4:unpack",
              "module": "lovr.math",
              "name": "unpack",
              "related": ["Vec4:set", "Vec4"],
              "summary": "Get the components of the vector.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The x value.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y value.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z value.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The w value.",
                      "name": "w",
                      "type": "number"
                    }
                  ]
                }
              ]
            }
          ],
          "module": "lovr.math",
          "name": "Vec4",
          "related": ["Vec2", "Vec3", "Vectors", "lovr.math"],
          "summary": "A 4D vector."
        },
        {
          "constructors": [
            "lovr.math.vec2",
            "lovr.math.vec3",
            "lovr.math.vec4",
            "lovr.math.quat",
            "lovr.math.mat4",
            "lovr.math.newVec2",
            "lovr.math.newVec3",
            "lovr.math.newVec4",
            "lovr.math.newQuat",
            "lovr.math.newMat4"
          ],
          "description": "L\u00d6VR has math objects for vectors, matrices, and quaternions, collectively called \"vector objects\".  Vectors are useful because they can represent a multidimensional quantity (like a 3D position) using just a single value.",
          "key": "Vectors",
          "methods": {},
          "module": "lovr.math",
          "name": "Vectors",
          "notes": "Most L\u00d6VR functions that accept positions, orientations, transforms, velocities, etc. also accept vector objects, so they can be used interchangeably with numbers:\n\n    function lovr.draw(pass)\n      -- position and size are vec3\u0027s, rotation is a quat\n      pass:box(position, size, rotation)\n    end\n\n### Temporary vs. Permanent\n\nVectors can be created in two different ways: **permanent** and **temporary**.\n\n**Permanent** vectors behave like normal Lua values.  They are individual objects that are garbage collected when no longer needed.  They\u0027re created using the usual `lovr.math.new\u003cType\u003e` syntax:\n\n    self.position \u003d lovr.math.newVec3(x, y, z)\n\n**Temporary** vectors are created from a shared pool of vector objects.  This makes them faster because they use temporary memory and do not need to be garbage collected.  To make a temporary vector, leave off the `new` prefix:\n\n    local position \u003d lovr.math.vec3(x, y, z)\n\nAs a shortcut, vector constructors are placed on the global scope.  The uppercase name of the vector is a function that will create a permanent vector, and the lowercase name will create a temporary vector.  This can be disabled using the `t.math.globals` option in `lovr.conf`.\n\n    local position \u003d vec3(x1, y1, z1) + vec3(x2, y2, z2)\n    local transform \u003d Mat4()\n\nTemporary vectors, with all their speed, come with an important restriction: they can only be used during the frame in which they were created.  Saving them into variables and using them later on will throw an error:\n\n    local position \u003d vec3(1, 2, 3)\n\n    function lovr.update(dt)\n      -- Reusing the temporary \u0027position\u0027 vector across frames will error:\n      position:add(vec3(dt))\n    end\n\nIt\u0027s possible to overflow the temporary vector pool.  If that happens, `lovr.math.drain` can be used to periodically drain the pool, invalidating any existing temporary vectors.\n\n### Metamethods\n\nVectors have metamethods, allowing them to be used using the normal math operators like `+`, `-`, `*`, `\/`, etc.\n\n    print(vec3(2, 4, 6) * .5 + vec3(10, 20, 30))\n\nThese metamethods will create new temporary vectors.\n\n### Components and Swizzles\n\nThe raw components of a vector can be accessed like normal fields:\n\n    print(vec3(1, 2, 3).z) --\u003e 3\n    print(mat4()[16]) --\u003e 1\n\nAlso, multiple fields can be accessed and combined into a new (temporary) vector, called swizzling:\n\n    local position \u003d vec3(10, 5, 1)\n    print(position.xy) --\u003e vec2(10, 5)\n    print(position.xyy) --\u003e vec3(10, 5, 5)\n    print(position.zyxz) --\u003e vec4(1, 5, 10, 1)\n\nThe following fields are supported for vectors:\n\n- `x`, `y`, `z`, `w`\n- `r`, `g`, `b`, `a`\n- `s`, `t`, `p`, `q`\n\nQuaternions support `x`, `y`, `z`, and `w`.\n\nMatrices use numbers for accessing individual components in \"column-major\" order.\n\nAll fields can also be assigned to.\n\n    -- Swap the components of a 2D vector\n    v.xy \u003d v.yx\n\nThe `unpack` function can be used (on any vector type) to access all of the individual components of a vector object.  For quaternions you can choose whether you want to unpack the angle\/axis representation or the raw quaternion components.  Similarly, matrices support raw unpacking as well as decomposition into translation\/scale\/rotation values.\n\n### Vector Constants\n\nThe following vector constants are available.  They return new temporary vectors each time they are used:\n\n- `vec2.zero` (0, 0)\n- `vec2.one` (1, 1)\n- `vec3.zero` (0, 0, 0)\n- `vec3.one` (1, 1, 1)\n- `vec3.left` (-1, 0, 0)\n- `vec3.right` (1, 0, 0)\n- `vec3.up` (0, 1, 0)\n- `vec3.down` (0, -1, 0)\n- `vec3.back` (0, 0, 1)\n- `vec3.forward` (0, 0, -1)\n- `vec4.zero` (0, 0, 0, 0)\n- `vec4.one` (1, 1, 1, 1)\n- `quat.identity` (0, 0, 0, 1)",
          "related": ["lovr.math"],
          "summary": "What is your vector victor."
        }
      ],
      "sections": [
        {
          "description": "Functions for generating random numbers and noise.",
          "name": "Randomization",
          "tag": "random"
        },
        {
          "description": "A collection of vector objects.  Check out the `Vectors` guide for an introduction.",
          "name": "Vectors",
          "tag": "vectors"
        },
        {
          "description": "Other miscellaneous math objects\/helpers.",
          "name": "Other",
          "tag": "mathOther"
        }
      ],
      "summary": "Contains useful math helpers.",
      "tag": "modules"
    },
    {
      "description": "The `lovr.physics` module simulates 3D rigid body physics.",
      "enums": [
        {
          "description": "Represents the different types of physics Joints available.",
          "key": "JointType",
          "module": "lovr.physics",
          "name": "JointType",
          "related": [
            "Joint",
            "BallJoint",
            "DistanceJoint",
            "HingeJoint",
            "SliderJoint",
            "lovr.physics"
          ],
          "summary": "Types of physics joints.",
          "values": [
            { "description": "A BallJoint.", "name": "ball" },
            { "description": "A DistanceJoint.", "name": "distance" },
            { "description": "A HingeJoint.", "name": "hinge" },
            { "description": "A SliderJoint.", "name": "slider" }
          ]
        },
        {
          "description": "The different ways the motor on a joint can be used.",
          "key": "MotorMode",
          "module": "lovr.physics",
          "name": "MotorMode",
          "related": [
            "HingeJoint:setMotorMode",
            "SliderJoint:setMotorMode",
            "lovr.physics"
          ],
          "summary": "The different states for joint motors.",
          "values": [
            {
              "description": "The motor drives to a particular value.",
              "name": "position"
            },
            {
              "description": "The motor drives to a particular speed.",
              "name": "velocity"
            }
          ]
        },
        {
          "description": "Represents the different types of physics Shapes available.",
          "key": "ShapeType",
          "module": "lovr.physics",
          "name": "ShapeType",
          "related": [
            "Shape",
            "BoxShape",
            "SphereShape",
            "CapsuleShape",
            "CylinderShape",
            "ConvexShape",
            "MeshShape",
            "TerrainShape",
            "lovr.physics"
          ],
          "summary": "Types of physics shapes.",
          "values": [
            { "description": "A box.", "name": "box" },
            { "description": "A sphere.", "name": "sphere" },
            {
              "description": "A capsule (cylinder with rounded ends).",
              "name": "capsule"
            },
            { "description": "A cylinder.", "name": "cylinder" },
            { "description": "A convex hull.", "name": "convex" },
            {
              "description": "A triangle mesh.  Colliders with this shape can not move.",
              "name": "mesh"
            },
            {
              "description": "A heightfield.  Colliders with this shape can not move.",
              "name": "terrain"
            }
          ]
        }
      ],
      "functions": [
        {
          "description": "Creates a new BallJoint.",
          "key": "lovr.physics.newBallJoint",
          "module": "lovr.physics",
          "name": "newBallJoint",
          "notes": "A ball joint is like a ball and socket between the two colliders.  It tries to keep the distance between the colliders and the anchor position the same, but does not constrain the angle between them.\n\nIf the anchor is nil, the position of the first Collider is the anchor.  If the first collider is nil, then the position of the second Collider is the anchor.",
          "related": [
            "lovr.physics.newConeJoint",
            "lovr.physics.newDistanceJoint",
            "lovr.physics.newHingeJoint",
            "lovr.physics.newSliderJoint",
            "lovr.physics.newWeldJoint",
            "lovr.physics"
          ],
          "summary": "Create a new BallJoint.",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The first collider to attach the Joint to, or `nil` to attach the joint to a fixed position in the World.",
                  "name": "colliderA",
                  "type": "Collider"
                },
                {
                  "description": "The second collider to attach the Joint to.",
                  "name": "colliderB",
                  "type": "Collider"
                },
                {
                  "description": "The x position of the joint anchor point, in world coordinates.",
                  "name": "x",
                  "type": "number"
                },
                {
                  "description": "The y position of the joint anchor point, in world coordinates.",
                  "name": "y",
                  "type": "number"
                },
                {
                  "description": "The z position of the joint anchor point, in world coordinates.",
                  "name": "z",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "The new BallJoint.",
                  "name": "ball",
                  "type": "BallJoint"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The first collider to attach the Joint to, or `nil` to attach the joint to a fixed position in the World.",
                  "name": "colliderA",
                  "type": "Collider"
                },
                {
                  "description": "The second collider to attach the Joint to.",
                  "name": "colliderB",
                  "type": "Collider"
                },
                {
                  "description": "The joint anchor point, in world coordinates.",
                  "name": "anchor",
                  "type": "Vec3"
                }
              ],
              "returns": [
                {
                  "description": "The new BallJoint.",
                  "name": "ball",
                  "type": "BallJoint"
                }
              ]
            }
          ]
        },
        {
          "description": "Creates a new BoxShape.",
          "key": "lovr.physics.newBoxShape",
          "module": "lovr.physics",
          "name": "newBoxShape",
          "notes": "A Shape can be attached to a Collider using `Collider:addShape`.",
          "related": [
            "BoxShape",
            "lovr.physics.newSphereShape",
            "lovr.physics.newCapsuleShape",
            "lovr.physics.newCylinderShape",
            "lovr.physics.newConvexShape",
            "lovr.physics.newMeshShape",
            "lovr.physics.newTerrainShape",
            "lovr.physics"
          ],
          "summary": "Create a new BoxShape.",
          "variants": [
            {
              "arguments": [
                {
                  "default": "1",
                  "description": "The width of the box, in meters.",
                  "name": "width",
                  "type": "number"
                },
                {
                  "default": "width",
                  "description": "The height of the box, in meters.",
                  "name": "height",
                  "type": "number"
                },
                {
                  "default": "width",
                  "description": "The depth of the box, in meters.",
                  "name": "depth",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "The new BoxShape.",
                  "name": "box",
                  "type": "BoxShape"
                }
              ]
            }
          ]
        },
        {
          "description": "Creates a new CapsuleShape.  Capsules are cylinders with hemispheres on each end.",
          "key": "lovr.physics.newCapsuleShape",
          "module": "lovr.physics",
          "name": "newCapsuleShape",
          "notes": "A Shape can be attached to a Collider using `Collider:addShape`.",
          "related": [
            "CapsuleShape",
            "lovr.physics.newBoxShape",
            "lovr.physics.newSphereShape",
            "lovr.physics.newCylinderShape",
            "lovr.physics.newConvexShape",
            "lovr.physics.newMeshShape",
            "lovr.physics.newTerrainShape",
            "lovr.physics"
          ],
          "summary": "Create a new CapsuleShape.",
          "variants": [
            {
              "arguments": [
                {
                  "default": "1",
                  "description": "The radius of the capsule, in meters.",
                  "name": "radius",
                  "type": "number"
                },
                {
                  "default": "1",
                  "description": "The length of the capsule, not including the caps, in meters.",
                  "name": "length",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "The new CapsuleShape.",
                  "name": "capsule",
                  "type": "CapsuleShape"
                }
              ]
            }
          ]
        },
        {
          "description": "Creates a new ConeJoint.",
          "key": "lovr.physics.newConeJoint",
          "module": "lovr.physics",
          "name": "newConeJoint",
          "notes": "A ConeJoint is similar to a BallJoint, where the relative position between the colliders will be constrained to a single point.  However, the ConeJoint also limits the rotation away from the cone axis.  This can be useful for limb joints, ropes, etc.\n\nIf the anchor is nil, the position of the first Collider is the anchor.  If the first Collider is nil, the position of the second collider is the anchor.\n\nIf the axis is nil, it defaults to the direction between the anchor and the second Collider.",
          "related": [
            "lovr.physics.newWeldJoint",
            "lovr.physics.newBallJoint",
            "lovr.physics.newDistanceJoint",
            "lovr.physics.newHingeJoint",
            "lovr.physics.newSliderJoint",
            "lovr.physics"
          ],
          "summary": "Create a new ConeJoint.",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The first collider to attach the Joint to, or `nil` to attach the joint to a fixed position in the World.",
                  "name": "colliderA",
                  "type": "Collider"
                },
                {
                  "description": "The second collider to attach the Joint to.",
                  "name": "colliderB",
                  "type": "Collider"
                },
                {
                  "description": "The x position of the joint anchor point, in world space.",
                  "name": "x",
                  "type": "number"
                },
                {
                  "description": "The y position of the joint anchor point, in world space.",
                  "name": "y",
                  "type": "number"
                },
                {
                  "description": "The z position of the joint anchor point, in world space.",
                  "name": "z",
                  "type": "number"
                },
                {
                  "description": "The x component of the cone axis, in world space.",
                  "name": "ax",
                  "type": "number"
                },
                {
                  "description": "The y component of the cone axis, in world space.",
                  "name": "ay",
                  "type": "number"
                },
                {
                  "description": "The z component of the cone axis, in world space.",
                  "name": "az",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "The new ConeJoint.",
                  "name": "cone",
                  "type": "ConeJoint"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The first collider to attach the Joint to, or `nil` to attach the joint to a fixed position in the World.",
                  "name": "colliderA",
                  "type": "Collider"
                },
                {
                  "description": "The second collider to attach the Joint to.",
                  "name": "colliderB",
                  "type": "Collider"
                },
                {
                  "description": "The joint anchor point, in world space.",
                  "name": "anchor",
                  "type": "Vec3"
                },
                {
                  "description": "The cone axis, in world space.",
                  "name": "axis",
                  "type": "Vec3"
                }
              ],
              "returns": [
                {
                  "description": "The new ConeJoint.",
                  "name": "cone",
                  "type": "ConeJoint"
                }
              ]
            }
          ]
        },
        {
          "description": "Creates a new ConvexShape.",
          "key": "lovr.physics.newConvexShape",
          "module": "lovr.physics",
          "name": "newConvexShape",
          "related": [
            "ConvexShape",
            "lovr.physics.newBoxShape",
            "lovr.physics.newSphereShape",
            "lovr.physics.newCapsuleShape",
            "lovr.physics.newCylinderShape",
            "lovr.physics.newMeshShape",
            "lovr.physics.newTerrainShape",
            "lovr.physics"
          ],
          "summary": "Create a new ConvexShape.",
          "variants": [
            {
              "arguments": [
                {
                  "description": "A list of vertices to compute a convex hull from.  Can be a table of tables (each with 3 numbers) or a table of numbers (every 3 numbers form a 3D point).",
                  "name": "points",
                  "type": "table"
                },
                {
                  "default": "1.0",
                  "description": "A scale to apply to the points.",
                  "name": "scale",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "The new ConvexShape.",
                  "name": "shape",
                  "type": "ConvexShape"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The ModelData to compute a convex hull from.",
                  "name": "modelData",
                  "type": "ModelData"
                },
                {
                  "default": "1.0",
                  "description": "A scale to apply to the points.",
                  "name": "scale",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "The new ConvexShape.",
                  "name": "shape",
                  "type": "ConvexShape"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The Model to compute a convex hull from.",
                  "name": "model",
                  "type": "Model"
                },
                {
                  "default": "1.0",
                  "description": "A scale to apply to the points.",
                  "name": "scale",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "The new ConvexShape.",
                  "name": "shape",
                  "type": "ConvexShape"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The Mesh to compute a convex hull from.  It must use the `cpu` storage mode.",
                  "name": "mesh",
                  "type": "Mesh"
                },
                {
                  "default": "1.0",
                  "description": "A scale to apply to the points.",
                  "name": "scale",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "The new ConvexShape.",
                  "name": "shape",
                  "type": "ConvexShape"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "An existing ConvexShape to clone.",
                  "name": "template",
                  "type": "ConvexShape"
                },
                {
                  "default": "1.0",
                  "description": "A scale to apply to the points.",
                  "name": "scale",
                  "type": "number"
                }
              ],
              "description": "Clones an existing ConvexShape, which is faster than passing the same points multiple times. Clones can have their own scale.  The clone\u0027s scale doesn\u0027t get multiplied with the scale of the template.",
              "returns": [
                {
                  "description": "The new ConvexShape.",
                  "name": "shape",
                  "type": "ConvexShape"
                }
              ]
            }
          ]
        },
        {
          "description": "Creates a new CylinderShape.",
          "key": "lovr.physics.newCylinderShape",
          "module": "lovr.physics",
          "name": "newCylinderShape",
          "notes": "A Shape can be attached to a Collider using `Collider:addShape`.",
          "related": [
            "CylinderShape",
            "lovr.physics.newBoxShape",
            "lovr.physics.newSphereShape",
            "lovr.physics.newCapsuleShape",
            "lovr.physics.newConvexShape",
            "lovr.physics.newMeshShape",
            "lovr.physics.newTerrainShape",
            "lovr.physics"
          ],
          "summary": "Create a new CylinderShape.",
          "variants": [
            {
              "arguments": [
                {
                  "default": "1",
                  "description": "The radius of the cylinder, in meters.",
                  "name": "radius",
                  "type": "number"
                },
                {
                  "default": "1",
                  "description": "The length of the cylinder, in meters.",
                  "name": "length",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "The new CylinderShape.",
                  "name": "cylinder",
                  "type": "CylinderShape"
                }
              ]
            }
          ]
        },
        {
          "description": "Creates a new DistanceJoint.",
          "key": "lovr.physics.newDistanceJoint",
          "module": "lovr.physics",
          "name": "newDistanceJoint",
          "notes": "A distance joint tries to keep the two colliders a fixed distance apart.  The distance is determined by the initial distance between the anchor points.  The joint allows for rotation on the anchor points.\n\nIf no anchors are given, they default to the positions of the Colliders.",
          "related": [
            "lovr.physics.newBallJoint",
            "lovr.physics.newConeJoint",
            "lovr.physics.newHingeJoint",
            "lovr.physics.newSliderJoint",
            "lovr.physics.newWeldJoint",
            "lovr.physics"
          ],
          "summary": "Create a new DistanceJoint.",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The first collider to attach the Joint to, or `nil` to attach the joint to a fixed position in the World.",
                  "name": "colliderA",
                  "type": "Collider"
                },
                {
                  "description": "The second collider to attach the Joint to.",
                  "name": "colliderB",
                  "type": "Collider"
                },
                {
                  "description": "The x position of the first anchor point, in world coordinates.",
                  "name": "x1",
                  "type": "number"
                },
                {
                  "description": "The y position of the first anchor point, in world coordinates.",
                  "name": "y1",
                  "type": "number"
                },
                {
                  "description": "The z position of the first anchor point, in world coordinates.",
                  "name": "z1",
                  "type": "number"
                },
                {
                  "description": "The x position of the second anchor point, in world coordinates.",
                  "name": "x2",
                  "type": "number"
                },
                {
                  "description": "The y position of the second anchor point, in world coordinates.",
                  "name": "y2",
                  "type": "number"
                },
                {
                  "description": "The z position of the second anchor point, in world coordinates.",
                  "name": "z2",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "The new DistanceJoint.",
                  "name": "joint",
                  "type": "DistanceJoint"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The first collider to attach the Joint to, or `nil` to attach the joint to a fixed position in the World.",
                  "name": "colliderA",
                  "type": "Collider"
                },
                {
                  "description": "The second collider to attach the Joint to.",
                  "name": "colliderB",
                  "type": "Collider"
                },
                {
                  "description": "The first anchor point, in world coordinates.",
                  "name": "first",
                  "type": "Vec3"
                },
                {
                  "description": "The second anchor point, in world coordinates.",
                  "name": "second",
                  "type": "Vec3"
                }
              ],
              "returns": [
                {
                  "description": "The new DistanceJoint.",
                  "name": "joint",
                  "type": "DistanceJoint"
                }
              ]
            }
          ]
        },
        {
          "description": "Creates a new HingeJoint.",
          "key": "lovr.physics.newHingeJoint",
          "module": "lovr.physics",
          "name": "newHingeJoint",
          "notes": "A hinge joint constrains two colliders to allow rotation only around the hinge\u0027s axis.\n\nIf the anchor is nil, the position of the first Collider is the anchor.  If the first Collider is nil, the position of the second collider is the anchor.\n\nIf the axis is nil, it defaults to the direction between the anchor and the second Collider.",
          "related": [
            "lovr.physics.newBallJoint",
            "lovr.physics.newConeJoint",
            "lovr.physics.newDistanceJoint",
            "lovr.physics.newSliderJoint",
            "lovr.physics.newWeldJoint",
            "lovr.physics"
          ],
          "summary": "Create a new HingeJoint.",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The first collider to attach the Joint to, or `nil` to attach the joint to a fixed position in the World.",
                  "name": "colliderA",
                  "type": "Collider"
                },
                {
                  "description": "The second collider to attach the Joint to.",
                  "name": "colliderB",
                  "type": "Collider"
                },
                {
                  "description": "The x position of the hinge anchor, in world coordinates.",
                  "name": "x",
                  "type": "number"
                },
                {
                  "description": "The y position of the hinge anchor, in world coordinates.",
                  "name": "y",
                  "type": "number"
                },
                {
                  "description": "The z position of the hinge anchor, in world coordinates.",
                  "name": "z",
                  "type": "number"
                },
                {
                  "description": "The x component of the hinge axis direction.",
                  "name": "ax",
                  "type": "number"
                },
                {
                  "description": "The y component of the hinge axis direction.",
                  "name": "ay",
                  "type": "number"
                },
                {
                  "description": "The z component of the hinge axis direction.",
                  "name": "az",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "The new HingeJoint.",
                  "name": "hinge",
                  "type": "HingeJoint"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The first collider to attach the Joint to, or `nil` to attach the joint to a fixed position in the World.",
                  "name": "colliderA",
                  "type": "Collider"
                },
                {
                  "description": "The second collider to attach the Joint to.",
                  "name": "colliderB",
                  "type": "Collider"
                },
                {
                  "description": "The anchor point, in world coordinates.",
                  "name": "anchor",
                  "type": "Vec3"
                },
                {
                  "description": "The hinge axis direction.",
                  "name": "axis",
                  "type": "Vec3"
                }
              ],
              "returns": [
                {
                  "description": "The new HingeJoint.",
                  "name": "hinge",
                  "type": "HingeJoint"
                }
              ]
            }
          ]
        },
        {
          "description": "Creates a new MeshShape.",
          "key": "lovr.physics.newMeshShape",
          "module": "lovr.physics",
          "name": "newMeshShape",
          "related": [
            "MeshShape",
            "lovr.physics.newBoxShape",
            "lovr.physics.newSphereShape",
            "lovr.physics.newCapsuleShape",
            "lovr.physics.newCylinderShape",
            "lovr.physics.newConvexShape",
            "lovr.physics.newTerrainShape",
            "Model:getTriangles",
            "lovr.physics"
          ],
          "summary": "Create a new MeshShape.",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The table of vertices in the mesh.  Each vertex is a table with 3 numbers.",
                  "name": "vertices",
                  "type": "table"
                },
                {
                  "description": "A table of triangle indices representing how the vertices are connected in the Mesh.",
                  "name": "indices",
                  "type": "table"
                },
                {
                  "default": "1.0",
                  "description": "A scale to apply to the mesh vertices.",
                  "name": "scale",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "The new MeshShape.",
                  "name": "mesh",
                  "type": "MeshShape"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The ModelData to use the vertices from.",
                  "name": "modelData",
                  "type": "ModelData"
                },
                {
                  "default": "1.0",
                  "description": "A scale to apply to the mesh vertices.",
                  "name": "scale",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "The new MeshShape.",
                  "name": "mesh",
                  "type": "MeshShape"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "A Model to use for the mesh data.  Similar to calling `Model:getTriangles` and passing it to this function, but has better performance.",
                  "name": "model",
                  "type": "Model"
                },
                {
                  "default": "1.0",
                  "description": "A scale to apply to the mesh vertices.",
                  "name": "scale",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "The new MeshShape.",
                  "name": "mesh",
                  "type": "MeshShape"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The Mesh to use the vertices from.  It must use the `cpu` storage mode.",
                  "name": "mesh",
                  "type": "Mesh"
                },
                {
                  "default": "1.0",
                  "description": "A scale to apply to the mesh vertices.",
                  "name": "scale",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "The new MeshShape.",
                  "name": "mesh",
                  "type": "MeshShape"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "An existing MeshShape to clone.",
                  "name": "template",
                  "type": "MeshShape"
                },
                {
                  "default": "1.0",
                  "description": "A scale to apply to the mesh vertices.",
                  "name": "scale",
                  "type": "number"
                }
              ],
              "description": "Clones an existing MeshShape, which is faster than passing the same mesh multiple times. Clones can have their own scale.  The clone\u0027s scale doesn\u0027t get multiplied with the scale of the template.",
              "returns": [
                {
                  "description": "The new MeshShape.",
                  "name": "mesh",
                  "type": "MeshShape"
                }
              ]
            }
          ]
        },
        {
          "description": "Creates a new SliderJoint.",
          "key": "lovr.physics.newSliderJoint",
          "module": "lovr.physics",
          "name": "newSliderJoint",
          "notes": "A slider joint constrains two colliders to only allow movement along the slider\u0027s axis.",
          "related": [
            "lovr.physics.newBallJoint",
            "lovr.physics.newConeJoint",
            "lovr.physics.newDistanceJoint",
            "lovr.physics.newHingeJoint",
            "lovr.physics.newWeldJoint",
            "lovr.physics"
          ],
          "summary": "Create a new SliderJoint.",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The first collider to attach the Joint to, or `nil` to attach the joint to a fixed position in the World.",
                  "name": "colliderA",
                  "type": "Collider"
                },
                {
                  "description": "The second collider to attach the Joint to.",
                  "name": "colliderB",
                  "type": "Collider"
                },
                {
                  "description": "The x component of the slider axis.",
                  "name": "ax",
                  "type": "number"
                },
                {
                  "description": "The y component of the slider axis.",
                  "name": "ay",
                  "type": "number"
                },
                {
                  "description": "The z component of the slider axis.",
                  "name": "az",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "The new SliderJoint.",
                  "name": "slider",
                  "type": "SliderJoint"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The first collider to attach the Joint to, or `nil` to attach the joint to a fixed position in the World.",
                  "name": "colliderA",
                  "type": "Collider"
                },
                {
                  "description": "The second collider to attach the Joint to.",
                  "name": "colliderB",
                  "type": "Collider"
                },
                {
                  "description": "The slider axis direction.",
                  "name": "axis",
                  "type": "Vec3"
                }
              ],
              "returns": [
                {
                  "description": "The new SliderJoint.",
                  "name": "slider",
                  "type": "SliderJoint"
                }
              ]
            }
          ]
        },
        {
          "description": "Creates a new SphereShape.",
          "key": "lovr.physics.newSphereShape",
          "module": "lovr.physics",
          "name": "newSphereShape",
          "notes": "A Shape can be attached to a Collider using `Collider:addShape`.",
          "related": [
            "SphereShape",
            "lovr.physics.newBoxShape",
            "lovr.physics.newCapsuleShape",
            "lovr.physics.newCylinderShape",
            "lovr.physics.newConvexShape",
            "lovr.physics.newMeshShape",
            "lovr.physics.newTerrainShape",
            "lovr.physics"
          ],
          "summary": "Create a new SphereShape.",
          "variants": [
            {
              "arguments": [
                {
                  "default": "1",
                  "description": "The radius of the sphere, in meters.",
                  "name": "radius",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "The new SphereShape.",
                  "name": "sphere",
                  "type": "SphereShape"
                }
              ]
            }
          ]
        },
        {
          "description": "Creates a new TerrainShape.",
          "key": "lovr.physics.newTerrainShape",
          "module": "lovr.physics",
          "name": "newTerrainShape",
          "notes": "A Shape can be attached to a Collider using `Collider:addShape`. For immobile terrain use the `Collider:setKinematic`.",
          "related": [
            "TerrainShape",
            "lovr.physics.newBoxShape",
            "lovr.physics.newSphereShape",
            "lovr.physics.newCapsuleShape",
            "lovr.physics.newCylinderShape",
            "lovr.physics.newConvexShape",
            "lovr.physics.newMeshShape",
            "lovr.data.newImage",
            "lovr.physics"
          ],
          "summary": "Create a new TerrainShape.",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The width and depth of the terrain, in meters.",
                  "name": "scale",
                  "type": "number"
                }
              ],
              "description": "Create a flat floor collider.",
              "returns": [
                {
                  "description": "The new TerrainShape.",
                  "name": "terrain",
                  "type": "TerrainShape"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The width and depth of the terrain, in meters.",
                  "name": "scale",
                  "type": "number"
                },
                {
                  "description": "A heightmap image describing the terrain elevation at different points.  The red channel brightness of each pixel determines the elevation at corresponding coordinates.",
                  "name": "heightmap",
                  "type": "Image"
                },
                {
                  "default": "1.0",
                  "description": "A vertical multiplier for height values to obtain terrain height.  When the image format has pixel values only in the 0 to 1 range, this can be used to scale the height to meters.",
                  "name": "stretch",
                  "type": "number"
                }
              ],
              "description": "Create terrain from a heightmap image.",
              "returns": [
                {
                  "description": "The new TerrainShape.",
                  "name": "terrain",
                  "type": "TerrainShape"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The width and depth of the terrain, in meters.",
                  "name": "scale",
                  "type": "number"
                },
                {
                  "arguments": [
                    { "name": "x", "type": "number" },
                    { "name": "z", "type": "number" }
                  ],
                  "description": "A function that computes terrain height from x and z coordinates.  The x and z inputs will range from `-scale \/ 2` to `scale \/ 2`.",
                  "name": "callback",
                  "returns": { "name": "height", "type": "number" },
                  "type": "function"
                },
                {
                  "default": "100",
                  "description": "The number of samples taken across the x and z dimensions.  More samples will result in higher terrain fidelity, but use more CPU and memory.",
                  "name": "samples",
                  "type": "number"
                }
              ],
              "description": "Create terrain defined with a callback function.",
              "returns": [
                {
                  "description": "The new TerrainShape.",
                  "name": "terrain",
                  "type": "TerrainShape"
                }
              ]
            }
          ]
        },
        {
          "description": "Creates a new WeldJoint.",
          "key": "lovr.physics.newWeldJoint",
          "module": "lovr.physics",
          "name": "newWeldJoint",
          "notes": "The joint will try to keep the Colliders in the relative pose they were at when the joint was created.",
          "related": [
            "lovr.physics.newBallJoint",
            "lovr.physics.newConeJoint",
            "lovr.physics.newDistanceJoint",
            "lovr.physics.newHingeJoint",
            "lovr.physics.newSliderJoint",
            "lovr.physics"
          ],
          "summary": "Create a new WeldJoint.",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The first collider to attach the Joint to, or `nil` to attach the joint to a fixed position in the World.",
                  "name": "colliderA",
                  "type": "Collider"
                },
                {
                  "description": "The second collider to attach the Joint to.",
                  "name": "colliderB",
                  "type": "Collider"
                }
              ],
              "returns": [
                {
                  "description": "The new WeldJoint.",
                  "name": "joint",
                  "type": "WeldJoint"
                }
              ]
            }
          ]
        },
        {
          "description": "Creates a new physics World.",
          "key": "lovr.physics.newWorld",
          "module": "lovr.physics",
          "name": "newWorld",
          "related": ["World:update", "lovr.physics"],
          "summary": "Create a new World.",
          "variants": [
            {
              "arguments": [
                {
                  "description": "An optional table with settings for the physics simulation.",
                  "name": "settings",
                  "table": [
                    {
                      "default": "{}",
                      "description": "The list of collision tags (strings).  Colliders can be assigned a tag, and collision can be enabled and disabled between different tags.  There is a maximum of 31 tags.",
                      "name": "tags",
                      "type": "table"
                    },
                    {
                      "default": "{}",
                      "description": "An optional list of collision tags that are \"static\".  Colliders with a static tag will not move, and the physics engine uses this for optimization.",
                      "name": "staticTags",
                      "type": "table"
                    },
                    {
                      "default": "16384",
                      "description": "The maximum number of Colliders in the World.  Increasing this will use more memory. This can\u0027t be bigger than 2^23 (around 8 million).",
                      "name": "maxColliders",
                      "type": "number"
                    },
                    {
                      "default": "true",
                      "description": "Whether the World and the objects it contains can be used from multiple threads.  This will use a set of locks to ensure only one thread can access a Collider at a given time. Disable this to potentially get a small performance boost when only using the World from a single Thread.",
                      "name": "threadSafe",
                      "type": "boolean"
                    },
                    {
                      "default": "true",
                      "description": "Whether colliders should be allowed to go to sleep when they come to rest.  Sleeping colliders don\u0027t need to simulate movement until something hits them.  This improves performance a lot for a typical physics scene where many objects are at rest.",
                      "name": "allowSleep",
                      "type": "boolean"
                    },
                    {
                      "default": "0.2",
                      "description": "How quickly the physics engine corrects position error from collisions and joints, from 0 to 1.  If the value is too low, objects will be spongy, but if it\u0027s too high then physics will explode.  Values between .2 and .8 are recommended.",
                      "name": "stabilization",
                      "type": "number"
                    },
                    {
                      "default": ".01",
                      "description": "The maximum amount that colliders are allowed to overlap, in meters.",
                      "name": "maxPenetration",
                      "type": "number"
                    },
                    {
                      "default": "1.0",
                      "description": "A velocity below which restitution (bounciness) will not be applied, in meters per second.  If this is too low then objects may have trouble coming to rest.",
                      "name": "restitutionThreshold",
                      "type": "number"
                    },
                    {
                      "default": "10",
                      "description": "The number of solver velocity iterations to run per tick.  This must be at least 2. Larger values will increase accuracy but use more CPU.",
                      "name": "velocitySteps",
                      "type": "number"
                    },
                    {
                      "default": "2",
                      "description": "The number of solver position iterations to run per tick.  Larger values will increase accuracy but use more CPU.",
                      "name": "positionSteps",
                      "type": "number"
                    }
                  ],
                  "type": "table"
                }
              ],
              "returns": [
                {
                  "description": "A whole new World.",
                  "name": "world",
                  "type": "World"
                }
              ]
            }
          ]
        }
      ],
      "key": "lovr.physics",
      "name": "physics",
      "objects": [
        {
          "constructors": ["lovr.physics.newBallJoint"],
          "description": "A BallJoint is a type of `Joint` that acts like a ball and socket between two colliders.  It allows the colliders to rotate freely around an anchor point, but does not allow the colliders\u0027 distance from the anchor point to change.",
          "extends": "Joint",
          "key": "BallJoint",
          "methods": {},
          "module": "lovr.physics",
          "name": "BallJoint",
          "related": ["Collider", "Joint", "lovr.physics"],
          "summary": "A ball and socket joint."
        },
        {
          "constructors": ["lovr.physics.newBoxShape", "World:newBoxCollider"],
          "description": "A type of `Shape` that can be used for cubes or boxes.",
          "extends": "Shape",
          "key": "BoxShape",
          "methods": [
            {
              "description": "Returns the width, height, and depth of the BoxShape.",
              "key": "BoxShape:getDimensions",
              "module": "lovr.physics",
              "name": "getDimensions",
              "related": ["BoxShape:setDimensions", "BoxShape"],
              "summary": "Get the dimensions of the BoxShape.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The width of the box, in meters.",
                      "name": "width",
                      "type": "number"
                    },
                    {
                      "description": "The height of the box, in meters.",
                      "name": "height",
                      "type": "number"
                    },
                    {
                      "description": "The depth of the box, in meters.",
                      "name": "depth",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Sets the width, height, and depth of the BoxShape.",
              "key": "BoxShape:setDimensions",
              "module": "lovr.physics",
              "name": "setDimensions",
              "notes": "This changes the mass of the shape.  If the shape is attached to a collider with automatic mass enabled, the mass properties of the collider will update as well.\n\nChanging shapes can make the physics engine explode since it can cause objects to overlap in unnatural ways.",
              "related": ["BoxShape:getDimensions", "BoxShape"],
              "summary": "Set the dimensions of the BoxShape.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The width of the box, in meters.",
                      "name": "width",
                      "type": "number"
                    },
                    {
                      "description": "The height of the box, in meters.",
                      "name": "height",
                      "type": "number"
                    },
                    {
                      "description": "The depth of the box, in meters.",
                      "name": "depth",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            }
          ],
          "module": "lovr.physics",
          "name": "BoxShape",
          "related": ["Shape", "lovr.physics"],
          "summary": "A box Shape."
        },
        {
          "constructors": [
            "lovr.physics.newCapsuleShape",
            "World:newCapsuleCollider"
          ],
          "description": "A type of `Shape` that can be used for capsule-shaped things.",
          "extends": "Shape",
          "key": "CapsuleShape",
          "methods": [
            {
              "description": "Returns the length of the CapsuleShape, not including the caps.",
              "key": "CapsuleShape:getLength",
              "module": "lovr.physics",
              "name": "getLength",
              "related": [
                "CapsuleShape:getRadius",
                "CapsuleShape:setRadius",
                "CapsuleShape:setLength",
                "CapsuleShape"
              ],
              "summary": "Get the length of the CapsuleShape.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The length of the capsule, in meters.",
                      "name": "length",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the radius of the CapsuleShape.",
              "key": "CapsuleShape:getRadius",
              "module": "lovr.physics",
              "name": "getRadius",
              "related": [
                "CapsuleShape:getLength",
                "CapsuleShape:setLength",
                "CapsuleShape:setRadius",
                "CapsuleShape"
              ],
              "summary": "Get the radius of the CapsuleShape.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The radius of the capsule, in meters.",
                      "name": "radius",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Sets the length of the CapsuleShape.",
              "key": "CapsuleShape:setLength",
              "module": "lovr.physics",
              "name": "setLength",
              "notes": "This changes the mass of the shape.  If the shape is attached to a collider with automatic mass enabled, the mass properties of the collider will update as well.\n\nChanging shapes can make the physics engine explode since it can cause objects to overlap in unnatural ways.",
              "related": [
                "CapsuleShape:getRadius",
                "CapsuleShape:setRadius",
                "CapsuleShape:getLength",
                "CapsuleShape"
              ],
              "summary": "Set the length of the CapsuleShape.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The new length, in meters, not including the caps.",
                      "name": "length",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the radius of the CapsuleShape.",
              "key": "CapsuleShape:setRadius",
              "module": "lovr.physics",
              "name": "setRadius",
              "notes": "This changes the mass of the shape.  If the shape is attached to a collider with automatic mass enabled, the mass properties of the collider will update as well.\n\nChanging shapes can make the physics engine explode since it can cause objects to overlap in unnatural ways.",
              "related": [
                "CapsuleShape:getLength",
                "CapsuleShape:setLength",
                "CapsuleShape:getRadius",
                "CapsuleShape"
              ],
              "summary": "Set the radius of the CapsuleShape.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The new radius, in meters.",
                      "name": "radius",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            }
          ],
          "module": "lovr.physics",
          "name": "CapsuleShape",
          "related": ["Shape", "lovr.physics"],
          "summary": "A capsule Shape."
        },
        {
          "constructors": [
            "World:newCollider",
            "World:newBoxCollider",
            "World:newSphereCollider",
            "World:newCapsuleCollider",
            "World:newCylinderCollider",
            "World:newConvexCollider",
            "World:newMeshCollider",
            "World:newTerrainCollider"
          ],
          "description": "Colliders represent a single rigid body in the physics simulation.",
          "key": "Collider",
          "methods": [
            {
              "description": "Attaches a Shape to the collider.",
              "key": "Collider:addShape",
              "module": "lovr.physics",
              "name": "addShape",
              "notes": "By default, L\u00d6VR will recompute mass properties for the Collider as shapes are added and removed.  Use `Collider:setAutomaticMass` to enable or disable this behavior.\n\nShapes can only be attached to a single Collider.  Attempting to attach a shape to multiple colliders (or to a single collider multiple times) will error.  Use `Collider:removeShape` to remove shapes from their original collider before reattaching them.\n\nAdding a `MeshShape` or a `TerrainShape` will force the Collider to be immobile.  It will immediately become kinematic, and will not move via velocity or forces.  However, it can still be repositioned with methods like `Collider:setPosition`.",
              "related": [
                "Collider:removeShape",
                "Collider:getShapes",
                "Collider:getShape",
                "Shape",
                "Collider"
              ],
              "summary": "Add a Shape to the Collider.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The Shape to attach.",
                      "name": "shape",
                      "type": "Shape"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Applies an angular impulse to the Collider.\n\nAn impulse is a single instantaneous push.  Impulses are independent of time, and are meant to only be applied once.  Use `Collider:applyTorque` for a time-dependent push that happens over multiple frames.",
              "key": "Collider:applyAngularImpulse",
              "module": "lovr.physics",
              "name": "applyAngularImpulse",
              "notes": "Kinematic colliders ignore forces.\n\nIf the Collider is asleep, this will wake it up.\n\nImpulses are accumulated and processed during `World:update`.",
              "related": [
                "Collider:applyTorque",
                "Collider:applyForce",
                "Collider:applyLinearImpulse",
                "Collider"
              ],
              "summary": "Apply an angular impulse to the Collider.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The x component of the world-space impulse vector, in newton meter seconds.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the world-space impulse vector, in newton meter seconds.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the world-space impulse vector, in newton meter seconds.",
                      "name": "z",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The world-space impulse vector, in newton meter seconds.",
                      "name": "impulse",
                      "type": "Vec3"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Applies a force to the Collider.",
              "key": "Collider:applyForce",
              "module": "lovr.physics",
              "name": "applyForce",
              "notes": "Kinematic colliders ignore forces.\n\nIf the Collider is asleep, this will wake it up.\n\nForces are accumulated and processed during `World:update`.",
              "related": [
                "Collider:applyLinearImpulse",
                "Collider:applyTorque",
                "Collider:applyAngularImpulse",
                "Collider"
              ],
              "summary": "Apply a force to the Collider.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The x component of the world-space force vector, in newtons.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the world-space force vector, in newtons.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the world-space force vector, in newtons.",
                      "name": "z",
                      "type": "number"
                    }
                  ],
                  "description": "Apply a force at the center of mass.",
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The x component of the world-space force vector, in newtons.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the world-space force vector, in newtons.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the world-space force vector, in newtons.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The x position to apply the force at, in world space.",
                      "name": "px",
                      "type": "number"
                    },
                    {
                      "description": "The y position to apply the force at, in world space.",
                      "name": "py",
                      "type": "number"
                    },
                    {
                      "description": "The z position to apply the force at, in world space.",
                      "name": "pz",
                      "type": "number"
                    }
                  ],
                  "description": "Apply a force at a custom position.",
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The world-space force vector, in newtons.",
                      "name": "force",
                      "type": "Vec3"
                    }
                  ],
                  "description": "Apply a force at the center of mass, using vector types.",
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The world-space force vector, in newtons.",
                      "name": "force",
                      "type": "Vec3"
                    },
                    {
                      "description": "The position to apply the force at, in world space.",
                      "name": "position",
                      "type": "Vec3"
                    }
                  ],
                  "description": "Apply a force at a custom position, using vector types.",
                  "returns": {}
                }
              ]
            },
            {
              "description": "Applies a linear impulse to the Collider.\n\nAn impulse is a single instantaneous push.  Impulses are independent of time, and are meant to only be applied once.  Use `Collider:applyForce` for a time-dependent push that happens over multiple frames.",
              "key": "Collider:applyLinearImpulse",
              "module": "lovr.physics",
              "name": "applyLinearImpulse",
              "notes": "Kinematic colliders ignore forces.\n\nIf the Collider is asleep, this will wake it up.\n\nImpulses are accumulated and processed during `World:update`.",
              "related": [
                "Collider:applyForce",
                "Collider:applyTorque",
                "Collider:applyAngularImpulse",
                "Collider"
              ],
              "summary": "Apply a linear impulse to the Collider.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The x component of the world-space impulse vector, in newton seconds.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the world-space impulse vector, in newton seconds.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the world-space impulse vector, in newton seconds.",
                      "name": "z",
                      "type": "number"
                    }
                  ],
                  "description": "Apply an impulse at the center of mass.",
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The x component of the world-space impulse vector, in newton seconds.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the world-space impulse vector, in newton seconds.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the world-space impulse vector, in newton seconds.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The x position to apply the impulse at, in world space.",
                      "name": "px",
                      "type": "number"
                    },
                    {
                      "description": "The y position to apply the impulse at, in world space.",
                      "name": "py",
                      "type": "number"
                    },
                    {
                      "description": "The z position to apply the impulse at, in world space.",
                      "name": "pz",
                      "type": "number"
                    }
                  ],
                  "description": "Apply an impulse at a custom position.",
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The world-space impulse vector, in newton seconds.",
                      "name": "impulse",
                      "type": "Vec3"
                    }
                  ],
                  "description": "Apply an impulse at the center of mass, using vector types.",
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The world-space impulse vector, in newton seconds.",
                      "name": "impulse",
                      "type": "Vec3"
                    },
                    {
                      "description": "The position to apply the impulse at, in world space.",
                      "name": "position",
                      "type": "Vec3"
                    }
                  ],
                  "description": "Apply an impulse at a custom position, using vector types.",
                  "returns": {}
                }
              ]
            },
            {
              "description": "Applies torque to the Collider.",
              "key": "Collider:applyTorque",
              "module": "lovr.physics",
              "name": "applyTorque",
              "notes": "Kinematic colliders ignore forces.\n\nIf the Collider is asleep, this will wake it up.\n\nForces are accumulated and processed during `World:update`.",
              "related": [
                "Collider:applyAngularImpulse",
                "Collider:applyForce",
                "Collider:applyLinearImpulse",
                "Collider"
              ],
              "summary": "Apply torque to the Collider.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The x component of the world-space torque vector, in newton meters.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the world-space torque vector, in newton meters.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the world-space torque vector, in newton meters.",
                      "name": "z",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The world-space torque vector, in newton meters.",
                      "name": "torque",
                      "type": "Vec3"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Destroys the Collider, removing it from the World and destroying all Shapes and Joints attached to it.",
              "key": "Collider:destroy",
              "module": "lovr.physics",
              "name": "destroy",
              "notes": "After a Collider is destroyed, calling methods on it or passing it to a function will throw an error.",
              "related": [
                "Collider:isDestroyed",
                "Collider:setEnabled",
                "World:destroy",
                "Shape:destroy",
                "Joint:destroy",
                "Collider"
              ],
              "summary": "Destroy the Collider.",
              "variants": [{ "arguments": {}, "returns": {} }]
            },
            {
              "description": "Returns the world-space axis-aligned bounding box of the Collider, computed from attached shapes.",
              "key": "Collider:getAABB",
              "module": "lovr.physics",
              "name": "getAABB",
              "related": ["Shape:getAABB", "World:queryBox", "Collider"],
              "summary": "Get the Collider\u0027s axis aligned bounding box.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The minimum x coordinate of the box.",
                      "name": "minx",
                      "type": "number"
                    },
                    {
                      "description": "The maximum x coordinate of the box.",
                      "name": "maxx",
                      "type": "number"
                    },
                    {
                      "description": "The minimum y coordinate of the box.",
                      "name": "miny",
                      "type": "number"
                    },
                    {
                      "description": "The maximum y coordinate of the box.",
                      "name": "maxy",
                      "type": "number"
                    },
                    {
                      "description": "The minimum z coordinate of the box.",
                      "name": "minz",
                      "type": "number"
                    },
                    {
                      "description": "The maximum z coordinate of the box.",
                      "name": "maxz",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the angular damping of the Collider.  Angular damping is similar to drag or air resistance, reducing the Collider\u0027s angular velocity over time.",
              "key": "Collider:getAngularDamping",
              "module": "lovr.physics",
              "name": "getAngularDamping",
              "notes": "The default damping is .05, meaning the collider will lose approximately 5% of its angular velocity each second.  A damping value of zero means the Collider will not lose velocity over time.",
              "related": [
                "Collider:getLinearDamping",
                "Collider:setLinearDamping",
                "Collider:getInertia",
                "Collider:setInertia",
                "Collider:setAngularDamping",
                "Collider"
              ],
              "summary": "Get the angular damping of the Collider.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The angular damping.",
                      "name": "damping",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the angular velocity of the Collider.",
              "key": "Collider:getAngularVelocity",
              "module": "lovr.physics",
              "name": "getAngularVelocity",
              "related": [
                "Collider:getLinearVelocity",
                "Collider:setLinearVelocity",
                "Collider:applyTorque",
                "Collider:getOrientation",
                "Collider:setOrientation",
                "Collider:setAngularVelocity",
                "Collider"
              ],
              "summary": "Get the angular velocity of the Collider.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The x component of the angular velocity.",
                      "name": "vx",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the angular velocity.",
                      "name": "vy",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the angular velocity.",
                      "name": "vz",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns whether automatic mass is enabled for the Collider.\n\nWhen enabled, the Collider\u0027s mass, inertia, and center of mass will be recomputed when:\n\n- A shape is added to or removed from the Collider.\n- A shape attached to the Collider changes shape (e.g. `SphereShape:setRadius`).\n- A shape attached to the Collider is moved using `Shape:setOffset`.\n- A shape attached to the Collider changes its density using `Shape:setDensity`.\n\nAdditionally, changing the center of mass of a Collider will automatically update its inertia when automatic mass is enabled.\n\nDisable this to manage the mass properties manually.  When automatic mass is disabled, `Collider:resetMassData` can still be used to reset the mass from attached shapes if needed.",
              "key": "Collider:getAutomaticMass",
              "module": "lovr.physics",
              "name": "getAutomaticMass",
              "related": [
                "Collider:resetMassData",
                "Collider:getMass",
                "Collider:setMass",
                "Collider:getInertia",
                "Collider:setInertia",
                "Collider:getCenterOfMass",
                "Collider:setCenterOfMass",
                "Collider:setAutomaticMass",
                "Collider"
              ],
              "summary": "Get whether automatic mass is enabled.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "Whether automatic mass is enabled.",
                      "name": "enabled",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the Collider\u0027s center of mass, in the Collider\u0027s local coordinate space.",
              "key": "Collider:getCenterOfMass",
              "module": "lovr.physics",
              "name": "getCenterOfMass",
              "notes": "By default, the center of mass of the Collider is kept up to date automatically as the Collider\u0027s shapes change.  To disable this, use `Collider:setAutomaticMass`.\n\nUse `Collider:resetMassData` to reset the center of mass and other mass properties based on the Collider\u0027s shapes.",
              "related": [
                "Shape:getCenterOfMass",
                "Collider:getMass",
                "Collider:setMass",
                "Collider:getInertia",
                "Collider:setInertia",
                "Collider:getAutomaticMass",
                "Collider:setAutomaticMass",
                "Collider:resetMassData",
                "Shape:getOffset",
                "Shape:setOffset",
                "Collider:setCenterOfMass",
                "Collider"
              ],
              "summary": "Get the Collider\u0027s local center of mass.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The x component of the center of mass.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the center of mass.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the center of mass.",
                      "name": "z",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Get the degrees of freedom of the Collider.",
              "key": "Collider:getDegreesOfFreedom",
              "module": "lovr.physics",
              "name": "getDegreesOfFreedom",
              "notes": "The default state is `xyz` for both translation and rotation.\n\nThe physics engine does not support disabling all degrees of freedom.  At least one translation or rotation axis needs to be enabled.  To disable all movement for a collider, make it kinematic.",
              "related": ["Collider:setDegreesOfFreedom", "Collider"],
              "summary": "Get the enabled translation\/rotation axes.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "A string containing the world-space axes the Collider is allowed to move on.  The string will have \u0027x\u0027, \u0027y\u0027, and \u0027z\u0027 letters representing which axes are enabled.  If no axes are enabled then it will be an empty string.",
                      "name": "translation",
                      "type": "string"
                    },
                    {
                      "description": "A string containing the world-space axes the Collider is allowed to rotate around.  The string will have \u0027x\u0027, \u0027y\u0027, and \u0027z\u0027 letters representing which axes are enabled.  If no axes are enabled then it will be an empty string.",
                      "name": "rotation",
                      "type": "string"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the friction of the Collider.  Friction determines how easy it is for two colliders to slide against each other.  Low friction makes it easier for a collider to slide, simulating a smooth surface.",
              "key": "Collider:getFriction",
              "module": "lovr.physics",
              "name": "getFriction",
              "notes": "The default friction is .2.\n\nWhen two colliders collide, their friction is combined using the geometric mean:\n\n    friction \u003d (frictionA * frictionB) ^ .5",
              "related": [
                "Contact:getFriction",
                "Contact:setFriction",
                "Collider:getRestitution",
                "Collider:setRestitution",
                "Collider:setFriction",
                "Collider"
              ],
              "summary": "Get the friction of the Collider.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The friction of the Collider.",
                      "name": "friction",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the gravity scale of the Collider.  This is multiplied with the global gravity from the World, so 1.0 is regular gravity, 0.0 will ignore gravity, etc.",
              "key": "Collider:getGravityScale",
              "module": "lovr.physics",
              "name": "getGravityScale",
              "related": [
                "World:getGravity",
                "World:setGravity",
                "Collider:getLinearDamping",
                "Collider:setLinearDamping",
                "Collider:setGravityScale",
                "Collider"
              ],
              "summary": "Get the gravity scale of the Collider.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The gravity scale.",
                      "name": "scale",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the inertia of the Collider.\n\nInertia is kind of like \"angular mass\".  Regular mass determines how resistant the Collider is to linear forces (movement), whereas inertia determines how resistant the Collider is to torque (rotation).  Colliders with less inertia are more spinny.\n\nIn 3D, inertia is represented by a 3x3 matrix, called a tensor.  To make calculations easier, the physics engine stores the inertia using eigenvalue decomposition, splitting the matrix into a diagonal matrix and a rotation.  It\u0027s complicated!\n\nIn a realistic simulation, mass and inertia follow a linear relationship.  If the mass of an object increases, the diagonal part of its inertia should increase proportionally.",
              "key": "Collider:getInertia",
              "module": "lovr.physics",
              "name": "getInertia",
              "notes": "By default, the inertia of the Collider is kept up to date automatically as the Collider\u0027s shapes change.  To disable this, use `Collider:setAutomaticMass`.\n\nUse `Collider:resetMassData` to reset the inertia and other mass properties based on the Collider\u0027s shapes.\n\nIf the Collider is kinematic or all rotation axes are disabled, this returns zeroes.",
              "related": [
                "Collider:getMass",
                "Collider:setMass",
                "Collider:getCenterOfMass",
                "Collider:setCenterOfMass",
                "Collider:getAutomaticMass",
                "Collider:setAutomaticMass",
                "Collider:resetMassData",
                "Shape:getInertia",
                "Collider:setInertia",
                "Collider"
              ],
              "summary": "Get the inertia of the Collider.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The x component of the diagonal matrix.",
                      "name": "dx",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the diagonal matrix.",
                      "name": "dy",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the diagonal matrix.",
                      "name": "dz",
                      "type": "number"
                    },
                    {
                      "description": "The angle of the inertia rotation.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the inertia rotation axis.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the inertia rotation axis.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the inertia rotation axis.",
                      "name": "az",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns a list of Joints attached to the Collider.",
              "key": "Collider:getJoints",
              "module": "lovr.physics",
              "name": "getJoints",
              "related": [
                "World:getJoints",
                "Joint:getColliders",
                "Joint:destroy",
                "Collider"
              ],
              "summary": "Get a list of Joints attached to the Collider.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "A list of `Joint` objects attached to the Collider.",
                      "name": "joints",
                      "type": "table"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the linear damping of the Collider.  Linear damping is similar to drag or air resistance, slowing the Collider down over time.",
              "key": "Collider:getLinearDamping",
              "module": "lovr.physics",
              "name": "getLinearDamping",
              "notes": "The default damping is .05, meaning the collider will lose approximately 5% of its velocity each second.  A damping value of zero means the Collider will not lose velocity over time.",
              "related": [
                "Collider:getAngularDamping",
                "Collider:setAngularDamping",
                "Collider:getGravityScale",
                "Collider:setGravityScale",
                "Collider:setLinearDamping",
                "Collider"
              ],
              "summary": "Get the linear damping of the Collider.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The linear damping.",
                      "name": "damping",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the world-space linear velocity of the center of mass of the Collider, in meters per second.",
              "key": "Collider:getLinearVelocity",
              "module": "lovr.physics",
              "name": "getLinearVelocity",
              "notes": "Currently, velocity is clamped to 500 meters per second to improve stability of the simulation.",
              "related": [
                "Collider:applyForce",
                "Collider:getLinearVelocityFromLocalPoint",
                "Collider:getLinearVelocityFromWorldPoint",
                "Collider:getAngularVelocity",
                "Collider:setAngularVelocity",
                "Collider:getPosition",
                "Collider:setPosition",
                "Collider:setLinearVelocity",
                "Collider"
              ],
              "summary": "Get the linear velocity of the Collider.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The x component of the velocity.",
                      "name": "vx",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the velocity.",
                      "name": "vy",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the velocity.",
                      "name": "vz",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the linear velocity of a point on the Collider.  This includes the velocity of the center of mass plus the angular velocity at that point.",
              "key": "Collider:getLinearVelocityFromLocalPoint",
              "module": "lovr.physics",
              "name": "getLinearVelocityFromLocalPoint",
              "related": [
                "Collider:getLinearVelocity",
                "Collider:getLinearVelocityFromWorldPoint",
                "Collider"
              ],
              "summary": "Get the linear velocity of a point on the Collider.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The x position in local space.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y position in local space.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z position in local space.",
                      "name": "z",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The x velocity of the point.",
                      "name": "vx",
                      "type": "number"
                    },
                    {
                      "description": "The y velocity of the point.",
                      "name": "vy",
                      "type": "number"
                    },
                    {
                      "description": "The z velocity of the point.",
                      "name": "vz",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The local-space point.",
                      "name": "point",
                      "type": "Vec3"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The x velocity of the point.",
                      "name": "vx",
                      "type": "number"
                    },
                    {
                      "description": "The y velocity of the point.",
                      "name": "vy",
                      "type": "number"
                    },
                    {
                      "description": "The z velocity of the point.",
                      "name": "vz",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the linear velocity of a point on the Collider.  This includes the velocity of the center of mass plus the angular velocity at that point.",
              "key": "Collider:getLinearVelocityFromWorldPoint",
              "module": "lovr.physics",
              "name": "getLinearVelocityFromWorldPoint",
              "related": [
                "Collider:getLinearVelocity",
                "Collider:getLinearVelocityFromLocalPoint",
                "Collider"
              ],
              "summary": "Get the linear velocity of the Collider at a world space point.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The x position in world space.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y position in world space.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z position in world space.",
                      "name": "z",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The x velocity of the point.",
                      "name": "vx",
                      "type": "number"
                    },
                    {
                      "description": "The y velocity of the point.",
                      "name": "vy",
                      "type": "number"
                    },
                    {
                      "description": "The z velocity of the point.",
                      "name": "vz",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The world-space point.",
                      "name": "point",
                      "type": "Vec3"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The x velocity of the point.",
                      "name": "vx",
                      "type": "number"
                    },
                    {
                      "description": "The y velocity of the point.",
                      "name": "vy",
                      "type": "number"
                    },
                    {
                      "description": "The z velocity of the point.",
                      "name": "vz",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Transforms a point from world coordinates into local coordinates relative to the Collider.",
              "key": "Collider:getLocalPoint",
              "module": "lovr.physics",
              "name": "getLocalPoint",
              "related": [
                "Collider:getWorldPoint",
                "Collider:getLocalVector",
                "Collider:getWorldVector",
                "Collider"
              ],
              "summary": "Transform a point from world space to collider space.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The x component of the world point.",
                      "name": "wx",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the world point.",
                      "name": "wy",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the world point.",
                      "name": "wz",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The x component of the local point.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the local point.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the local point.",
                      "name": "z",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The world point.",
                      "name": "point",
                      "type": "Vec3"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The x component of the local point.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the local point.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the local point.",
                      "name": "z",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Transforms a direction vector from world space to local space.",
              "key": "Collider:getLocalVector",
              "module": "lovr.physics",
              "name": "getLocalVector",
              "related": [
                "Collider:getWorldVector",
                "Collider:getLocalPoint",
                "Collider:getWorldPoint",
                "Collider"
              ],
              "summary": "Transform a vector from world space to local space.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The x component of the world vector.",
                      "name": "wx",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the world vector.",
                      "name": "wy",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the world vector.",
                      "name": "wz",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The x component of the local vector.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the local vector.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the local vector.",
                      "name": "z",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The world vector.",
                      "name": "vector",
                      "type": "Vec3"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The x component of the local vector.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the local vector.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the local vector.",
                      "name": "z",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the mass of the Collider.\n\nThe relative mass of colliders determines how they react when they collide.  A heavier collider has more momentum than a lighter collider moving the same speed, and will impart more force on the lighter collider.\n\nMore generally, heavier colliders react less to forces they receive, including forces applied with functions like `Collider:applyForce`.\n\nColliders with higher mass do not fall faster.  Use `Collider:setLinearDamping` to give a collider drag to make it fall slower or `Collider:setGravityScale` to change the way it reacts to gravity.",
              "key": "Collider:getMass",
              "module": "lovr.physics",
              "name": "getMass",
              "notes": "By default, the mass of the Collider will be kept up to date automatically as shapes are added and removed from the Collider (or if the shapes change size or density).  Use `Collider:setAutomaticMass` to customize this.\n\nMass can be overridden with `Collider:setMass`, or recomputed from the attached shapes with `Collider:resetMassData`.\n\nIf the Collider is kinematic or all translation axes are disabled, this returns 0.",
              "related": [
                "Collider:getInertia",
                "Collider:setInertia",
                "Collider:getCenterOfMass",
                "Collider:setCenterOfMass",
                "Collider:getAutomaticMass",
                "Collider:setAutomaticMass",
                "Collider:resetMassData",
                "Shape:getDensity",
                "Shape:setDensity",
                "Shape:getVolume",
                "Shape:getMass",
                "Collider:setMass",
                "Collider"
              ],
              "summary": "Get the mass of the Collider.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The mass of the Collider, in kilograms.",
                      "name": "mass",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the orientation of the Collider in angle\/axis representation.",
              "key": "Collider:getOrientation",
              "module": "lovr.physics",
              "name": "getOrientation",
              "notes": "If `World:interpolate` has been called, this returns an interpolated orientation between the last two physics updates.",
              "related": [
                "Collider:applyTorque",
                "Collider:getAngularVelocity",
                "Collider:setAngularVelocity",
                "Collider:getPosition",
                "Collider:setPosition",
                "Collider:getPose",
                "Collider:setPose",
                "Collider:setOrientation",
                "Collider"
              ],
              "summary": "Get the orientation of the Collider.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The number of radians the Collider is rotated around its axis of rotation.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the position and orientation of the Collider.",
              "key": "Collider:getPose",
              "module": "lovr.physics",
              "name": "getPose",
              "notes": "If `World:interpolate` has been called, this returns an interpolated pose between the last two physics updates.",
              "related": [
                "Collider:getPosition",
                "Collider:getOrientation",
                "Collider:setPose",
                "Collider"
              ],
              "summary": "Get the pose of the Collider.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The x position of the Collider, in meters.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y position of the Collider, in meters.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z position of the Collider, in meters.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The number of radians the Collider is rotated around its axis of rotation.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the position of the Collider.",
              "key": "Collider:getPosition",
              "module": "lovr.physics",
              "name": "getPosition",
              "notes": "If `World:interpolate` has been called, this returns an interpolated position between the last two physics updates.",
              "related": [
                "Collider:applyForce",
                "Collider:getLinearVelocity",
                "Collider:setLinearVelocity",
                "Collider:getOrientation",
                "Collider:setOrientation",
                "Collider:getPose",
                "Collider:setPose",
                "Collider:setPosition",
                "Collider"
              ],
              "summary": "Get the position of the Collider.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The x position of the Collider, in meters.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y position of the Collider, in meters.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z position of the Collider, in meters.",
                      "name": "z",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the restitution of the Collider.  Restitution makes a Collider bounce when it collides with other objects.  A restitution value of zero would result in an inelastic collision response, whereas 1.0 would result in an elastic collision that preserves all of the velocity. The restitution can be bigger than 1.0 to make the collision even more bouncy.",
              "key": "Collider:getRestitution",
              "module": "lovr.physics",
              "name": "getRestitution",
              "notes": "To improve stability of the simulation and allow colliders to come to rest, restitution is only applied if the collider is moving above a certain speed.  This can be configured using the `restitutionThreshold` option in `lovr.physics.newWorld`.",
              "related": [
                "Contact:getRestitution",
                "Contact:setRestitution",
                "Collider:getFriction",
                "Collider:setFriction",
                "Collider:setRestitution",
                "Collider"
              ],
              "summary": "Get the bounciness of the Collider.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The restitution of the Collider.",
                      "name": "restitution",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns a Shape attached to the Collider.\n\nFor the common case where a Collider only has a single shape, this is more convenient and efficient than extracting it from the table returned by `Collider:getShapes`.  It is always equivalent to `Collider:getShapes()[1]`.",
              "examples": [
                {
                  "code": "function drawBoxCollider(pass, collider)\n  local position \u003d vec3(collider:getPosition())\n  local size \u003d vec3(collider:getShape():getDimensions())\n  local orientation \u003d quat(collider:getOrientation())\n  pass:box(position, size, orientation)\nend"
                }
              ],
              "key": "Collider:getShape",
              "module": "lovr.physics",
              "name": "getShape",
              "notes": "This may return `nil` if the Collider doesn\u0027t have any shapes attached to it.",
              "related": [
                "Collider:getShapes",
                "Collider:addShape",
                "Collider:removeShape",
                "Shape",
                "Collider"
              ],
              "summary": "Get the first Shape attached to the Collider.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "One of the `Shape` objects attached to the Collider.",
                      "name": "shape",
                      "type": "Shape"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns a list of Shapes attached to the Collider.",
              "key": "Collider:getShapes",
              "module": "lovr.physics",
              "name": "getShapes",
              "related": [
                "Collider:getShape",
                "Collider:addShape",
                "Collider:removeShape",
                "Shape",
                "Collider"
              ],
              "summary": "Get a list of Shapes attached to the Collider.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "A list of `Shape` objects attached to the Collider.",
                      "name": "shapes",
                      "type": "table"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the Collider\u0027s tag.\n\nTags are strings that represent the category of a collider.  Use `World:enableCollisionBetween` and `World:disableCollisionBetween` to control which pairs of tags should collide with each other.  Physics queries like `World:raycast` also use tags to filter their results.\n\nThe list of available tags is set in `lovr.physics.newWorld`.",
              "key": "Collider:getTag",
              "module": "lovr.physics",
              "name": "getTag",
              "related": [
                "World:getTags",
                "World:disableCollisionBetween",
                "World:enableCollisionBetween",
                "World:isCollisionEnabledBetween",
                "lovr.physics.newWorld",
                "Collider:setTag",
                "Collider"
              ],
              "summary": "Get the Collider\u0027s tag.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The Collider\u0027s tag.",
                      "name": "tag",
                      "type": "string"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the Lua value associated with the Collider.",
              "key": "Collider:getUserData",
              "module": "lovr.physics",
              "name": "getUserData",
              "notes": "The userdata is useful for linking a Collider with custom data:\n\n    local collider \u003d world:raycast(origin, direction, \u0027enemy\u0027)\n\n    if collider then\n      -- Get the enemy object from its Collider\n      local enemy \u003d collider:getUserData()\n      enemy.health \u003d 0\n    end\n\nThe user data is not shared between threads.  Each thread has its own user data for the Collider.",
              "related": [
                "Shape:getUserData",
                "Shape:setUserData",
                "Joint:getUserData",
                "Joint:setUserData",
                "Collider:setUserData",
                "Collider"
              ],
              "summary": "Get the Lua value associated with the Collider.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The custom value associated with the Collider.",
                      "name": "data",
                      "type": "*"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the World the Collider is in.",
              "key": "Collider:getWorld",
              "module": "lovr.physics",
              "name": "getWorld",
              "notes": "Colliders can only ever be in the World that created them.",
              "related": ["Collider"],
              "summary": "Get the World the Collider is in.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The World the Collider is in.",
                      "name": "world",
                      "type": "World"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Transforms a local point relative to the collider to a point in world coordinates.",
              "key": "Collider:getWorldPoint",
              "module": "lovr.physics",
              "name": "getWorldPoint",
              "related": [
                "Collider:getLocalPoint",
                "Collider:getLocalVector",
                "Collider:getWorldVector",
                "Collider"
              ],
              "summary": "Transform a point from local space to world space.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The x component of the local point.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the local point.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the local point.",
                      "name": "z",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The x component of the world point.",
                      "name": "wx",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the world point.",
                      "name": "wy",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the world point.",
                      "name": "wz",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The local point.",
                      "name": "point",
                      "type": "Vec3"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The x component of the world point.",
                      "name": "wx",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the world point.",
                      "name": "wy",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the world point.",
                      "name": "wz",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Transforms a direction vector from local space to world space.",
              "key": "Collider:getWorldVector",
              "module": "lovr.physics",
              "name": "getWorldVector",
              "related": [
                "Collider:getLocalVector",
                "Collider:getLocalPoint",
                "Collider:getWorldPoint",
                "Collider"
              ],
              "summary": "Transform a vector from local space to world space.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The x component of the local vector.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the local vector.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the local vector.",
                      "name": "z",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The x component of the world vector.",
                      "name": "wx",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the world vector.",
                      "name": "wy",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the world vector.",
                      "name": "wz",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The local vector.",
                      "name": "vector",
                      "type": "Vec3"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The x component of the world vector.",
                      "name": "wx",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the world vector.",
                      "name": "wy",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the world vector.",
                      "name": "wz",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns whether the Collider is awake.",
              "key": "Collider:isAwake",
              "module": "lovr.physics",
              "name": "isAwake",
              "notes": "See `Collider:setSleepingAllowed` for notes about sleeping.",
              "related": [
                "Collider:isSleepingAllowed",
                "Collider:setSleepingAllowed",
                "Collider:setAwake",
                "Collider"
              ],
              "summary": "Check if the Collider is awake.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "Whether the Collider is finally awake.",
                      "name": "awake",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns whether the Collider uses continuous collision detection.\n\nNormally on each timestep a Collider will \"teleport\" to its new position based on its velocity. Usually this works fine, but if a Collider is going really fast relative to its size, then it might miss collisions with objects or pass through walls.  Enabling continuous collision detection means the Collider will check for obstacles along its path before moving to the new location.  This prevents the Collider from going through walls, but reduces performance.  It\u0027s usually used for projectiles, which tend to be small and really fast.",
              "key": "Collider:isContinuous",
              "module": "lovr.physics",
              "name": "isContinuous",
              "notes": "The physics engine performs an optimization where continuous collision detection is only used if the Collider is moving faster than 75% of its size.  So it is not necessary to enable and disable continuous collision detection based on how fast the Collider is moving.\n\nColliders that are sensors are not able to use continuous collision detection.",
              "related": ["Collider:setContinuous", "Collider"],
              "summary": "Check if the Collider is using continuous collision detection.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "Whether the Collider uses continuous collision detection.",
                      "name": "continuous",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns whether the collider has been destroyed.",
              "key": "Collider:isDestroyed",
              "module": "lovr.physics",
              "name": "isDestroyed",
              "notes": "After a Collider is destroyed, calling methods on it or passing it to a function will throw an error.",
              "related": [
                "Collider:destroy",
                "World:destroy",
                "Shape:destroy",
                "Joint:destroy",
                "Collider"
              ],
              "summary": "Check if the Collider has been destroyed.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "Whether the collider has been destroyed.",
                      "name": "destroyed",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns whether the Collider is enabled.  When a Collider is disabled, it is removed from the World and does not impact the physics simulation in any way.  The Collider keeps all of its state and can be re-enabled to add it back to the World.",
              "key": "Collider:isEnabled",
              "module": "lovr.physics",
              "name": "isEnabled",
              "notes": "Colliders are enabled when they are created.",
              "related": [
                "Collider:destroy",
                "Collider:setEnabled",
                "Collider"
              ],
              "summary": "Check if the Collider is enabled.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "Whether the Collider is enabled.",
                      "name": "enabled",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            },
            {
              "deprecated": "This function has been replaced by `Collider:getGravityScale`.",
              "description": "Returns whether the Collider is currently ignoring gravity.",
              "key": "Collider:isGravityIgnored",
              "module": "lovr.physics",
              "name": "isGravityIgnored",
              "related": ["Collider:setGravityIgnored", "Collider"],
              "summary": "Check if the Collider ignores gravity.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "Whether gravity is ignored for this Collider.",
                      "name": "ignored",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns whether the Collider is kinematic.\n\nKinematic colliders behave like they have infinite mass.  They ignore forces applied to them from gravity, joints, and collisions, but they can still move if given a velocity.  Kinematic colliders don\u0027t collide with other kinematic colliders.  They\u0027re useful for static environment objects in a level, or for objects that have their position managed outside of the physics system like tracked hands.",
              "key": "Collider:isKinematic",
              "module": "lovr.physics",
              "name": "isKinematic",
              "notes": "If a Collider has a `MeshShape` or a `TerrainShape`, it will always be kinematic.",
              "related": ["Collider:setKinematic", "Collider"],
              "summary": "Check if the Collider is kinematic.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "Whether the Collider is kinematic.",
                      "name": "kinematic",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns whether the Collider is a sensor.  Sensors do not collide with other objects, but they can still sense collisions with the collision callbacks set by `World:setCallbacks`.  Use them to trigger gameplay behavior when an object is inside a region of space.",
              "examples": [
                {
                  "code": "danger \u003d world:newBoxCollider(x, y, z, width, height, depth)\ndanger:setKinematic(true)\ndanger:setSensor(true)\n\nworld:setCallbacks({\n  enter \u003d function(a, b)\n    if (a \u003d\u003d danger and b \u003d\u003d player) or (a \u003d\u003d player and b \u003d\u003d danger) then\n      damagePlayer()\n    end\n  end\n})"
                }
              ],
              "key": "Collider:isSensor",
              "module": "lovr.physics",
              "name": "isSensor",
              "notes": "Sensors are still reported as hits when doing raycasts and other queries.  Use tags to ignore sensors if needed.\n\nWhen a World is created, a set of collision tags can be marked as \"static\", for performance. Sensors do not detect collision with colliders that have a static tag.  Also, if a sensor itself has a static tag, it will not be able to detect collisions with sleeping colliders.  If a Collider enters a static sensor and goes to sleep, the `exit` callback is called and the sensor is no longer able to detect that collider.\n\nSensors can not use continuous collision detection.\n\nSensors will never go to sleep.",
              "related": [
                "Collider:setKinematic",
                "Collider:setEnabled",
                "World:overlapShape",
                "World:setCallbacks",
                "Collider:setSensor",
                "Collider"
              ],
              "summary": "Check if the Collider is a sensor.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "Whether the Collider is a sensor.",
                      "name": "sensor",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns whether the Collider is allowed to automatically go to sleep.\n\nWhen enabled, the Collider will go to sleep if it hasn\u0027t moved in a while.  The physics engine does not simulate movement for colliders that are asleep, which saves a lot of CPU for a typical physics world where most objects are at rest at any given time.",
              "key": "Collider:isSleepingAllowed",
              "module": "lovr.physics",
              "name": "isSleepingAllowed",
              "notes": "Sleeping is enabled by default.  Sleeping can be disabled globally using the `allowSleep` option in `lovr.physics.newWorld`.\n\nColliders can still be put to sleep manually with `Collider:setAwake`, even if automatic sleeping is disabled.\n\nSleeping colliders will wake up when:\n\n- Colliding with a moving collider\n- Awakened explicitly with `Collider:setAwake`\n- Changing position `Collider:setPosition` or `Collider:setOrientation`\n- Changing velocity (to something non-zero)\n- Applying force, torque, or an impulse\n- Enabling a joint connected to the sleeping collider\n\nNotably, the following will not wake up the collider:\n\n- Changing its kinematic state with `Collider:setKinematic`\n- Changing its shape with `Collider:addShape` or `Collider:removeShape`\n- Disabling or destroying a sleeping collider it is resting on\n\nSensors will never go to sleep.",
              "related": [
                "Collider:isAwake",
                "Collider:setAwake",
                "Collider:setSleepingAllowed",
                "Collider"
              ],
              "summary": "Check if the Collider is allowed to sleep.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "Whether the Collider can go to sleep.",
                      "name": "sleepy",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Moves the collider towards a destination pose.  The velocity of the collider is set so that the collider reaches the destination in `dt` seconds.",
              "key": "Collider:moveKinematic",
              "module": "lovr.physics",
              "name": "moveKinematic",
              "notes": "The collider doesn\u0027t stop when it reaches the destination, this is just a shorthand for setting its velocity.",
              "related": [
                "Collider:setLinearVelocity",
                "Collider:setAngularVelocity",
                "Collider:applyForce",
                "Collider:applyTorque",
                "Collider"
              ],
              "summary": "Move the collider towards a destination.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The x position of the target, in meters.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y position of the target, in meters.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z position of the target, in meters.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The angle of the target orientation.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the target axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the target axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the target axis of rotation.",
                      "name": "az",
                      "type": "number"
                    },
                    {
                      "description": "How long it should take to reach the destination.",
                      "name": "dt",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The position of the target, in meters.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "description": "The target orientation.",
                      "name": "orientation",
                      "type": "Quat"
                    },
                    {
                      "description": "How long it should take to reach the destination.",
                      "name": "dt",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Removes a Shape from the Collider.",
              "key": "Collider:removeShape",
              "module": "lovr.physics",
              "name": "removeShape",
              "notes": "By default, L\u00d6VR will recompute mass properties for the Collider as shapes are added and removed.  Use `Collider:setAutomaticMass` to enable or disable this behavior.\n\nIt is valid for a Collider to have zero shapes, but due to a limitation of the physics engine L\u00d6VR substitutes in a 1mm sphere so that the Collider still has mass.  It isn\u0027t advisable to keep these tiny spheres around.  Instead, prefer to quickly attach other shapes, or disable the Collider with `Collider:setEnabled`.",
              "related": [
                "Collider:addShape",
                "Collider:getShapes",
                "Shape",
                "Collider"
              ],
              "summary": "Remove a Shape from the Collider.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The Shape to remove.",
                      "name": "shape",
                      "type": "Shape"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Resets the mass, inertia, and center of mass of the Collider based on its attached shapes.\n\nIf automatic mass is enabled, these properties will be kept up to date automatically.  Use this function when automatic mass is disabled or if mass needs to be reset after being overridden.",
              "key": "Collider:resetMassData",
              "module": "lovr.physics",
              "name": "resetMassData",
              "related": [
                "Collider:getAutomaticMass",
                "Collider:setAutomaticMass",
                "Collider:getMass",
                "Collider:setMass",
                "Collider:getInertia",
                "Collider:setInertia",
                "Collider:getCenterOfMass",
                "Collider:setCenterOfMass",
                "Collider"
              ],
              "summary": "Reset mass properties.",
              "variants": [{ "arguments": {}, "returns": {} }]
            },
            {
              "description": "Sets the angular damping of the Collider.  Angular damping is similar to drag or air resistance, reducing the Collider\u0027s angular velocity over time.",
              "key": "Collider:setAngularDamping",
              "module": "lovr.physics",
              "name": "setAngularDamping",
              "notes": "The default damping is .05, meaning the collider will lose approximately 5% of its velocity each second.  A damping value of zero means the Collider will not lose velocity over time.\n\nNegative damping is not meaningful and will be clamped to zero.",
              "related": [
                "Collider:getLinearDamping",
                "Collider:setLinearDamping",
                "Collider:getInertia",
                "Collider:setInertia",
                "Collider:getAngularDamping",
                "Collider"
              ],
              "summary": "Set the angular damping of the Collider.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The angular damping.",
                      "name": "damping",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the angular velocity of the Collider.",
              "key": "Collider:setAngularVelocity",
              "module": "lovr.physics",
              "name": "setAngularVelocity",
              "notes": "Although setting the velocity directly is useful sometimes, it can cause problems:\n\n- Velocity ignores mass, so it can lead to unnaturally sharp changes in motion.\n- If the velocity of a Collider is changed multiple times during a frame, only the last one is\n  going to have an effect, nullifying the other velocities that were set.\n- Setting the velocity of a Collider every frame can mess up collisions, since the forces used\n  to resolve a collision will get ignored by changing the velocity.\n\nUsing forces and impulses to move Colliders will avoid all of these issues.\n\nIf the Collider is asleep, setting the angular velocity to a non-zero value will wake it up.\n\nIf the Collider has a tag that was marked as static when the World was created, then the Collider can not move and this function will do nothing.",
              "related": [
                "Collider:applyTorque",
                "Collider:applyAngularImpulse",
                "Collider:getLinearVelocity",
                "Collider:setLinearVelocity",
                "Collider:getOrientation",
                "Collider:setOrientation",
                "Collider:getAngularVelocity",
                "Collider"
              ],
              "summary": "Set the angular velocity of the Collider.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The x component of the angular velocity.",
                      "name": "vx",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the angular velocity.",
                      "name": "vy",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the angular velocity.",
                      "name": "vz",
                      "type": "number"
                    }
                  ],
                  "description": "Sets the angular velocity of the Collider using numbers.",
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The angular velocity of the Collider.",
                      "name": "velocity",
                      "type": "Vec3"
                    }
                  ],
                  "description": "Sets the angular velocity of the Collider using a vector.",
                  "returns": {}
                }
              ]
            },
            {
              "description": "Enables or disables automatic mass for the Collider.\n\nWhen enabled, the Collider\u0027s mass, inertia, and center of mass will be recomputed when:\n\n- A shape is added to or removed from the Collider.\n- A shape attached to the Collider changes shape (e.g. `SphereShape:setRadius`).\n- A shape attached to the Collider is moved using `Shape:setOffset`.\n- A shape attached to the Collider changes its density using `Shape:setDensity`.\n\nAdditionally, changing the center of mass of a Collider will automatically update its inertia when automatic mass is enabled.\n\nDisable this to manage the mass properties manually.  When automatic mass is disabled, `Collider:resetMassData` can still be used to reset the mass from attached shapes if needed.",
              "key": "Collider:setAutomaticMass",
              "module": "lovr.physics",
              "name": "setAutomaticMass",
              "related": [
                "Collider:resetMassData",
                "Collider:getMass",
                "Collider:setMass",
                "Collider:getInertia",
                "Collider:setInertia",
                "Collider:getCenterOfMass",
                "Collider:setCenterOfMass",
                "Collider:getAutomaticMass",
                "Collider"
              ],
              "summary": "Enable or disable automatic mass.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "Whether automatic mass should be enabled.",
                      "name": "enable",
                      "type": "boolean"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Puts the Collider to sleep or wakes it up manually.",
              "key": "Collider:setAwake",
              "module": "lovr.physics",
              "name": "setAwake",
              "notes": "This function can still be used to put a Collider to sleep even if automatic sleeping has been disabled with `Collider:setSleepingAllowed`.",
              "related": [
                "Collider:isSleepingAllowed",
                "Collider:setSleepingAllowed",
                "Collider:isAwake",
                "Collider"
              ],
              "summary": "Put the Collider to sleep or wake it up.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "Whether the Collider should be awake.",
                      "name": "awake",
                      "type": "boolean"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the Collider\u0027s center of mass, in the Collider\u0027s local coordinate space.\n\nThis does not change the Collider\u0027s position.",
              "key": "Collider:setCenterOfMass",
              "module": "lovr.physics",
              "name": "setCenterOfMass",
              "notes": "By default, the center of mass of the Collider is kept up to date automatically as the Collider\u0027s shapes change.  To disable this, use `Collider:setAutomaticMass`.\n\nUse `Collider:resetMassData` to reset the center and other mass properties based on the Collider\u0027s shapes.",
              "related": [
                "Shape:getCenterOfMass",
                "Collider:getMass",
                "Collider:setMass",
                "Collider:getInertia",
                "Collider:setInertia",
                "Collider:getAutomaticMass",
                "Collider:setAutomaticMass",
                "Collider:resetMassData",
                "Shape:getOffset",
                "Shape:setOffset",
                "Collider:getCenterOfMass",
                "Collider"
              ],
              "summary": "Set the Collider\u0027s center of mass.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The x component of the center of mass.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the center of mass.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the center of mass.",
                      "name": "z",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The center of mass.",
                      "name": "center",
                      "type": "Vec3"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets whether the Collider uses continuous collision detection.\n\nNormally on each timestep a Collider will \"teleport\" to its new position based on its velocity. Usually this works fine, but if a Collider is going really fast relative to its size, then it might miss collisions with objects or pass through walls.  Enabling continuous collision detection means the Collider will check for obstacles along its path before moving to the new location.  This prevents the Collider from going through walls, but reduces performance.  It\u0027s usually used for projectiles, which tend to be small and really fast.",
              "key": "Collider:setContinuous",
              "module": "lovr.physics",
              "name": "setContinuous",
              "notes": "The physics engine performs an optimization where continuous collision detection is only used if the Collider is moving faster than 75% of its size.  So it is not necessary to enable and disable continuous collision detection based on how fast the Collider is moving.\n\nColliders that are sensors are not able to use continuous collision detection.",
              "related": ["Collider:isContinuous", "Collider"],
              "summary": "Set whether the Collider uses continuous collision detection.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "Whether the Collider uses continuous collision detection.",
                      "name": "continuous",
                      "type": "boolean"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Set the degrees of freedom of the Collider.",
              "key": "Collider:setDegreesOfFreedom",
              "module": "lovr.physics",
              "name": "setDegreesOfFreedom",
              "notes": "The default state is `xyz` for both translation and rotation.\n\nThe physics engine does not support disabling all degrees of freedom.  At least one translation or rotation axis needs to be enabled.  To disable all movement for a collider, make it kinematic.\n\nWhen all translation axes are disabled, `Collider:getMass` will return 0.\n\nWhen all rotation axes are disabled, `Collider:getInertia` will return zero\/identity.",
              "related": ["Collider:getDegreesOfFreedom", "Collider"],
              "summary": "Set the enabled translation\/rotation axes.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "A string containing the world-space axes the Collider is allowed to move on.  The string should have \u0027x\u0027, \u0027y\u0027, and \u0027z\u0027 letters representing the axes to enable.  Use nil or an empty string to disable all translation.",
                      "name": "translation",
                      "type": "string"
                    },
                    {
                      "description": "A string containing the world-space axes the Collider is allowed to rotate on.  The string should have \u0027x\u0027, \u0027y\u0027, and \u0027z\u0027 letters representing the axes to enable.  Use nil or an empty string to disable all rotation.",
                      "name": "rotation",
                      "type": "string"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Enables or disables the Collider.  When a Collider is disabled, it is removed from the World and does not impact the physics simulation in any way.  The Collider keeps all of its state and can be re-enabled to add it back to the World.",
              "key": "Collider:setEnabled",
              "module": "lovr.physics",
              "name": "setEnabled",
              "related": ["Collider:destroy", "Collider:isEnabled", "Collider"],
              "summary": "Enable or disable the Collider.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "Whether the Collider should be enabled.",
                      "name": "enable",
                      "type": "boolean"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the friction of the Collider.  Friction determines how easy it is for two colliders to slide against each other.  Low friction makes it easier for a collider to slide, simulating a smooth surface.",
              "key": "Collider:setFriction",
              "module": "lovr.physics",
              "name": "setFriction",
              "notes": "The default friction is .2.\n\nWhen two colliders collide, their friction is combined using the geometric mean:\n\n    friction \u003d (frictionA * frictionB) ^ .5",
              "related": [
                "Contact:getFriction",
                "Contact:setFriction",
                "Collider:getRestitution",
                "Collider:setRestitution",
                "Collider:getFriction",
                "Collider"
              ],
              "summary": "Set the friction of the Collider.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The friction of the Collider.",
                      "name": "friction",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "deprecated": "This function has been replaced by `Collider:setGravityScale`.",
              "description": "Sets whether the Collider should ignore gravity.",
              "key": "Collider:setGravityIgnored",
              "module": "lovr.physics",
              "name": "setGravityIgnored",
              "related": ["Collider:isGravityIgnored", "Collider"],
              "summary": "Set whether the Collider ignores gravity.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "Whether gravity should be ignored.",
                      "name": "ignored",
                      "type": "boolean"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the gravity scale of the Collider.  This is multiplied with the global gravity from the World, so 1.0 is regular gravity, 0.0 will ignore gravity, etc.",
              "key": "Collider:setGravityScale",
              "module": "lovr.physics",
              "name": "setGravityScale",
              "related": [
                "World:getGravity",
                "World:setGravity",
                "Collider:getLinearDamping",
                "Collider:setLinearDamping",
                "Collider:getGravityScale",
                "Collider"
              ],
              "summary": "Set the gravity scale of the Collider.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The gravity scale.",
                      "name": "scale",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the inertia of the Collider.\n\nInertia is kind of like \"angular mass\".  Regular mass determines how resistant the Collider is to linear forces (movement), whereas inertia determines how resistant the Collider is to torque (rotation).  Colliders with less inertia are more spinny.\n\nIn 3D, inertia is represented by a 3x3 matrix, called a tensor.  To make calculations easier, the physics engine stores the inertia using eigenvalue decomposition, splitting the matrix into a diagonal matrix and a rotation.  It\u0027s complicated!\n\nIn a realistic simulation, mass and inertia follow a linear relationship.  If the mass of an object increases, the diagonal part of its inertia should increase proportionally.",
              "key": "Collider:setInertia",
              "module": "lovr.physics",
              "name": "setInertia",
              "notes": "By default, the inertia of the Collider is kept up to date automatically as the Collider\u0027s shapes change.  To disable this, use `Collider:setAutomaticMass`.\n\nUse `Collider:resetMassData` to reset the inertia and other mass properties based on the Collider\u0027s shapes.\n\nIf the Collider is kinematic or all rotation axes are disabled, the collider behaves as though it has infinite inertia, and this function will do nothing.",
              "related": [
                "Collider:getMass",
                "Collider:setMass",
                "Collider:getCenterOfMass",
                "Collider:setCenterOfMass",
                "Collider:getAutomaticMass",
                "Collider:setAutomaticMass",
                "Collider:resetMassData",
                "Shape:getInertia",
                "Collider:getInertia",
                "Collider"
              ],
              "summary": "Set the inertia of the Collider.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The x component of the diagonal matrix.",
                      "name": "dx",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the diagonal matrix.",
                      "name": "dy",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the diagonal matrix.",
                      "name": "dz",
                      "type": "number"
                    },
                    {
                      "description": "The angle of the inertia rotation, in radians.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the rotation axis.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the rotation axis.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the rotation axis.",
                      "name": "az",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "A vector containing the 3 elements of a diagonal matrix.",
                      "name": "diagonal",
                      "type": "Vec3"
                    },
                    {
                      "description": "The inertia rotation.",
                      "name": "rotation",
                      "type": "Quat"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets whether the Collider is kinematic.\n\nKinematic colliders behave like they have infinite mass.  They ignore forces applied to them from gravity, joints, and collisions, but they can still move if given a velocity.  Kinematic colliders don\u0027t collide with other kinematic colliders.  They\u0027re useful for static environment objects in a level, or for objects that have their position managed outside of the physics system like tracked hands.",
              "key": "Collider:setKinematic",
              "module": "lovr.physics",
              "name": "setKinematic",
              "notes": "If a Collider has a `MeshShape` or a `TerrainShape`, the collider will always be kinematic and this function will do nothing.",
              "related": ["Collider:isKinematic", "Collider"],
              "summary": "Set whether the Collider is kinematic.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "Whether the Collider should be kinematic.",
                      "name": "kinematic",
                      "type": "boolean"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the linear damping of the Collider.  Linear damping is similar to drag or air resistance, slowing the Collider down over time.",
              "key": "Collider:setLinearDamping",
              "module": "lovr.physics",
              "name": "setLinearDamping",
              "notes": "The default damping is .05, meaning the collider will lose approximately 5% of its velocity each second.  A damping value of zero means the Collider will not lose velocity over time.\n\nNegative damping is not meaningful and will be clamped to zero.",
              "related": [
                "Collider:getAngularDamping",
                "Collider:setAngularDamping",
                "Collider:getGravityScale",
                "Collider:setGravityScale",
                "Collider:getLinearDamping",
                "Collider"
              ],
              "summary": "Set the linear damping of the Collider.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The linear damping.",
                      "name": "damping",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the world-space linear velocity of the center of mass of the Collider.",
              "key": "Collider:setLinearVelocity",
              "module": "lovr.physics",
              "name": "setLinearVelocity",
              "notes": "Although setting the velocity directly is useful sometimes, it can cause problems:\n\n- Velocity ignores mass, so it can lead to unnaturally sharp changes in motion.\n- If the velocity of a Collider is changed multiple times during a frame, only the last one is\n  going to have an effect, nullifying the other velocities that were set.\n- Setting the velocity of a Collider every frame can mess up collisions, since the forces used\n  to resolve a collision will get ignored by changing the velocity.\n\nUsing forces and impulses to move Colliders will avoid all of these issues.\n\nIf the Collider is asleep, setting the velocity to a non-zero value will wake it up.\n\nIf the Collider has a tag that was marked as static when the World was created, then the Collider can not move and this function will do nothing.\n\nCurrently, velocity is clamped to 500 meters per second to improve stability of the simulation.",
              "related": [
                "Collider:applyForce",
                "Collider:applyLinearImpulse",
                "Collider:getLinearVelocityFromLocalPoint",
                "Collider:getLinearVelocityFromWorldPoint",
                "Collider:getAngularVelocity",
                "Collider:setAngularVelocity",
                "Collider:getPosition",
                "Collider:setPosition",
                "Collider:getLinearVelocity",
                "Collider"
              ],
              "summary": "Set the linear velocity of the Collider.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The x component of the new velocity, in meters per second.",
                      "name": "vx",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the new velocity, in meters per second.",
                      "name": "vy",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the new velocity, in meters per second.",
                      "name": "vz",
                      "type": "number"
                    }
                  ],
                  "description": "Set the linear velocity of the collider using numbers.",
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The new velocity, in meters per second.",
                      "name": "velocity",
                      "type": "Vec3"
                    }
                  ],
                  "description": "Set the linear velocity of the collider using a vector.",
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the mass of the Collider.\n\nThe relative mass of colliders determines how they react when they collide.  A heavier collider has more momentum than a lighter collider moving the same speed, and will impart more force on the lighter collider.\n\nMore generally, heavier colliders react less to forces they receive, including forces applied with functions like `Collider:applyForce`.\n\nColliders with higher mass do not fall faster.  Use `Collider:setLinearDamping` to give a collider drag to make it fall slower or `Collider:setGravityScale` to change the way it reacts to gravity.",
              "key": "Collider:setMass",
              "module": "lovr.physics",
              "name": "setMass",
              "notes": "The mass must be positive.  Attempting to set a zero or negative mass will error.\n\nBy default, the mass of the Collider is kept up to date automatically as the Collider\u0027s shapes change.  Use `Collider:setAutomaticMass` to disable this.\n\nUse `Collider:resetMassData` to reset the mass based on the Collider\u0027s shapes.\n\nIf the Collider is kinematic or all translation axes are disabled, this function will do nothing.",
              "related": [
                "Collider:getInertia",
                "Collider:setInertia",
                "Collider:getCenterOfMass",
                "Collider:setCenterOfMass",
                "Collider:getAutomaticMass",
                "Collider:setAutomaticMass",
                "Collider:resetMassData",
                "Shape:getDensity",
                "Shape:setDensity",
                "Shape:getVolume",
                "Shape:getMass",
                "Collider:getMass",
                "Collider"
              ],
              "summary": "Set the mass of the Collider.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The new mass for the Collider, in kilograms.",
                      "name": "mass",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the orientation of the Collider in angle\/axis representation.",
              "key": "Collider:setOrientation",
              "module": "lovr.physics",
              "name": "setOrientation",
              "related": [
                "Collider:applyTorque",
                "Collider:getAngularVelocity",
                "Collider:setAngularVelocity",
                "Collider:getPosition",
                "Collider:setPosition",
                "Collider:getPose",
                "Collider:setPose",
                "Collider:getOrientation",
                "Collider"
              ],
              "summary": "Set the orientation of the Collider.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The number of radians the Collider is rotated around its axis of rotation.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    }
                  ],
                  "description": "Set the orientation of the Collider using numbers.",
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The orientation of the Collider.",
                      "name": "orientation",
                      "type": "Quat"
                    }
                  ],
                  "description": "Set the orientation of the Collider using a quaternion.",
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the position and orientation of the Collider.",
              "key": "Collider:setPose",
              "module": "lovr.physics",
              "name": "setPose",
              "related": [
                "Collider:setPosition",
                "Collider:setOrientation",
                "Collider:getPose",
                "Collider"
              ],
              "summary": "Set the pose of the Collider.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The x position of the Collider, in meters.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y position of the Collider, in meters.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z position of the Collider, in meters.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The number of radians the Collider is rotated around its axis of rotation.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    }
                  ],
                  "description": "Set the pose of the Collider using numbers.",
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The position of the Collider, in meters.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "description": "The orientation of the Collider.",
                      "name": "orientation",
                      "type": "Quat"
                    }
                  ],
                  "description": "Set the pose of the Collider using vector types.",
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the position of the Collider.",
              "key": "Collider:setPosition",
              "module": "lovr.physics",
              "name": "setPosition",
              "related": [
                "Collider:applyForce",
                "Collider:getLinearVelocity",
                "Collider:setLinearVelocity",
                "Collider:getOrientation",
                "Collider:setOrientation",
                "Collider:getPose",
                "Collider:setPose",
                "Collider:getPosition",
                "Collider"
              ],
              "summary": "Set the position of the Collider.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The x position of the Collider, in meters.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y position of the Collider, in meters.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z position of the Collider, in meters.",
                      "name": "z",
                      "type": "number"
                    }
                  ],
                  "description": "Set the position of the Collider using numbers.",
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The position of the Collider, in meters.",
                      "name": "position",
                      "type": "Vec3"
                    }
                  ],
                  "description": "Set the position of the Collider using a vector.",
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the restitution of the Collider.  Restitution makes a Collider bounce when it collides with other objects.  A restitution value of zero would result in an inelastic collision response, whereas 1.0 would result in an elastic collision that preserves all of the velocity.",
              "key": "Collider:setRestitution",
              "module": "lovr.physics",
              "name": "setRestitution",
              "notes": "To improve stability of the simulation and allow colliders to come to rest, restitution is only applied if the collider is moving above a certain speed.  This can be configured using the `restitutionThreshold` option in `lovr.physics.newWorld`.\n\nNegative restitution is not meaningful and is clamped to zero.",
              "related": [
                "Contact:getRestitution",
                "Contact:setRestitution",
                "Collider:getFriction",
                "Collider:setFriction",
                "Collider:getRestitution",
                "Collider"
              ],
              "summary": "Set the bounciness of the Collider.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The restitution of the Collider.",
                      "name": "restitution",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets whether the Collider should be a sensor.  Sensors do not collide with other objects, but they can still sense collisions with the collision callbacks set by `World:setCallbacks`.  Use them to trigger gameplay behavior when an object is inside a region of space.",
              "key": "Collider:setSensor",
              "module": "lovr.physics",
              "name": "setSensor",
              "notes": "Sensors are still reported as hits when doing raycasts and other queries.  Use tags to ignore sensors if needed.\n\nWhen a World is created, a set of collision tags can be marked as \"static\", for performance. Sensors do not detect collision with colliders that have a static tag.  Also, if a sensor itself has a static tag, it will not be able to detect collisions with sleeping colliders.  If a Collider enters a static sensor and goes to sleep, the `exit` callback is called and the sensor is no longer able to detect that collider.\n\nSensors can not use continuous collision detection.\n\nSensors will never go to sleep.",
              "related": [
                "Collider:setKinematic",
                "Collider:setEnabled",
                "World:overlapShape",
                "World:setCallbacks",
                "Collider:isSensor",
                "Collider"
              ],
              "summary": "Set whether the Collider should be a sensor.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "Whether the Collider should be a sensor.",
                      "name": "sensor",
                      "type": "boolean"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets whether the Collider is allowed to automatically go to sleep.\n\nWhen enabled, the Collider will go to sleep if it hasn\u0027t moved in a while.  The physics engine does not simulate movement for colliders that are asleep, which saves a lot of CPU for a typical physics world where most objects are at rest at any given time.",
              "key": "Collider:setSleepingAllowed",
              "module": "lovr.physics",
              "name": "setSleepingAllowed",
              "notes": "Sleeping is enabled by default.  Sleeping can be disabled globally using the `allowSleep` option in `lovr.physics.newWorld`.\n\nColliders can still be put to sleep manually with `Collider:setAwake`, even if automatic sleeping is disabled.\n\nSleeping colliders will wake up when:\n\n- Colliding with a moving collider\n- Awakened explicitly with `Collider:setAwake`\n- Changing position `Collider:setPosition` or `Collider:setOrientation`\n- Changing velocity (to something non-zero)\n- Applying force, torque, or an impulse\n- Enabling a joint connected to the sleeping collider\n\nNotably, the following will not wake up the collider:\n\n- Changing its kinematic state with `Collider:setKinematic`\n- Changing its shape with `Collider:addShape` or `Collider:removeShape`\n- Disabling or destroying a sleeping collider it is resting on\n\nSensors will never go to sleep.",
              "related": [
                "Collider:isAwake",
                "Collider:setAwake",
                "Collider:isSleepingAllowed",
                "Collider"
              ],
              "summary": "Set whether the Collider is allowed to sleep.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "Whether the Collider can go to sleep.",
                      "name": "sleepy",
                      "type": "boolean"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the Collider\u0027s tag.\n\nTags are strings that represent the category of a collider.  Use `World:enableCollisionBetween` and `World:disableCollisionBetween` to control which pairs of tags should collide with each other.  Physics queries like `World:raycast` also use tags to filter their results.\n\nThe list of available tags is set in `lovr.physics.newWorld`.",
              "key": "Collider:setTag",
              "module": "lovr.physics",
              "name": "setTag",
              "related": [
                "World:getTags",
                "World:disableCollisionBetween",
                "World:enableCollisionBetween",
                "World:isCollisionEnabledBetween",
                "lovr.physics.newWorld",
                "Collider:getTag",
                "Collider"
              ],
              "summary": "Set the Collider\u0027s tag.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The Collider\u0027s tag.",
                      "name": "tag",
                      "type": "string"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": {},
                  "description": "Clear the Collider\u0027s tag.",
                  "returns": {}
                }
              ]
            },
            {
              "description": "Associates a Lua value with the Collider.",
              "key": "Collider:setUserData",
              "module": "lovr.physics",
              "name": "setUserData",
              "notes": "Set the user data to `nil` to clear any existing reference.\n\nThe userdata is useful for linking a Collider with custom data:\n\n    local collider \u003d world:raycast(origin, direction, \u0027enemy\u0027)\n\n    if collider then\n      -- Get the enemy object from its Collider\n      local enemy \u003d collider:getUserData()\n      enemy.health \u003d 0\n    end\n\nThe user data is not shared between threads.  Each thread has its own user data for the Collider.",
              "related": [
                "Shape:getUserData",
                "Shape:setUserData",
                "Joint:getUserData",
                "Joint:setUserData",
                "Collider:getUserData",
                "Collider"
              ],
              "summary": "Associate a Lua value with the Collider.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The custom value to associate with the Collider.",
                      "name": "data",
                      "type": "*"
                    }
                  ],
                  "returns": {}
                }
              ]
            }
          ],
          "module": "lovr.physics",
          "name": "Collider",
          "related": ["lovr.physics"],
          "sections": [
            {
              "links": [
                "Collider:getPosition",
                "Collider:setPosition",
                "Collider:getOrientation",
                "Collider:setOrientation",
                "Collider:getPose",
                "Collider:setPose",
                "Collider:getLocalPoint",
                "Collider:getWorldPoint",
                "Collider:getLocalVector",
                "Collider:getWorldVector",
                "Collider:getAABB",
                "Collider:getLinearVelocity",
                "Collider:setLinearVelocity",
                "Collider:getAngularVelocity",
                "Collider:setAngularVelocity",
                "Collider:getLinearVelocityFromLocalPoint",
                "Collider:getLinearVelocityFromWorldPoint",
                "Collider:moveKinematic",
                "Collider:applyForce",
                "Collider:applyTorque",
                "Collider:applyLinearImpulse",
                "Collider:applyAngularImpulse",
                "Collider:getLinearDamping",
                "Collider:setLinearDamping",
                "Collider:getAngularDamping",
                "Collider:setAngularDamping",
                "Collider:isKinematic",
                "Collider:setKinematic",
                "Collider:isContinuous",
                "Collider:setContinuous",
                "Collider:getDegreesOfFreedom",
                "Collider:setDegreesOfFreedom",
                "Collider:getGravityScale",
                "Collider:setGravityScale",
                "Collider:isSleepingAllowed",
                "Collider:setSleepingAllowed",
                "Collider:isAwake",
                "Collider:setAwake"
              ],
              "name": "Motion"
            },
            {
              "links": [
                "Collider:getTag",
                "Collider:setTag",
                "Collider:getShape",
                "Collider:getShapes",
                "Collider:addShape",
                "Collider:removeShape",
                "Collider:isSensor",
                "Collider:setSensor",
                "Collider:getFriction",
                "Collider:setFriction",
                "Collider:getRestitution",
                "Collider:setRestitution"
              ],
              "name": "Collision"
            },
            {
              "links": [
                "Collider:getMass",
                "Collider:setMass",
                "Collider:getInertia",
                "Collider:setInertia",
                "Collider:getCenterOfMass",
                "Collider:setCenterOfMass",
                "Collider:getAutomaticMass",
                "Collider:setAutomaticMass",
                "Collider:resetMassData"
              ],
              "name": "Mass"
            },
            {
              "links": [
                "Collider:getUserData",
                "Collider:setUserData",
                "Collider:isEnabled",
                "Collider:setEnabled",
                "Collider:getWorld",
                "Collider:getJoints",
                "Collider:destroy",
                "Collider:isDestroyed"
              ],
              "name": "Miscellaneous"
            }
          ],
          "summary": "A single object in a physics simulation."
        },
        {
          "description": "TODO",
          "extends": "Joint",
          "key": "ConeJoint",
          "methods": [
            {
              "description": "Returns the axis of the ConeJoint, in world space.  The axis is relative to the first Collider connected to the Joint, so it will rotate as the collider does.  The relative angle between the axis and the second collider will be constrained based on the ConeJoint\u0027s angle limit.",
              "key": "ConeJoint:getAxis",
              "module": "lovr.physics",
              "name": "getAxis",
              "related": ["ConeJoint"],
              "summary": "Get the axis of the cone.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The x component of the axis.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis.",
                      "name": "az",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the angle limit of the ConeJoint.  The relative angle between the ConeJoint\u0027s axis and the second Collider will be constrained to this limit.",
              "key": "ConeJoint:getLimit",
              "module": "lovr.physics",
              "name": "getLimit",
              "notes": "The default limit is zero, preventing any rotation away from the axis.",
              "related": ["ConeJoint:setLimit", "ConeJoint"],
              "summary": "Get the angle limit of the ConeJoint.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The angle limit, in radians.",
                      "name": "limit",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Sets the angle limit of the ConeJoint.  The relative angle between the ConeJoint\u0027s axis and the second Collider will be constrained to this limit.",
              "key": "ConeJoint:setLimit",
              "module": "lovr.physics",
              "name": "setLimit",
              "notes": "The default limit is zero, preventing any rotation away from the axis.",
              "related": ["ConeJoint:getLimit", "ConeJoint"],
              "summary": "Set the angle limit of the ConeJoint.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The new limit in radians, between 0 and pi.",
                      "name": "limit",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            }
          ],
          "module": "lovr.physics",
          "name": "ConeJoint",
          "related": ["Joint", "lovr.physics"],
          "summary": "TODO"
        },
        {
          "description": "TODO",
          "key": "Contact",
          "methods": [
            {
              "description": "Returns the two Colliders that are in contact.",
              "key": "Contact:getColliders",
              "module": "lovr.physics",
              "name": "getColliders",
              "related": ["Contact:getShapes", "Contact"],
              "summary": "Get the two Colliders that are in contact.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The first collider.",
                      "name": "first",
                      "type": "Collider"
                    },
                    {
                      "description": "The second collider.",
                      "name": "second",
                      "type": "Collider"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the friction of the Contact.  Lower friction makes it easier for the colliders to slide against each other.",
              "key": "Contact:getFriction",
              "module": "lovr.physics",
              "name": "getFriction",
              "related": [
                "Collider:getFriction",
                "Collider:setFriction",
                "Contact:getRestitution",
                "Contact:setRestitution",
                "Contact:setFriction",
                "Contact"
              ],
              "summary": "Get the friction of the Contact.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The contact friction.",
                      "name": "friction",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the normal vector of the Contact.  This is a direction vector that represents which direction the second collider should move to resolve the collision.",
              "key": "Contact:getNormal",
              "module": "lovr.physics",
              "name": "getNormal",
              "related": ["Contact:getOverlap", "Contact:getPoints", "Contact"],
              "summary": "Get the normal vector of the Contact.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The x component of the normal vector.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the normal vector.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the normal vector.",
                      "name": "z",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the amount of overlap between the colliders.",
              "key": "Contact:getOverlap",
              "module": "lovr.physics",
              "name": "getOverlap",
              "related": ["Contact:getNormal", "Contact"],
              "summary": "Get the amount of overlap between the colliders.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The amount of overlap, in meters.",
                      "name": "overlap",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the contact points of the Contact.  These are the points where the colliders are intersecting.",
              "key": "Contact:getPoints",
              "module": "lovr.physics",
              "name": "getPoints",
              "related": ["Contact"],
              "summary": "Get the contact points of the Contact.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "Triplets of x\/y\/z numbers, one for each contact point.",
                      "name": "...points",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the restitution of the Contact.  Restitution makes the Colliders bounce off of each other.  A restitution value of zero results in an inelastic collision response, whereas 1.0 results in an elastic collision that preserves all of the velocity.  Restitution can be bigger than 1.0 to make the collision even more bouncy.",
              "key": "Contact:getRestitution",
              "module": "lovr.physics",
              "name": "getRestitution",
              "notes": "The default restitution is the maximum restitution of either of the colliders.",
              "related": [
                "Collider:getRestitution",
                "Collider:setRestitution",
                "Contact:getFriction",
                "Contact:setFriction",
                "Contact:setRestitution",
                "Contact"
              ],
              "summary": "Get the bounciness of the Contact.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The contact restitution.",
                      "name": "restitution",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the two Shapes that are in contact.",
              "key": "Contact:getShapes",
              "module": "lovr.physics",
              "name": "getShapes",
              "related": ["Contact:getColliders", "Contact"],
              "summary": "Get the two Shapes that are in contact.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The first shape.",
                      "name": "first",
                      "type": "Shape"
                    },
                    {
                      "description": "The second shape.",
                      "name": "second",
                      "type": "Shape"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the world space surface velocity of the Contact.  This can be used to achieve a conveyor belt effect.",
              "key": "Contact:getSurfaceVelocity",
              "module": "lovr.physics",
              "name": "getSurfaceVelocity",
              "related": ["Contact:setSurfaceVelocity", "Contact"],
              "summary": "Get the surface velocity of the Contact.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The x component of the surface velocity.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the surface velocity.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the surface velocity.",
                      "name": "z",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns whether the Contact is enabled.  Disabled contacts do not generate any collision response.  Use `Contact:setEnabled` to disable a contact to selectively ignore certain collisions.",
              "key": "Contact:isEnabled",
              "module": "lovr.physics",
              "name": "isEnabled",
              "related": [
                "Collider:isEnabled",
                "Collider:setEnabled",
                "World:setCallbacks",
                "Contact:setEnabled",
                "Contact"
              ],
              "summary": "Check if the Contact is enabled.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "Whether the Contact is enabled.",
                      "name": "enabled",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Enables or disables the Contact.  Disabled contacts do not generate any collision response.",
              "key": "Contact:setEnabled",
              "module": "lovr.physics",
              "name": "setEnabled",
              "notes": "Note that this is the slowest way to ignore a collision.  Faster ways to disable collisions (in increasing order of speed) are:\n\n- The `filter` callback in `World:setCallbacks`\n- Disabling collision between tags with `World:disableCollisionBetween`\n- Removing the collider from the World completely with `Collider:setEnabled`",
              "related": ["Contact:isEnabled", "Contact"],
              "summary": "Enable or disable the Contact.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "Whether the Contact should be enabled.",
                      "name": "enable",
                      "type": "boolean"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the friction of the Contact.  Lower friction makes it easier for the colliders to slide against each other.  This overrides the default friction computed by the friction of the two Colliders.",
              "key": "Contact:setFriction",
              "module": "lovr.physics",
              "name": "setFriction",
              "notes": "The default friction is computed from the geometric mean of the Colliders\u0027 friction:\n\n    friction \u003d (frictionA * frictionB) ^ .5\n\nNegative frictions will be clamped to zero.",
              "related": [
                "Collider:getFriction",
                "Collider:setFriction",
                "Contact:getRestitution",
                "Contact:setRestitution",
                "Contact:getFriction",
                "Contact"
              ],
              "summary": "Set the friction of the Contact.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The contact friction.",
                      "name": "friction",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the restitution of the Contact.  Restitution makes the Colliders bounce off of each other. A restitution value of zero results in an inelastic collision response, whereas 1.0 results in an elastic collision that preserves all of the velocity.  Restitution can be bigger than 1.0 to make the collision even more bouncy.",
              "key": "Contact:setRestitution",
              "module": "lovr.physics",
              "name": "setRestitution",
              "notes": "The default restitution is the maximum restitution of either of the colliders.\n\nNegative restitution values will be clamped to zero.",
              "related": [
                "Collider:getRestitution",
                "Collider:setRestitution",
                "Contact:getFriction",
                "Contact:setFriction",
                "Contact:getRestitution",
                "Contact"
              ],
              "summary": "Set the bounciness of the Contact.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The contact restitution.",
                      "name": "restitution",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the world space surface velocity of the Contact.  This can be used to achieve a conveyor belt effect.",
              "key": "Contact:setSurfaceVelocity",
              "module": "lovr.physics",
              "name": "setSurfaceVelocity",
              "related": ["Contact:getSurfaceVelocity", "Contact"],
              "summary": "Set the surface velocity of the Contact.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The x component of the surface velocity.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the surface velocity.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the surface velocity.",
                      "name": "z",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The surface velocity.",
                      "name": "velocity",
                      "type": "Vec3"
                    }
                  ],
                  "returns": {}
                }
              ]
            }
          ],
          "module": "lovr.physics",
          "name": "Contact",
          "related": ["lovr.physics"],
          "summary": "TODO"
        },
        {
          "constructors": [
            "lovr.physics.newConvexShape",
            "World:newConvexCollider"
          ],
          "description": "A type of `Shape` that is a convex hull of a collection of points, allowing for custom collision shapes.  It is similar to a `MeshShape`, but it is not required to be kinematic, and it will use the convex hull of the mesh instead of using the exact triangles of the object.\n\nConvex shapes can be created from a `Model`, `ModelData`, `Mesh`, or a table of point positions, similar to `MeshShape`.\n\nConvex shapes can be cloned by passing in an existing ConvexShape to clone:\n\n    model \u003d lovr.data.newModelData(\u0027rock.glb\u0027)\n    parent \u003d lovr.physics.newConvexShape(model)\n    clone \u003d lovr.physics.newConvexShape(parent, scale)\n\nThe clone will reuse all of the data from the parent, which speeds things up a lot.\n\nConvex shapes can have a custom scale applied to their points, and clones can have their own scale.",
          "examples": [
            {
              "code": "function lovr.load()\n  model \u003d lovr.graphics.newModel(\u0027eggplant.glb\u0027)\n  hull \u003d lovr.physics.newConvexShape(model)\n\n  -- Each face will be a list of points to draw a line through\n  faces \u003d {}\n\n  for f \u003d 1, hull:getFaceCount() do\n    local face \u003d {}\n\n    for _, pointindex in ipairs(hull:getFace(f)) do\n      local x, y, z \u003d hull:getPoint(pointindex)\n      table.insert(face, x)\n      table.insert(face, y)\n      table.insert(face, z)\n    end\n\n    -- Connect the last point back to the first point\n    table.insert(face, face[1])\n    table.insert(face, face[2])\n    table.insert(face, face[3])\n\n    table.insert(faces, face)\n  end\nend\n\nfunction lovr.draw(pass)\n  pass:push()\n  pass:translate(0, 0, -5)\n  pass:draw(model)\n\n  pass:setColor(1, 0, 0)\n  for i, points in pairs(faces) do\n    pass:line(points)\n  end\n  pass:pop()\nend",
              "description": "Drawing a convex hull."
            }
          ],
          "extends": "Shape",
          "key": "ConvexShape",
          "methods": [
            {
              "description": "Returns the indices of points that make up one of the faces of the convex hull.",
              "key": "ConvexShape:getFace",
              "module": "lovr.physics",
              "name": "getFace",
              "related": [
                "ConvexShape:getPoint",
                "ConvexShape:getFaceCount",
                "ConvexShape"
              ],
              "summary": "Get the point indices of one of the faces of the convex hull.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of the face.",
                      "name": "index",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "A table with point indices.  Use `ConvexShape:getPoint` to get the coordinates.  The points are given in counterclockwise order.",
                      "name": "points",
                      "type": "table"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the number of faces in the convex hull.",
              "key": "ConvexShape:getFaceCount",
              "module": "lovr.physics",
              "name": "getFaceCount",
              "related": ["ConvexShape:getFace", "ConvexShape"],
              "summary": "Get the number of faces in the convex hull.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The number of faces.",
                      "name": "count",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns one of the points in the convex hull, in local space.",
              "key": "ConvexShape:getPoint",
              "module": "lovr.physics",
              "name": "getPoint",
              "notes": "Currently, the point positions do not include the scale of the convex shape.",
              "related": ["ConvexShape:getPointCount", "ConvexShape"],
              "summary": "Get one of the points in the convex hull.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The index of the point.",
                      "name": "index",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The x coordinate.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z coordinate.",
                      "name": "z",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the number of points in the convex hull.",
              "key": "ConvexShape:getPointCount",
              "module": "lovr.physics",
              "name": "getPointCount",
              "notes": "This isn\u0027t necessarily the same as the number of points or vertices that were used to create the shape, since points inside the hull will be discarded.",
              "related": ["ConvexShape:getPoint", "ConvexShape"],
              "summary": "Get the number of points in the convex hull.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The number of points.",
                      "name": "count",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the scale the ConvexShape was created with.",
              "key": "ConvexShape:getScale",
              "module": "lovr.physics",
              "name": "getScale",
              "related": [
                "lovr.physics.newConvexShape",
                "World:newConvexCollider",
                "ConvexShape"
              ],
              "summary": "Get the scale the ConvexShape was created with.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The scale.",
                      "name": "scale",
                      "type": "number"
                    }
                  ]
                }
              ]
            }
          ],
          "module": "lovr.physics",
          "name": "ConvexShape",
          "related": ["Shape", "lovr.physics"],
          "summary": "A convex hull shape."
        },
        {
          "constructors": [
            "lovr.physics.newCylinderShape",
            "World:newCylinderCollider"
          ],
          "description": "A type of `Shape` that can be used for cylinder-shaped things.",
          "extends": "Shape",
          "key": "CylinderShape",
          "methods": [
            {
              "description": "Returns the length of the CylinderShape.",
              "key": "CylinderShape:getLength",
              "module": "lovr.physics",
              "name": "getLength",
              "related": [
                "CylinderShape:getRadius",
                "CylinderShape:setRadius",
                "CylinderShape:setLength",
                "CylinderShape"
              ],
              "summary": "Get the length of the CylinderShape.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The length of the cylinder, in meters.",
                      "name": "length",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the radius of the CylinderShape.",
              "key": "CylinderShape:getRadius",
              "module": "lovr.physics",
              "name": "getRadius",
              "related": [
                "CylinderShape:getLength",
                "CylinderShape:setLength",
                "CylinderShape:setRadius",
                "CylinderShape"
              ],
              "summary": "Get the radius of the CylinderShape.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The radius of the cylinder, in meters.",
                      "name": "radius",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Sets the length of the CylinderShape.",
              "key": "CylinderShape:setLength",
              "module": "lovr.physics",
              "name": "setLength",
              "notes": "This changes the mass of the shape.  If the shape is attached to a collider with automatic mass enabled, the mass properties of the collider will update as well.\n\nChanging shapes can make the physics engine explode since it can cause objects to overlap in unnatural ways.",
              "related": [
                "CylinderShape:getRadius",
                "CylinderShape:setRadius",
                "CylinderShape:getLength",
                "CylinderShape"
              ],
              "summary": "Set the length of the CylinderShape.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The new length, in meters.",
                      "name": "length",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the radius of the CylinderShape.",
              "key": "CylinderShape:setRadius",
              "module": "lovr.physics",
              "name": "setRadius",
              "notes": "This changes the mass of the shape.  If the shape is attached to a collider with automatic mass enabled, the mass properties of the collider will update as well.\n\nChanging shapes can make the physics engine explode since it can cause objects to overlap in unnatural ways.",
              "related": [
                "CylinderShape:getLength",
                "CylinderShape:setLength",
                "CylinderShape:getRadius",
                "CylinderShape"
              ],
              "summary": "Set the radius of the CylinderShape.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The new radius, in meters.",
                      "name": "radius",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            }
          ],
          "module": "lovr.physics",
          "name": "CylinderShape",
          "related": ["Shape", "lovr.physics"],
          "summary": "A cylinder Shape."
        },
        {
          "constructors": ["lovr.physics.newDistanceJoint"],
          "description": "A DistanceJoint is a type of `Joint` that tries to keep two colliders within a certain distance. The distance is determined by the initial distance between the anchor points.  The joint allows for rotation on the anchor points.",
          "extends": "Joint",
          "key": "DistanceJoint",
          "methods": [
            {
              "description": "Returns the minimum and maximum distance allowed between the Colliders.",
              "key": "DistanceJoint:getLimits",
              "module": "lovr.physics",
              "name": "getLimits",
              "notes": "The limits default to the distance between the Colliders when the Joint was created.",
              "related": ["DistanceJoint:setLimits", "DistanceJoint"],
              "summary": "Get the minimum and maximum distance.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The minimum distance, in meters.  The Colliders won\u0027t be able to get closer than this.",
                      "name": "min",
                      "type": "number"
                    },
                    {
                      "description": "The maximum distance, in meters.  The Colliders won\u0027t be able to get further than this.",
                      "name": "max",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the DistanceJoint\u0027s spring parameters.  Use this to control how fast the joint pulls the colliders back together at the distance limits.",
              "key": "DistanceJoint:getSpring",
              "module": "lovr.physics",
              "name": "getSpring",
              "notes": "Higher frequencies make the spring more stiff.  When zero (the default), the spring is disabled and the limits will be as stiff as possible.\n\nThe damping ratio controls how quickly the oscillation slows down:\n\n- Undamped: Zero damping will cause the spring to oscillate forever.  (Note that the spring may\n  still lose a small amount of energy over time).\n- Underdamped: Damping less than one results in a system that is underdamped.  The spring will\n  oscillate around the target, but the oscillations will decay over time, eventually stabilizing\n  at the target.\n- Overdamped: Damping greater than one will not have any oscillation, and the spring will take\n  extra time to reach the target.\n- Critical Damping: When the damping is exactly 1.0, there is no oscillation and the spring\n  takes the minimum amount of time to reach the target (based on the frequency).\n\nThe default damping ratio is 1.",
              "related": ["DistanceJoint:setSpring", "DistanceJoint"],
              "summary": "Get the spring parameters of the joint.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The frequency of the spring, in hertz.  Higher frequencies make the spring more stiff.  When zero, the spring is disabled.",
                      "name": "frequency",
                      "type": "number"
                    },
                    {
                      "description": "The damping ratio of the spring.",
                      "name": "damping",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Sets the minimum and maximum distance allowed between the Colliders.",
              "key": "DistanceJoint:setLimits",
              "module": "lovr.physics",
              "name": "setLimits",
              "notes": "The limits default to the distance between the Colliders when the Joint was created.",
              "related": ["DistanceJoint:getLimits", "DistanceJoint"],
              "summary": "Set the minimum and maximum distance.",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "0",
                      "description": "The minimum distance, in meters.  The Colliders won\u0027t be able to get closer than this.",
                      "name": "min",
                      "type": "number"
                    },
                    {
                      "default": "min",
                      "description": "The maximum distance, in meters.  The Colliders won\u0027t be able to get further than this.",
                      "name": "max",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": {},
                  "description": "Remove the limits, setting the minimum distance to zero and the maximum distance to infinity.",
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the DistanceJoint\u0027s spring parameters.  Use this to control how fast the joint pulls the colliders back together at the distance limits.",
              "key": "DistanceJoint:setSpring",
              "module": "lovr.physics",
              "name": "setSpring",
              "notes": "Higher frequencies make the spring more stiff.  When zero (the default), the spring is disabled and the limits will be as stiff as possible.\n\nThe damping ratio controls how quickly the oscillation slows down:\n\n- Undamped: Zero damping will cause the spring to oscillate forever.  (Note that the spring may\n  still lose a small amount of energy over time).\n- Underdamped: Damping less than one results in a system that is underdamped.  The spring will\n  oscillate around the target, but the oscillations will decay over time, eventually stabilizing\n  at the target.\n- Overdamped: Damping greater than one will not have any oscillation, and the spring will take\n  extra time to reach the target.\n- Critical Damping: When the damping is exactly 1.0, there is no oscillation and the spring\n  takes the minimum amount of time to reach the target (based on the frequency).",
              "related": ["DistanceJoint:getSpring", "DistanceJoint"],
              "summary": "Set the spring parameters of the joint.",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "0.0",
                      "description": "The frequency of the spring, in hertz.  Higher frequencies make the spring more stiff.  When zero, the spring is disabled.",
                      "name": "frequency",
                      "type": "number"
                    },
                    {
                      "default": "1.0",
                      "description": "The damping ratio of the spring.",
                      "name": "damping",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            }
          ],
          "module": "lovr.physics",
          "name": "DistanceJoint",
          "related": ["Collider", "Joint", "lovr.physics"],
          "summary": "A fixed distance joint."
        },
        {
          "constructors": ["lovr.physics.newHingeJoint"],
          "description": "A HingeJoint is a type of `Joint` that only allows colliders to rotate on a single axis.",
          "extends": "Joint",
          "key": "HingeJoint",
          "methods": [
            {
              "description": "Returns the current angle of the HingeJoint, relative to the rest position.",
              "key": "HingeJoint:getAngle",
              "module": "lovr.physics",
              "name": "getAngle",
              "related": [
                "HingeJoint:getAxis",
                "HingeJoint:getLimits",
                "HingeJoint:setLimits",
                "HingeJoint"
              ],
              "summary": "Get the current angle of the HingeJoint.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The hinge angle, in radians.",
                      "name": "angle",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the axis of the hinge, in world space.",
              "key": "HingeJoint:getAxis",
              "module": "lovr.physics",
              "name": "getAxis",
              "related": [
                "HingeJoint:getAngle",
                "Joint:getAnchors",
                "HingeJoint"
              ],
              "summary": "Get the rotation axis of the HingeJoint.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The x component of the axis.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis.",
                      "name": "z",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the friction of the HingeJoint.  This is a maximum torque force that will be applied, in newton meters.",
              "key": "HingeJoint:getFriction",
              "module": "lovr.physics",
              "name": "getFriction",
              "notes": "Friction is only applied when the motor is disabled.",
              "related": ["HingeJoint:setFriction", "HingeJoint"],
              "summary": "Get the friction of the HingeJoint.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The friction, in newton meters.",
                      "name": "friction",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the angle limits of the HingeJoint.  The \"zero\" angle is determined by the relative position of the colliders at the time the joint was created.",
              "key": "HingeJoint:getLimits",
              "module": "lovr.physics",
              "name": "getLimits",
              "notes": "The default limits are -\u03c0 and \u03c0.",
              "related": [
                "HingeJoint:getAngle",
                "HingeJoint:setLimits",
                "HingeJoint"
              ],
              "summary": "Get the angle limits of the HingeJoint.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The minimum angle, in radians.  Always between -\u03c0 and 0.",
                      "name": "min",
                      "type": "number"
                    },
                    {
                      "description": "The maximum angle, in radians.  Always between 0 and \u03c0.",
                      "name": "max",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the maximum amount of torque the motor can use to reach its target, in newton meters.\n\nThere are separate limits for each direction the hinge can move.  They\u0027re usually kept the same, but one of them can be set to zero to make a motor that can only push in one direction.  Note that both limits are positive.",
              "key": "HingeJoint:getMaxMotorTorque",
              "module": "lovr.physics",
              "name": "getMaxMotorTorque",
              "related": [
                "HingeJoint:getMotorTorque",
                "HingeJoint:setMaxMotorTorque",
                "HingeJoint"
              ],
              "summary": "Get the maximum amount of torque the motor can use.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The maximum amount of torque the motor can use to push the hinge in the \"positive\" direction, in newton meters.",
                      "name": "positive",
                      "type": "number"
                    },
                    {
                      "description": "The maximum amount of torque the motor can use to push the hinge in the \"negative\" direction, in newton meters.",
                      "name": "negative",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the motor mode of the HingeJoint.  When enabled, the motor will drive the hinge to a target angle (for the `position` mode) or a target speed (for the `velocity` mode), set by `HingeJoint:setMotorTarget`.",
              "key": "HingeJoint:getMotorMode",
              "module": "lovr.physics",
              "name": "getMotorMode",
              "related": [
                "HingeJoint:getMotorTarget",
                "HingeJoint:setMotorTarget",
                "HingeJoint:setMotorMode",
                "HingeJoint"
              ],
              "summary": "Get the motor mode of the HingeJoint.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The mode of the motor, or `nil` if the motor is disabled.",
                      "name": "mode",
                      "type": "MotorMode"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the spring parameters of the motor target.  These are similar to the spring parameters set by `HingeJoint:setSpring`, but they apply to the motor when it reaches its target instead of the angle limits of the hinge joint.  Note that these only take effect when the motor mode is `position`.",
              "key": "HingeJoint:getMotorSpring",
              "module": "lovr.physics",
              "name": "getMotorSpring",
              "notes": "See `HingeJoint:setSpring` for more detailed info on how the spring parameters work.",
              "related": [
                "HingeJoint:getSpring",
                "HingeJoint:setSpring",
                "HingeJoint:getMotorTarget",
                "HingeJoint:setMotorTarget",
                "HingeJoint:setMotorSpring",
                "HingeJoint"
              ],
              "summary": "Get the spring parameters of the motor target.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The frequency of the spring, in hertz.  Higher frequencies make the spring more stiff.  When zero, the spring is disabled.",
                      "name": "frequency",
                      "type": "number"
                    },
                    {
                      "description": "The damping ratio of the spring.",
                      "name": "damping",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the target value for the HingeJoint\u0027s motor.  This is either a target angle or a target velocity, based on the mode set by `HingeJoint:setMotorMode`.",
              "key": "HingeJoint:getMotorTarget",
              "module": "lovr.physics",
              "name": "getMotorTarget",
              "related": [
                "HingeJoint:getMotorMode",
                "HingeJoint:setMotorMode",
                "HingeJoint"
              ],
              "summary": "Get the target of the hinge motor.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The target value, in radians or radians per second, depending on the mode.",
                      "name": "target",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the current torque the motor is using to reach its target, in newton meters.",
              "key": "HingeJoint:getMotorTorque",
              "module": "lovr.physics",
              "name": "getMotorTorque",
              "related": [
                "HingeJoint:getMaxMotorTorque",
                "HingeJoint:setMaxMotorTorque",
                "HingeJoint"
              ],
              "summary": "Get the current motor torque.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The current torque, in newton meters.",
                      "name": "torque",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the spring parameters of the HingeJoint.  Use this to make the angle limits of the hinge \"soft\".  When the motor is active, a separate set of spring parameters can be set on the motor, see `HingeJoint:setMotorSpring`.",
              "key": "HingeJoint:getSpring",
              "module": "lovr.physics",
              "name": "getSpring",
              "notes": "Higher frequencies make the spring more stiff.  When zero (the default), the spring is disabled and the limits will be as stiff as possible.\n\nThe damping ratio controls how quickly the oscillation slows down:\n\n- Undamped: Zero damping will cause the spring to oscillate forever.  (Note that the spring may\n  still lose a small amount of energy over time).\n- Underdamped: Damping less than one results in a system that is underdamped.  The spring will\n  oscillate around the target, but the oscillations will decay over time, eventually stabilizing\n  at the target.\n- Overdamped: Damping greater than one will not have any oscillation, and the spring will take\n  extra time to reach the target.\n- Critical Damping: When the damping is exactly 1.0, there is no oscillation and the spring\n  takes the minimum amount of time to reach the target (based on the frequency).\n\nThe default damping ratio is 1.",
              "related": [
                "HingeJoint:getMotorSpring",
                "HingeJoint:setMotorSpring",
                "HingeJoint:setSpring",
                "HingeJoint"
              ],
              "summary": "Get the spring parameters of the HingeJoint limits.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The frequency of the spring, in hertz.  Higher frequencies make the spring more stiff.  When zero, the spring is disabled.",
                      "name": "frequency",
                      "type": "number"
                    },
                    {
                      "description": "The damping ratio of the spring.",
                      "name": "damping",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Sets the friction of the HingeJoint.  This is a maximum torque force that will be applied, in newton meters.",
              "key": "HingeJoint:setFriction",
              "module": "lovr.physics",
              "name": "setFriction",
              "notes": "Friction is only applied when the motor is disabled.",
              "related": ["HingeJoint:getFriction", "HingeJoint"],
              "summary": "Set the friction of the HingeJoint.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The friction, in newton meters.",
                      "name": "friction",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the angle limits of the HingeJoint.  The \"zero\" angle is determined by the relative position of the colliders at the time the joint was created.",
              "key": "HingeJoint:setLimits",
              "module": "lovr.physics",
              "name": "setLimits",
              "notes": "The default limits are -\u03c0 and \u03c0.",
              "related": [
                "HingeJoint:getAngle",
                "HingeJoint:getLimits",
                "HingeJoint"
              ],
              "summary": "Set the angle limits of the HingeJoint.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The minimum angle, in radians.  Should be between -\u03c0 and 0.",
                      "name": "min",
                      "type": "number"
                    },
                    {
                      "description": "The maximum angle, in radians.  Should be between 0 and \u03c0.",
                      "name": "max",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": {},
                  "description": "Disable the limits, setting them to -\u03c0 and \u03c0.",
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the maximum amount of torque the motor can use to reach its target, in newton meters.\n\nThere are separate limits for each direction the hinge can move.  They\u0027re usually kept the same, but one of them can be set to zero to make a motor that can only push in one direction.  Note that both limits are positive.",
              "key": "HingeJoint:setMaxMotorTorque",
              "module": "lovr.physics",
              "name": "setMaxMotorTorque",
              "related": [
                "HingeJoint:getMotorTorque",
                "HingeJoint:getMaxMotorTorque",
                "HingeJoint"
              ],
              "summary": "Set the maximum amount of torque the motor can use.",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "math.huge",
                      "description": "The maximum amount of torque the motor can use to push the hinge in the \"positive\" direction, in newton meters.",
                      "name": "positive",
                      "type": "number"
                    },
                    {
                      "default": "positive",
                      "description": "The maximum amount of torque the motor can use to push the hinge in the \"negative\" direction, in newton meters.",
                      "name": "negative",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the motor mode of the HingeJoint.  When enabled, the motor will drive the hinge to a target angle (for the `position` mode) or a target speed (for the `velocity` mode), set by `HingeJoint:setMotorTarget`.",
              "key": "HingeJoint:setMotorMode",
              "module": "lovr.physics",
              "name": "setMotorMode",
              "related": [
                "HingeJoint:getMotorTarget",
                "HingeJoint:setMotorTarget",
                "HingeJoint:getMotorMode",
                "HingeJoint"
              ],
              "summary": "Set the motor mode of the HingeJoint.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The mode of the motor.",
                      "name": "mode",
                      "type": "MotorMode"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": {},
                  "description": "Disables the motor.",
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the spring parameters of the motor target.  These are similar to the spring parameters set by `HingeJoint:setSpring`, but they apply to the motor when it reaches its target instead of the angle limits of the hinge joint.  Note that these only take effect when the motor mode is `position`.",
              "key": "HingeJoint:setMotorSpring",
              "module": "lovr.physics",
              "name": "setMotorSpring",
              "notes": "See `HingeJoint:setSpring` for more detailed info on how the spring parameters work.",
              "related": [
                "HingeJoint:getSpring",
                "HingeJoint:setSpring",
                "HingeJoint:getMotorTarget",
                "HingeJoint:setMotorTarget",
                "HingeJoint:getMotorSpring",
                "HingeJoint"
              ],
              "summary": "Set the spring parameters of the motor target.",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "0.0",
                      "description": "The frequency of the spring, in hertz.  Higher frequencies make the spring more stiff.  When zero, the spring is disabled.",
                      "name": "frequency",
                      "type": "number"
                    },
                    {
                      "default": "1.0",
                      "description": "The damping ratio of the spring.",
                      "name": "damping",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the target value for the HingeJoint\u0027s motor.  This is either a target angle or a target velocity, based on the mode set by `HingeJoint:setMotorMode`.",
              "key": "HingeJoint:setMotorTarget",
              "module": "lovr.physics",
              "name": "setMotorTarget",
              "related": [
                "HingeJoint:getMotorMode",
                "HingeJoint:setMotorMode",
                "HingeJoint:getMotorTarget",
                "HingeJoint"
              ],
              "summary": "Set the target of the hinge motor.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The target value, in radians or radians per second, depending on the mode.",
                      "name": "target",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the spring parameters of the HingeJoint.  Use this to make the angle limits of the hinge \"soft\".  When the motor is active, a separate set of spring parameters can be set on the motor, see `HingeJoint:setMotorSpring`.",
              "key": "HingeJoint:setSpring",
              "module": "lovr.physics",
              "name": "setSpring",
              "notes": "Higher frequencies make the spring more stiff.  When zero (the default), the spring is disabled and the limits will be as stiff as possible.\n\nThe damping ratio controls how quickly the oscillation slows down:\n\n- Undamped: Zero damping will cause the spring to oscillate forever.  (Note that the spring may\n  still lose a small amount of energy over time).\n- Underdamped: Damping less than one results in a system that is underdamped.  The spring will\n  oscillate around the target, but the oscillations will decay over time, eventually stabilizing\n  at the target.\n- Overdamped: Damping greater than one will not have any oscillation, and the spring will take\n  extra time to reach the target.\n- Critical Damping: When the damping is exactly 1.0, there is no oscillation and the spring\n  takes the minimum amount of time to reach the target (based on the frequency).",
              "related": [
                "HingeJoint:getMotorSpring",
                "HingeJoint:setMotorSpring",
                "HingeJoint:getSpring",
                "HingeJoint"
              ],
              "summary": "Set the spring parameters of the HingeJoint limits.",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "0.0",
                      "description": "The frequency of the spring, in hertz.  Higher frequencies make the spring more stiff.  When zero, the spring is disabled.",
                      "name": "frequency",
                      "type": "number"
                    },
                    {
                      "default": "1.0",
                      "description": "The damping ratio of the spring.",
                      "name": "damping",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            }
          ],
          "module": "lovr.physics",
          "name": "HingeJoint",
          "related": ["Collider", "Joint", "lovr.physics"],
          "summary": "A hinge joint."
        },
        {
          "constructors": [
            "lovr.physics.newWeldJoint",
            "lovr.physics.newBallJoint",
            "lovr.physics.newConeJoint",
            "lovr.physics.newDistanceJoint",
            "lovr.physics.newHingeJoint",
            "lovr.physics.newSliderJoint"
          ],
          "description": "A Joint is a physics object that constrains the movement of two Colliders.",
          "key": "Joint",
          "methods": [
            {
              "description": "Destroys the Joint, removing it from the World and breaking the connection between its Colliders.  There is no way to get the Joint back after destroying it, and attempting to use it will throw an error.  To temporarily disable a Joint, use `Joint:setEnabled`.",
              "key": "Joint:destroy",
              "module": "lovr.physics",
              "name": "destroy",
              "notes": "Joints are automatically destroyed if either of their Colliders are destroyed or if the World is destroyed or garbage collected.",
              "related": [
                "Joint:isDestroyed",
                "Joint:setEnabled",
                "Collider:destroy",
                "Shape:destroy",
                "World:destroy",
                "Joint"
              ],
              "summary": "Destroy the Joint.",
              "variants": [{ "arguments": {}, "returns": {} }]
            },
            {
              "description": "Returns the world space anchor points of the Joint.  Joints are attached to each collider at a single point, which is defined when the Joint is created.",
              "key": "Joint:getAnchors",
              "module": "lovr.physics",
              "name": "getAnchors",
              "related": ["Joint:getColliders", "Joint"],
              "summary": "Get the anchor points of the Joint.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The x coordinate of the anchor point on the first Collider, in world space.",
                      "name": "x1",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate of the anchor point on the first Collider, in world space.",
                      "name": "y1",
                      "type": "number"
                    },
                    {
                      "description": "The z coordinate of the anchor point on the first Collider, in world space.",
                      "name": "z1",
                      "type": "number"
                    },
                    {
                      "description": "The x coordinate of the anchor point on the second Collider, in world space.",
                      "name": "x2",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate of the anchor point on the second Collider, in world space.",
                      "name": "y2",
                      "type": "number"
                    },
                    {
                      "description": "The z coordinate of the anchor point on the second Collider, in world space.",
                      "name": "z2",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the Colliders the Joint is attached to.",
              "key": "Joint:getColliders",
              "module": "lovr.physics",
              "name": "getColliders",
              "related": ["Collider:getJoints", "Joint"],
              "summary": "Get the Colliders the Joint is attached to.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The first Collider.",
                      "name": "colliderA",
                      "type": "Collider"
                    },
                    {
                      "description": "The second Collider.",
                      "name": "colliderB",
                      "type": "Collider"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the magnitude of the force used to satisfy the Joint\u0027s constraint during the last physics update, in newtons.\n\nThis is useful for breakable joints.  Use `Joint:destroy` to break the joint if its force goes above a threshold.",
              "key": "Joint:getForce",
              "module": "lovr.physics",
              "name": "getForce",
              "notes": "This does not include the motor force of a `SliderJoint`, see `SliderJoint:getMotorForce`. that.",
              "related": [
                "Joint:getTorque",
                "SliderJoint:getMotorForce",
                "Joint"
              ],
              "summary": "Get the force used to satisfy the Joint\u0027s constraint.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The magnitude of the force used to satisfy the Joint\u0027s constraint.",
                      "name": "force",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the priority of the Joint.  Joints with a higher priority are more likely to be solved correctly.  Priority values are non-negative integers.",
              "key": "Joint:getPriority",
              "module": "lovr.physics",
              "name": "getPriority",
              "notes": "The default priority is zero.",
              "related": ["Joint:setPriority", "Joint"],
              "summary": "Get the priority of the Joint.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The integer priority value.",
                      "name": "priority",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the magnitude of the torque used to satisfy the Joint\u0027s constraint during the last physics update, in newton meters.\n\nThis is useful for breakable joints.  Use `Joint:destroy` to break the joint if its torque goes above a threshold.",
              "key": "Joint:getTorque",
              "module": "lovr.physics",
              "name": "getTorque",
              "notes": "This does not include the motor force of a `HingeJoint`, see `HingeJoint:getMotorForce`.",
              "related": [
                "Joint:getForce",
                "HingeJoint:getMotorTorque",
                "Joint"
              ],
              "summary": "Get the torque used to satisfy the Joint\u0027s constraint.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The magnitude of the torque used to satisfy the Joint\u0027s constraint.",
                      "name": "torque",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the type of the Joint.",
              "key": "Joint:getType",
              "module": "lovr.physics",
              "name": "getType",
              "related": ["Joint"],
              "summary": "Get the type of the Joint.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The type of the Joint.",
                      "name": "type",
                      "type": "JointType"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the Lua value associated with the Joint.",
              "key": "Joint:getUserData",
              "module": "lovr.physics",
              "name": "getUserData",
              "notes": "The user data is not shared between threads.  Each thread has its own user data for the Joint.",
              "related": [
                "Collider:getUserData",
                "Collider:setUserData",
                "Shape:getUserData",
                "Shape:setUserData",
                "Joint:setUserData",
                "Joint"
              ],
              "summary": "Get the Lua value associated with the Joint.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The custom value associated with the Joint.",
                      "name": "data",
                      "type": "*"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns whether a Joint has been destroyed.  This the only method that can be called on a destroyed Joint, using the Joint in any other way will error.",
              "key": "Joint:isDestroyed",
              "module": "lovr.physics",
              "name": "isDestroyed",
              "related": [
                "Joint:destroy",
                "Joint:isEnabled",
                "Joint:setEnabled",
                "Collider:destroy",
                "Shape:destroy",
                "World:destroy",
                "Joint"
              ],
              "summary": "Check if a Joint is destroyed.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "Whether the Joint has been destroyed.",
                      "name": "destroyed",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns whether the Joint is enabled.  Disabled joints do not affect the simulation in any way. Use `Joint:setEnabled` to reactivate the Joint later.  If the Joint is no longer needed, `Joint:destroy` is a better option that completely removes the Joint from the simulation.",
              "key": "Joint:isEnabled",
              "module": "lovr.physics",
              "name": "isEnabled",
              "related": ["Joint:destroy", "Joint:setEnabled", "Joint"],
              "summary": "Check if the Joint is enabled.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "Whether the Joint is enabled.",
                      "name": "enabled",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Enable or disable the Joint.  Disabled joints do not affect the simulation in any way.  If the Joint is no longer needed, `Joint:destroy` is a better option that completely removes the Joint from the simulation.",
              "key": "Joint:setEnabled",
              "module": "lovr.physics",
              "name": "setEnabled",
              "related": ["Joint:destroy", "Joint:isEnabled", "Joint"],
              "summary": "Enable or disable the Joint.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "Whether the Joint should be enabled.",
                      "name": "enabled",
                      "type": "boolean"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the priority of the Joint.  Joints with a higher priority are more likely to be solved correctly.  Priority values are non-negative integers.",
              "key": "Joint:setPriority",
              "module": "lovr.physics",
              "name": "setPriority",
              "notes": "The default priority is zero.",
              "related": ["Joint:getPriority", "Joint"],
              "summary": "Set the priority of the Joint.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The integer priority value.",
                      "name": "priority",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Associates a Lua value with the Joint.",
              "key": "Joint:setUserData",
              "module": "lovr.physics",
              "name": "setUserData",
              "notes": "Set the user data to `nil` to clear any existing reference.\n\nThe user data is not shared between threads.  Each thread has its own user data for the Joint.",
              "related": [
                "Collider:getUserData",
                "Collider:setUserData",
                "Shape:getUserData",
                "Shape:setUserData",
                "Joint:getUserData",
                "Joint"
              ],
              "summary": "Associate a Lua value with the Joint.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The custom value to associate with the Joint.",
                      "name": "data",
                      "type": "*"
                    }
                  ],
                  "returns": {}
                }
              ]
            }
          ],
          "module": "lovr.physics",
          "name": "Joint",
          "related": ["Collider", "lovr.physics"],
          "summary": "Joins two Colliders together."
        },
        {
          "constructors": [
            "lovr.physics.newMeshShape",
            "World:newMeshCollider"
          ],
          "description": "A type of `Shape` that can be used for triangle meshes.",
          "extends": "Shape",
          "key": "MeshShape",
          "methods": [
            {
              "description": "Returns the scale the MeshShape was created with.",
              "key": "MeshShape:getScale",
              "module": "lovr.physics",
              "name": "getScale",
              "related": [
                "lovr.physics.newMeshShape",
                "World:newMeshCollider",
                "MeshShape"
              ],
              "summary": "Get the scale the MeshShape was created with.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The scale.",
                      "name": "scale",
                      "type": "number"
                    }
                  ]
                }
              ]
            }
          ],
          "module": "lovr.physics",
          "name": "MeshShape",
          "notes": "If a `Collider` contains a MeshShape, it will be forced to become kinematic.  `ConvexShape` can be used instead for dynamic mesh colliders.",
          "related": ["Shape", "lovr.physics"],
          "summary": "A mesh Shape."
        },
        {
          "constructors": [
            "lovr.physics.newBoxShape",
            "lovr.physics.newSphereShape",
            "lovr.physics.newCapsuleShape",
            "lovr.physics.newCylinderShape",
            "lovr.physics.newConvexShape",
            "lovr.physics.newMeshShape",
            "lovr.physics.newTerrainShape",
            "World:newBoxCollider",
            "World:newSphereCollider",
            "World:newCapsuleCollider",
            "World:newCylinderCollider",
            "World:newConvexCollider",
            "World:newMeshCollider",
            "World:newTerrainCollider"
          ],
          "description": "A Shape is a physics object that can be attached to colliders to define their shape.",
          "key": "Shape",
          "methods": [
            {
              "description": "Returns whether a point is inside the Shape.\n\nThis takes into account the pose of the Shape\u0027s collider (if any), as well as its local offset set with `Shape:setOffset`.",
              "key": "Shape:containsPoint",
              "module": "lovr.physics",
              "name": "containsPoint",
              "related": [
                "Shape:raycast",
                "World:raycast",
                "World:shapecast",
                "World:overlapShape",
                "World:queryBox",
                "World:querySphere",
                "Shape"
              ],
              "summary": "Check if a point is inside the shape.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The x coordinate of the point.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate of the point.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z coordinate of the point.",
                      "name": "z",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "Whether the point is inside the Shape.",
                      "name": "hit",
                      "type": "boolean"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The point, as a vector.",
                      "name": "point",
                      "type": "Vec3"
                    }
                  ],
                  "returns": [
                    {
                      "description": "Whether the point is inside the Shape.",
                      "name": "hit",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Destroys the Shape, removing it from the Collider it\u0027s attached to.",
              "key": "Shape:destroy",
              "module": "lovr.physics",
              "name": "destroy",
              "notes": "Calling methods on the Shape after destroying it will error (except for `Shape:isDestroyed`).\n\nIf the Shape is attached to a Collider with automatic mass enabled, the collider\u0027s mass properties will update.",
              "related": [
                "Shape:isDestroyed",
                "Collider:destroy",
                "Joint:destroy",
                "World:destroy",
                "Shape"
              ],
              "summary": "Destroy the Shape.",
              "variants": [{ "arguments": {}, "returns": {} }]
            },
            {
              "description": "Returns the axis aligned bounding box of the Shape.",
              "key": "Shape:getAABB",
              "module": "lovr.physics",
              "name": "getAABB",
              "related": ["Collider:getAABB", "Shape"],
              "summary": "Get the Shape\u0027s axis aligned bounding box.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The minimum x coordinate of the box.",
                      "name": "minx",
                      "type": "number"
                    },
                    {
                      "description": "The maximum x coordinate of the box.",
                      "name": "maxx",
                      "type": "number"
                    },
                    {
                      "description": "The minimum y coordinate of the box.",
                      "name": "miny",
                      "type": "number"
                    },
                    {
                      "description": "The maximum y coordinate of the box.",
                      "name": "maxy",
                      "type": "number"
                    },
                    {
                      "description": "The minimum z coordinate of the box.",
                      "name": "minz",
                      "type": "number"
                    },
                    {
                      "description": "The maximum z coordinate of the box.",
                      "name": "maxz",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the center of mass of the Shape.  Currently the only shape that can have a non-zero center of mass is `ConvexShape`.",
              "key": "Shape:getCenterOfMass",
              "module": "lovr.physics",
              "name": "getCenterOfMass",
              "notes": "`MeshShape` and `TerrainShape` do not have a well-defined mass, this function returns zero for those shapes.",
              "related": [
                "Collider:getCenterOfMass",
                "Shape:getOffset",
                "Shape:setOffset",
                "Shape"
              ],
              "summary": "Get the center of mass of the Shape.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The x position of the center of mass.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y position of the center of mass.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z position of the center of mass.",
                      "name": "z",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the Collider the Shape is attached to.\n\nThis function will return `nil` if the Shape is not attached to a Collider.  When a Shape isn\u0027t attached to a Collider, the Shape can still be used for queries with `World:overlapShape` and `World:shapecast`.",
              "key": "Shape:getCollider",
              "module": "lovr.physics",
              "name": "getCollider",
              "notes": "A Shape can only be attached to one Collider at a time.",
              "related": [
                "Collider",
                "Collider:getShape",
                "Collider:getShapes",
                "Collider:addShape",
                "Collider:removeShape",
                "Shape"
              ],
              "summary": "Get the Collider the Shape is attached to.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The Collider the Shape is attached to, or nil if the Shape isn\u0027t attached to a Collider.",
                      "name": "collider",
                      "type": "Collider"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the density of the Shape, in kilograms per cubic meter.  The density, combined with the volume of the Shape, determines the Shape\u0027s overall mass.",
              "key": "Shape:getDensity",
              "module": "lovr.physics",
              "name": "getDensity",
              "notes": "The default density is 1,000, which is the density of water.\n\n`MeshShape` and `TerrainShape` do not have volume, and return 0.",
              "related": [
                "Shape:getVolume",
                "Shape:getMass",
                "Shape:setDensity",
                "Shape"
              ],
              "summary": "Get the density of the Shape.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The density of the Shape, in kilograms per cubic meter.",
                      "name": "density",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the inertia of the Shape.\n\nInertia is kind of like \"angular mass\".  Regular mass determines how resistant a Collider is to linear forces (movement), whereas inertia determines how resistant the Collider is to torque (rotation).  Colliders with less inertia are more spinny.\n\nIn 3D, inertia is represented by a 3x3 matrix, called a tensor.  To make calculations easier, the physics engine stores the inertia using eigenvalue decomposition, splitting the matrix into a diagonal matrix and a rotation.  It\u0027s complicated!\n\nIn a realistic simulation, mass and inertia follow a linear relationship.  If the mass of an object increases, the diagonal part of its inertia should increase proportionally.",
              "key": "Shape:getInertia",
              "module": "lovr.physics",
              "name": "getInertia",
              "notes": "`MeshShape` and `TerrainShape` do not have mass or volue, and for those shapes this function returns zeroes.",
              "related": [
                "Shape:getMass",
                "Shape:getCenterOfMass",
                "Collider:getInertia",
                "Shape"
              ],
              "summary": "Get the inertia of the Shape.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The x component of the diagonal matrix.",
                      "name": "dx",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the diagonal matrix.",
                      "name": "dy",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the diagonal matrix.",
                      "name": "dz",
                      "type": "number"
                    },
                    {
                      "description": "The angle of the inertia rotation.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the inertia rotation axis.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the inertia rotation axis.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the inertia rotation axis.",
                      "name": "az",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the mass of the Shape, in kilograms.  The mass is the volume multiplied by the density.",
              "key": "Shape:getMass",
              "module": "lovr.physics",
              "name": "getMass",
              "notes": "The mass of a Collider is the sum of the mass of all of its Shapes.  The center of a mass of a Collider is the average of all of its Shapes, weighted by their mass.\n\n`MeshShape` and `TerrainShape` do not have mass, and will return 0.",
              "related": [
                "Collider:getMass",
                "Collider:setMass",
                "Collider:resetMassData",
                "Shape:getVolume",
                "Shape:getDensity",
                "Shape:setDensity",
                "Shape:getInertia",
                "Shape:getCenterOfMass",
                "Shape"
              ],
              "summary": "Get the mass of the Shape.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The mass of the Shape, in kilograms.",
                      "name": "mass",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the local offset of the Shape.  When the Shape is attached to a Collider, it will have this offset relative to the Collider.",
              "key": "Shape:getOffset",
              "module": "lovr.physics",
              "name": "getOffset",
              "related": [
                "Shape:getPosition",
                "Shape:getOrientation",
                "Shape:getPose",
                "Shape:setOffset",
                "Shape"
              ],
              "summary": "Get the local offset of the Shape.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The local x offset of the Shape, in meters.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The local y offset of the Shape, in meters.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The local z offset of the Shape, in meters.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The number of radians the Shape is rotated around its axis of rotation.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Get the orientation of the Shape in world space, taking into account the position and orientation of the Collider it\u0027s attached to, if any.  Shapes that aren\u0027t attached to a Collider will return their local offset.",
              "key": "Shape:getOrientation",
              "module": "lovr.physics",
              "name": "getOrientation",
              "related": [
                "Shape:getPosition",
                "Shape:getPose",
                "Shape:getOffset",
                "Shape:setOffset",
                "Shape"
              ],
              "summary": "Get the orientation of the Shape.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The number of radians the Shape is rotated.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the rotation axis.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the rotation axis.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the rotation axis.",
                      "name": "az",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the position and orientation of the Shape in world space, taking into the account the position and orientation of the Collider it\u0027s attached to, if any.  Shapes that aren\u0027t attached to a Collider will return their local offset.",
              "key": "Shape:getPose",
              "module": "lovr.physics",
              "name": "getPose",
              "related": [
                "Shape:getPosition",
                "Shape:getOrientation",
                "Shape:getOffset",
                "Shape:setOffset",
                "Shape"
              ],
              "summary": "Get the pose of the Shape.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The x position of the Shape, in meters.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y position of the Shape, in meters.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z position of the Shape, in meters.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The number of radians the Shape is rotated around its axis of rotation.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the position of the Shape in world space, taking into the account the position and orientation of the Collider it\u0027s attached to, if any.  Shapes that aren\u0027t attached to a Collider will return their local offset.",
              "key": "Shape:getPosition",
              "module": "lovr.physics",
              "name": "getPosition",
              "related": [
                "Shape:getOrientation",
                "Shape:getPose",
                "Shape:getOffset",
                "Shape:setOffset",
                "Shape"
              ],
              "summary": "Get the position of the Shape.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The x position, in world space.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y position, in world space.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z position, in world space.",
                      "name": "z",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the type of the Shape.",
              "key": "Shape:getType",
              "module": "lovr.physics",
              "name": "getType",
              "related": ["Shape"],
              "summary": "Get the type of the Shape.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The type of the Shape.",
                      "name": "type",
                      "type": "ShapeType"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the Lua value associated with the Shape.",
              "key": "Shape:getUserData",
              "module": "lovr.physics",
              "name": "getUserData",
              "notes": "The user data is not shared between threads.  Each thread has its own user data for the Shape.",
              "related": [
                "Collider:getUserData",
                "Collider:setUserData",
                "Joint:getUserData",
                "Joint:setUserData",
                "Shape:setUserData",
                "Shape"
              ],
              "summary": "Get the Lua value associated with the Shape.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The custom value associated with the Shape.",
                      "name": "data",
                      "type": "*"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the volume of the Shape, in cubic meters.",
              "key": "Shape:getVolume",
              "module": "lovr.physics",
              "name": "getVolume",
              "notes": "`MeshShape` and `TerrainShape` do not have volume, and will return 0.",
              "related": [
                "Shape:getDensity",
                "Shape:setDensity",
                "Shape:getMass",
                "Shape:getAABB",
                "Shape"
              ],
              "summary": "Get the volume of the Shape.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The volume of the shape, in cubic meters.",
                      "name": "volume",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns whether the Shape has been destroyed.  Destroyed shapes can not be used for anything.",
              "key": "Shape:isDestroyed",
              "module": "lovr.physics",
              "name": "isDestroyed",
              "related": [
                "Shape:destroy",
                "Collider:isDestroyed",
                "Joint:isDestroyed",
                "World:isDestroyed",
                "Shape"
              ],
              "summary": "Check if the Shape is destroyed.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "Whether the Shape has been destroyed.",
                      "name": "destroyed",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Casts a ray against the Shape and returns the first intersection.\n\nThis takes into account the pose of the Shape\u0027s collider (if any), as well as its local offset set with `Shape:setOffset`.",
              "key": "Shape:raycast",
              "module": "lovr.physics",
              "name": "raycast",
              "related": [
                "World:raycast",
                "Shape:containsPoint",
                "World:shapecast",
                "World:overlapShape",
                "Shape"
              ],
              "summary": "Cast a ray against the shape.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The x coordinate of the origin of the ray.",
                      "name": "x1",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate of the origin of the ray.",
                      "name": "y1",
                      "type": "number"
                    },
                    {
                      "description": "The z coordinate of the origin of the ray.",
                      "name": "z1",
                      "type": "number"
                    },
                    {
                      "description": "The x coordinate of the endpoint of the ray.",
                      "name": "x2",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate of the endpoint of the ray.",
                      "name": "y2",
                      "type": "number"
                    },
                    {
                      "description": "The z coordinate of the endpoint of the ray.",
                      "name": "z2",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The x coordinate of the impact point.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate of the impact point.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z coordinate of the impact point.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the normal vector.",
                      "name": "nx",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the normal vector.",
                      "name": "ny",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the normal vector.",
                      "name": "nz",
                      "type": "number"
                    },
                    {
                      "description": "The index of the triangle that was hit, or `nil` if this is not a MeshShape.",
                      "name": "triangle",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The origin of the ray.",
                      "name": "origin",
                      "type": "Vec3"
                    },
                    {
                      "description": "The endpoint of the ray.",
                      "name": "endpoint",
                      "type": "Vec3"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The x coordinate of the impact point.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate of the impact point.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z coordinate of the impact point.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the normal vector.",
                      "name": "nx",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the normal vector.",
                      "name": "ny",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the normal vector.",
                      "name": "nz",
                      "type": "number"
                    },
                    {
                      "description": "The index of the triangle that was hit, or `nil` if this is not a MeshShape.",
                      "name": "triangle",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Sets the density of the Shape, in kilograms per cubic meter.  The density, combined with the volume of the Shape, determines the Shape\u0027s overall mass.",
              "key": "Shape:setDensity",
              "module": "lovr.physics",
              "name": "setDensity",
              "notes": "This changes the mass of the Shape.  If the Shape is attached to a Collider with automatic mass enabled, the Collider\u0027s mass properties will change as well.\n\nThe default density is 1,000, which is the density of water.\n\n`MeshShape` and `TerrainShape` do not have mass.",
              "related": [
                "Shape:getVolume",
                "Shape:getMass",
                "Shape:getDensity",
                "Shape"
              ],
              "summary": "Set the density of the Shape.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The density of the Shape, in kilograms per cubic meter.",
                      "name": "density",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the local offset of the Shape.  When the Shape is attached to a Collider, it will have this offset relative to the Collider.",
              "key": "Shape:setOffset",
              "module": "lovr.physics",
              "name": "setOffset",
              "related": [
                "Shape:getPosition",
                "Shape:getOrientation",
                "Shape:getPose",
                "Shape"
              ],
              "summary": "Set the local offset of the Shape.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The local x offset of the Shape, in meters.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The local y offset of the Shape, in meters.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The local z offset of the Shape, in meters.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The number of radians the Shape is rotated around its axis of rotation.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The local offset of the Shape, in meters.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "description": "The local rotation of the Shape, in meters.",
                      "name": "rotation",
                      "type": "Quat"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Associates a Lua value with the Shape.",
              "key": "Shape:setUserData",
              "module": "lovr.physics",
              "name": "setUserData",
              "notes": "Set the user data to `nil` to clear any existing reference.\n\nThe user data is not shared between threads.  Each thread has its own user data for the Shape.",
              "related": [
                "Collider:getUserData",
                "Collider:setUserData",
                "Joint:getUserData",
                "Joint:setUserData",
                "Shape:getUserData",
                "Shape"
              ],
              "summary": "Associate a Lua value with the Shape.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The custom value to associate with the Shape.",
                      "name": "data",
                      "type": "*"
                    }
                  ],
                  "returns": {}
                }
              ]
            }
          ],
          "module": "lovr.physics",
          "name": "Shape",
          "related": ["lovr.physics"],
          "sections": [
            {
              "links": [
                "Shape:getType",
                "Shape:destroy",
                "Shape:isDestroyed",
                "Shape:getCollider",
                "Shape:getUserData",
                "Shape:setUserData"
              ],
              "name": "Basics"
            },
            {
              "links": [
                "Shape:getOffset",
                "Shape:setOffset",
                "Shape:getPosition",
                "Shape:getOrientation",
                "Shape:getPose",
                "Shape:getAABB"
              ],
              "name": "Position"
            },
            {
              "links": [
                "Shape:getVolume",
                "Shape:getDensity",
                "Shape:setDensity",
                "Shape:getMass",
                "Shape:getInertia",
                "Shape:getCenterOfMass"
              ],
              "name": "Mass"
            },
            {
              "links": ["Shape:containsPoint", "Shape:raycast"],
              "name": "Queries"
            }
          ],
          "summary": "Defines the shape of Colliders."
        },
        {
          "constructors": ["lovr.physics.newSliderJoint"],
          "description": "A SliderJoint is a type of `Joint` that only allows colliders to move on a single axis.",
          "extends": "Joint",
          "key": "SliderJoint",
          "methods": [
            {
              "description": "Returns the axis of the slider, in world space.",
              "key": "SliderJoint:getAxis",
              "module": "lovr.physics",
              "name": "getAxis",
              "related": ["SliderJoint:getPosition", "SliderJoint"],
              "summary": "Get the axis of the SliderJoint.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The x component of the axis.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis.",
                      "name": "z",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the friction of the SliderJoint.  This is a maximum friction force that will be applied, in newtons, opposing movement along the slider axis.",
              "key": "SliderJoint:getFriction",
              "module": "lovr.physics",
              "name": "getFriction",
              "notes": "Friction is only applied when the motor is disabled.",
              "related": ["SliderJoint:setFriction", "SliderJoint"],
              "summary": "Get the friction of the SliderJoint.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The maximum friction force, in newtons.",
                      "name": "friction",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the position limits of the SliderJoint.  The \"zero\" position is determined by the relative position of the colliders at the time the joint was created, and positive positions are further apart along the slider axis.",
              "key": "SliderJoint:getLimits",
              "module": "lovr.physics",
              "name": "getLimits",
              "notes": "The default limits are -math.huge and math.huge (no limits).",
              "related": [
                "SliderJoint:getPosition",
                "SliderJoint:setLimits",
                "SliderJoint"
              ],
              "summary": "Get the position limits of the SliderJoint.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The minimum position, in meters.  Must be less than or equal to zero.",
                      "name": "min",
                      "type": "number"
                    },
                    {
                      "description": "The maximum position, in meters.  Must be greater than or equal to zero.",
                      "name": "max",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the maximum amount of force the motor can use to reach its target, in newtons.\n\nThere are separate limits for each direction the slider can move.  They\u0027re usually kept the same, but one of them can be set to zero to make a motor that can only push in one direction. Note that both limits are positive.",
              "key": "SliderJoint:getMaxMotorForce",
              "module": "lovr.physics",
              "name": "getMaxMotorForce",
              "related": [
                "SliderJoint:getMotorForce",
                "SliderJoint:setMaxMotorForce",
                "SliderJoint"
              ],
              "summary": "Get the maximum amount of force the motor can use.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The maximum amount of force the motor can use to push the slider in the \"positive\" direction, in newtons.",
                      "name": "positive",
                      "type": "number"
                    },
                    {
                      "description": "The maximum amount of force the motor can use to push the slider in the \"negative\" direction, in newtons.",
                      "name": "negative",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the current force the motor is using to reach its target, in newtons.",
              "key": "SliderJoint:getMotorForce",
              "module": "lovr.physics",
              "name": "getMotorForce",
              "related": [
                "SliderJoint:getMaxMotorForce",
                "SliderJoint:setMaxMotorForce",
                "SliderJoint"
              ],
              "summary": "Get the current motor force.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The current force, in newtons.",
                      "name": "force",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the motor mode of the SliderJoint.  When enabled, the motor will drive the slider to a target position (for the `position` mode) or a target speed (for the `velocity` mode), set by `SliderJoint:setMotorTarget`.",
              "key": "SliderJoint:getMotorMode",
              "module": "lovr.physics",
              "name": "getMotorMode",
              "related": [
                "SliderJoint:getMotorTarget",
                "SliderJoint:setMotorTarget",
                "SliderJoint:setMotorMode",
                "SliderJoint"
              ],
              "summary": "Get the motor mode of the SliderJoint.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The mode of the motor, or `nil` if the motor is disabled.",
                      "name": "mode",
                      "type": "MotorMode"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the spring parameters of the motor target.  These are similar to the spring parameters set by `SliderJoint:setSpring`, but they apply to the motor when it reaches its target instead of the position limits of the slider joint.  Note that these only take effect when the motor mode is `position`.",
              "key": "SliderJoint:getMotorSpring",
              "module": "lovr.physics",
              "name": "getMotorSpring",
              "notes": "See `SliderJoint:setSpring` for more detailed info on how the spring parameters work.",
              "related": [
                "SliderJoint:getSpring",
                "SliderJoint:setSpring",
                "SliderJoint:getMotorTarget",
                "SliderJoint:setMotorTarget",
                "SliderJoint:setMotorSpring",
                "SliderJoint"
              ],
              "summary": "Get the spring parameters of the motor target.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The frequency of the spring, in hertz.  Higher frequencies make the spring more stiff.  When zero, the spring is disabled.",
                      "name": "frequency",
                      "type": "number"
                    },
                    {
                      "description": "The damping ratio of the spring.",
                      "name": "damping",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the target value for the SliderJoint\u0027s motor.  This is either a target position or a target velocity, based on the mode set by `SliderJoint:setMotorMode`.",
              "key": "SliderJoint:getMotorTarget",
              "module": "lovr.physics",
              "name": "getMotorTarget",
              "related": [
                "SliderJoint:getMotorMode",
                "SliderJoint:setMotorMode",
                "SliderJoint"
              ],
              "summary": "Get the target of the slider motor.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The target value, in meters or meters per second, depending on the mode.",
                      "name": "target",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the position of the slider joint.  The \"zero\" position is the relative distance the colliders were at when the joint is created, and positive positions are further apart along the slider\u0027s axis.",
              "key": "SliderJoint:getPosition",
              "module": "lovr.physics",
              "name": "getPosition",
              "related": [
                "SliderJoint:getAxis",
                "SliderJoint:setLimits",
                "SliderJoint"
              ],
              "summary": "Get how far the SliderJoint is extended.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The position of the slider joint, in meters.",
                      "name": "position",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the spring parameters of the SliderJoint.  Use this to make the position limits of the slider \"soft\".  When the motor is active, a separate set of spring parameters can be set on the motor, see `SliderJoint:setMotorSpring`.",
              "key": "SliderJoint:getSpring",
              "module": "lovr.physics",
              "name": "getSpring",
              "notes": "Higher frequencies make the spring more stiff.  When zero (the default), the spring is disabled and the limits will be as stiff as possible.\n\nThe damping ratio controls how quickly the oscillation slows down:\n\n- Undamped: Zero damping will cause the spring to oscillate forever.  (Note that the spring may\n  still lose a small amount of energy over time).\n- Underdamped: Damping less than one results in a system that is underdamped.  The spring will\n  oscillate around the target, but the oscillations will decay over time, eventually stabilizing\n  at the target.\n- Overdamped: Damping greater than one will not have any oscillation, and the spring will take\n  extra time to reach the target.\n- Critical Damping: When the damping is exactly 1.0, there is no oscillation and the spring\n  takes the minimum amount of time to reach the target (based on the frequency).\n\nThe default damping ratio is 1.",
              "related": [
                "SliderJoint:getMotorSpring",
                "SliderJoint:setMotorSpring",
                "SliderJoint:setSpring",
                "SliderJoint"
              ],
              "summary": "Get the spring parameters of the SliderJoint limits.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The frequency of the spring, in hertz.  Higher frequencies make the spring more stiff.  When zero, the spring is disabled.",
                      "name": "frequency",
                      "type": "number"
                    },
                    {
                      "description": "The damping ratio of the spring.",
                      "name": "damping",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Sets the friction of the SliderJoint.  This is a maximum friction force that will be applied, in newtons, opposing movement along the slider axis.",
              "key": "SliderJoint:setFriction",
              "module": "lovr.physics",
              "name": "setFriction",
              "notes": "Friction is only applied when the motor is disabled.",
              "related": ["SliderJoint:getFriction", "SliderJoint"],
              "summary": "Set the friction of the SliderJoint.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The maximum friction force, in newtons.",
                      "name": "friction",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the position limits of the SliderJoint.  The \"zero\" position is determined by the relative position of the colliders at the time the joint was created, and positive distances are further apart on the slider axis.",
              "key": "SliderJoint:setLimits",
              "module": "lovr.physics",
              "name": "setLimits",
              "notes": "The default limits are -math.huge and math.huge.",
              "related": [
                "SliderJoint:getPosition",
                "SliderJoint:getLimits",
                "SliderJoint"
              ],
              "summary": "Set the position limits of the SliderJoint.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The minimum position, in meters.  Must be less than or equal to zero.",
                      "name": "min",
                      "type": "number"
                    },
                    {
                      "description": "The maximum position, in meters.  Must be greater than or equal to zero.",
                      "name": "max",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": {},
                  "description": "Disable the limits, setting them to -math.huge and math.huge.",
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the maximum amount of force the motor can use to reach its target, in newtons.\n\nThere are separate limits for each direction the slider can move.  They\u0027re usually kept the same, but one of them can be set to zero to make a motor that can only push in one direction. Note that both limits are positive.",
              "key": "SliderJoint:setMaxMotorForce",
              "module": "lovr.physics",
              "name": "setMaxMotorForce",
              "related": [
                "SliderJoint:getMotorForce",
                "SliderJoint:getMaxMotorForce",
                "SliderJoint"
              ],
              "summary": "Set the maximum amount of force the motor can use.",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "math.huge",
                      "description": "The maximum amount of force the motor can use to push the slider in the \"positive\" direction, in newtons.",
                      "name": "positive",
                      "type": "number"
                    },
                    {
                      "default": "positive",
                      "description": "The maximum amount of force the motor can use to push the slider in the \"negative\" direction, in newtons.",
                      "name": "negative",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the motor mode of the SliderJoint.  When enabled, the motor will drive the slider to a target position (for the `position` mode) or a target speed (for the `velocity` mode), set by `SliderJoint:setMotorTarget`.",
              "key": "SliderJoint:setMotorMode",
              "module": "lovr.physics",
              "name": "setMotorMode",
              "related": [
                "SliderJoint:getMotorTarget",
                "SliderJoint:setMotorTarget",
                "SliderJoint:getMotorMode",
                "SliderJoint"
              ],
              "summary": "Set the motor mode of the SliderJoint.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The mode of the motor.",
                      "name": "mode",
                      "type": "MotorMode"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": {},
                  "description": "Disables the motor.",
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the spring parameters of the motor target.  These are similar to the spring parameters set by `SldierJoint:setSpring`, but they apply to the motor when it reaches its target instead of the position limits of the slider joint.  Note that these only take effect when the motor mode is `position`.",
              "key": "SliderJoint:setMotorSpring",
              "module": "lovr.physics",
              "name": "setMotorSpring",
              "notes": "See `SldierJoint:setSpring` for more detailed info on how the spring parameters work.",
              "related": [
                "SliderJoint:getSpring",
                "SliderJoint:setSpring",
                "SliderJoint:getMotorTarget",
                "SliderJoint:setMotorTarget",
                "SliderJoint:getMotorSpring",
                "SliderJoint"
              ],
              "summary": "Set the spring parameters of the motor target.",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "0.0",
                      "description": "The frequency of the spring, in hertz.  Higher frequencies make the spring more stiff.  When zero, the spring is disabled.",
                      "name": "frequency",
                      "type": "number"
                    },
                    {
                      "default": "1.0",
                      "description": "The damping ratio of the spring.",
                      "name": "damping",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the target value for the SliderJoint\u0027s motor.  This is either a target position or a target velocity, based on the mode set by `SliderJoint:setMotorMode`.",
              "key": "SliderJoint:setMotorTarget",
              "module": "lovr.physics",
              "name": "setMotorTarget",
              "related": [
                "SliderJoint:getMotorMode",
                "SliderJoint:setMotorMode",
                "SliderJoint:getMotorTarget",
                "SliderJoint"
              ],
              "summary": "Set the target of the slider motor.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The target value, in meters or meters per second, depending on the mode.",
                      "name": "target",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the spring parameters of the SliderJoint.  Use this to make the position limits of the slider \"soft\".  When the motor is active, a separate set of spring parameters can be set on the motor, see `SliderJoint:setMotorSpring`.",
              "key": "SliderJoint:setSpring",
              "module": "lovr.physics",
              "name": "setSpring",
              "notes": "Higher frequencies make the spring more stiff.  When zero (the default), the spring is disabled and the limits will be as stiff as possible.\n\nThe damping ratio controls how quickly the oscillation slows down:\n\n- Undamped: Zero damping will cause the spring to oscillate forever.  (Note that the spring may\n  still lose a small amount of energy over time).\n- Underdamped: Damping less than one results in a system that is underdamped.  The spring will\n  oscillate around the target, but the oscillations will decay over time, eventually stabilizing\n  at the target.\n- Overdamped: Damping greater than one will not have any oscillation, and the spring will take\n  extra time to reach the target.\n- Critical Damping: When the damping is exactly 1.0, there is no oscillation and the spring\n  takes the minimum amount of time to reach the target (based on the frequency).",
              "related": [
                "SliderJoint:getMotorSpring",
                "SliderJoint:setMotorSpring",
                "SliderJoint:getSpring",
                "SliderJoint"
              ],
              "summary": "Set the spring parameters of the SliderJoint limits.",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "0.0",
                      "description": "The frequency of the spring, in hertz.  Higher frequencies make the spring more stiff.  When zero, the spring is disabled.",
                      "name": "frequency",
                      "type": "number"
                    },
                    {
                      "default": "1.0",
                      "description": "The damping ratio of the spring.",
                      "name": "damping",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            }
          ],
          "module": "lovr.physics",
          "name": "SliderJoint",
          "related": ["Collider", "Joint", "lovr.physics"],
          "summary": "A slider joint."
        },
        {
          "constructors": [
            "lovr.physics.newSphereShape",
            "World:newSphereCollider"
          ],
          "description": "A type of `Shape` that can be used for spheres.",
          "extends": "Shape",
          "key": "SphereShape",
          "methods": [
            {
              "description": "Returns the radius of the SphereShape.",
              "key": "SphereShape:getRadius",
              "module": "lovr.physics",
              "name": "getRadius",
              "related": ["SphereShape:setRadius", "SphereShape"],
              "summary": "Get the radius of the SphereShape.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The radius of the sphere, in meters.",
                      "name": "radius",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Sets the radius of the SphereShape.",
              "key": "SphereShape:setRadius",
              "module": "lovr.physics",
              "name": "setRadius",
              "notes": "This changes the mass of the shape.  If the shape is attached to a collider with automatic mass enabled, the mass properties of the collider will update as well.\n\nChanging shapes can make the physics engine explode since it can cause objects to overlap in unnatural ways.",
              "related": ["SphereShape:getRadius", "SphereShape"],
              "summary": "Set the radius of the SphereShape.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The radius of the sphere, in meters.",
                      "name": "radius",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            }
          ],
          "module": "lovr.physics",
          "name": "SphereShape",
          "related": ["Shape", "lovr.physics"],
          "summary": "A sphere Shape."
        },
        {
          "constructors": [
            "lovr.physics.newTerrainShape",
            "World:newTerrainCollider"
          ],
          "description": "A type of `Shape` that can be used for terrains and irregular surfaces.",
          "extends": "Shape",
          "key": "TerrainShape",
          "methods": {},
          "module": "lovr.physics",
          "name": "TerrainShape",
          "related": ["Shape", "lovr.physics"],
          "summary": "A terrain Shape."
        },
        {
          "constructors": ["lovr.physics.newWeldJoint"],
          "description": "A WeldJoint is a `Joint` that restricts all relative motion between two colliders, as though they were welded together into a single object.  All six degrees of freedom are constrained.\n\nWeldJoints are useful for making breakable objects.  Several colliders can be welded together with joints, and if `Joint:getForce` reports a large enough value, the joints can be disabled or destroyed, allowing the pieces to move freely.",
          "extends": "Joint",
          "key": "WeldJoint",
          "methods": {},
          "module": "lovr.physics",
          "name": "WeldJoint",
          "related": ["Joint", "lovr.physics"],
          "summary": "A joint that welds two colliders together."
        },
        {
          "constructors": ["lovr.physics.newWorld"],
          "description": "A World is an object that holds all of the colliders and joints in a physics simulation.\n\nBe sure to call `World:update` on the World every frame to advance the simulation.",
          "key": "World",
          "methods": [
            {
              "description": "Destroys the World.  This will destroy all colliders, shapes, and joints in the world.  After calling this function, the world can no longer be used.  Attempting to call a method on the World after destroying it will error, with the exception of `World:isDestroyed`.",
              "key": "World:destroy",
              "module": "lovr.physics",
              "name": "destroy",
              "notes": "If a World gets garbage collected, it will be destroyed and, consequently, all of the colliders, shapes, and joints in the World will be destroyed as well, even if they can still be reached by Lua.  This is an exception to the way objects in L\u00d6VR normally work, and is done to avoid issues with cycles in reference counting.",
              "related": [
                "Collider:destroy",
                "Shape:destroy",
                "Joint:destroy",
                "World"
              ],
              "summary": "Destroy the World!!  Muahaha!",
              "variants": [{ "arguments": {}, "returns": {} }]
            },
            {
              "description": "Disables collision between two tags.  Use `Collider:setTag` to set a Collider\u0027s tag.",
              "key": "World:disableCollisionBetween",
              "module": "lovr.physics",
              "name": "disableCollisionBetween",
              "notes": "By default, collision is enabled between all tags.\n\nAnother way of disabling collisions is by using the `filter` callback in `World:setCallbacks`. However, using tags is much faster than using the callback, because the physics engine calls the callback later in the collision detection process.  With tags, the colliders are ignored much earlier and precise collision detection is never performed.\n\nTags can be marked as \"static\" when the world is created, as an optimization hint.  Static tags will never collide with other static tags, regardless of whether collision is enabled between them.",
              "related": [
                "World:enableCollisionBetween",
                "World:isCollisionEnabledBetween",
                "lovr.physics.newWorld",
                "World:getTags",
                "Collider:setTag",
                "World"
              ],
              "summary": "Disable collision between two tags.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The first tag.",
                      "name": "tag1",
                      "type": "string"
                    },
                    {
                      "description": "The second tag.",
                      "name": "tag2",
                      "type": "string"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Enables collision between two tags.  Use `Collider:setTag` to set a Collider\u0027s tag.",
              "key": "World:enableCollisionBetween",
              "module": "lovr.physics",
              "name": "enableCollisionBetween",
              "notes": "By default, collision is enabled between all tags.\n\nTags can be marked as \"static\" when the world is created, as an optimization hint.  Static tags will never collide with other static tags, regardless of whether collision is enabled between them.",
              "related": [
                "World:disableCollisionBetween",
                "World:isCollisionEnabledBetween",
                "lovr.physics.newWorld",
                "World:getTags",
                "Collider:setTag",
                "World"
              ],
              "summary": "Enable collision between two tags.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The first tag.",
                      "name": "tag1",
                      "type": "string"
                    },
                    {
                      "description": "The second tag.",
                      "name": "tag2",
                      "type": "string"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "deprecated": true,
              "description": "Returns the angular damping parameters of the World.  Angular damping makes things less \"spinny\", making them slow down their angular velocity over time.",
              "key": "World:getAngularDamping",
              "module": "lovr.physics",
              "name": "getAngularDamping",
              "notes": "This sets the default damping for newly-created colliders.  Damping can also be set on a per-collider basis using `Collider:setAngularDamping`.",
              "related": [
                "Collider:getAngularDamping",
                "Collider:setAngularDamping",
                "World:setAngularDamping",
                "World"
              ],
              "summary": "Get the angular damping of the World.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The angular damping.",
                      "name": "damping",
                      "type": "number"
                    },
                    {
                      "description": "Velocity limit below which the damping is not applied.",
                      "name": "threshold",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "- Returns the callbacks assigned to the World.\n- The callbacks are described in more detail on `World:setCallbacks`.",
              "key": "World:getCallbacks",
              "module": "lovr.physics",
              "name": "getCallbacks",
              "related": ["World:setCallbacks", "World"],
              "summary": "Get the World\u0027s collision callbacks.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The World collision callbacks.",
                      "name": "callbacks",
                      "table": [
                        {
                          "description": "The function used to filter collisions.",
                          "name": "filter",
                          "type": "function"
                        },
                        {
                          "description": "The function called when 2 colliders start touching.",
                          "name": "enter",
                          "type": "function"
                        },
                        {
                          "description": "The function called when 2 colliders stop touching.",
                          "name": "exit",
                          "type": "function"
                        },
                        {
                          "description": "The function called every frame while 2 colliders are in contact.",
                          "name": "contact",
                          "type": "function"
                        }
                      ],
                      "type": "table"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the number of colliders in the world.  This includes sleeping and disabled colliders.",
              "key": "World:getColliderCount",
              "module": "lovr.physics",
              "name": "getColliderCount",
              "notes": "The world has a maximum number of colliders, configured when creating the world.  The default is 8192.  Trying to create more than this will error.",
              "related": ["World:getColliders", "World:getJointCount", "World"],
              "summary": "Get the number of colliders in the world.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The number of colliders in the World.",
                      "name": "count",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns a list of colliders in the world.  This includes sleeping and disabled colliders.",
              "key": "World:getColliders",
              "module": "lovr.physics",
              "name": "getColliders",
              "related": ["World:getColliderCount", "World:getJoints", "World"],
              "summary": "Get a list of colliders in the World.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The list of `Collider` objects in the World.",
                      "name": "colliders",
                      "type": "table"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the World\u0027s gravity.  Gravity is a constant acceleration applied to all colliders.  The default is `(0, -9.81, 0)` meters per second squared, causing colliders to fall downward.\n\nUse `Collider:setGravityScale` to change gravity strength for a single collider.",
              "key": "World:getGravity",
              "module": "lovr.physics",
              "name": "getGravity",
              "notes": "Kinematic colliders ignore gravity, since they are not moved by forces.  Colliders with higher mass do not fall faster.",
              "related": [
                "Collider:getGravityScale",
                "Collider:setGravityScale",
                "Collider:getLinearDamping",
                "Collider:setLinearDamping",
                "World:setGravity",
                "World"
              ],
              "summary": "Get the gravity of the World.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The x component of the gravity force, in meters per second squared.",
                      "name": "gx",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the gravity force, in meters per second squared.",
                      "name": "gy",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the gravity force, in meters per second squared.",
                      "name": "gz",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the number of joints in the world.  This includes disabled joints.",
              "key": "World:getJointCount",
              "module": "lovr.physics",
              "name": "getJointCount",
              "related": ["World:getJoints", "World:getColliderCount", "World"],
              "summary": "Get the number of joints in the world.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The number of joints in the World.",
                      "name": "count",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns a table with all the joints in the World.  This includes disabled joints.",
              "key": "World:getJoints",
              "module": "lovr.physics",
              "name": "getJoints",
              "related": ["World:getJointCount", "World:getColliders", "World"],
              "summary": "Get a list of joints in the World.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The list of `Joint` objects in the World.",
                      "name": "joints",
                      "type": "table"
                    }
                  ]
                }
              ]
            },
            {
              "deprecated": true,
              "description": "Returns the linear damping parameters of the World.  Linear damping is similar to drag or air resistance, slowing down colliders over time as they move.",
              "key": "World:getLinearDamping",
              "module": "lovr.physics",
              "name": "getLinearDamping",
              "notes": "A linear damping of 0 means colliders won\u0027t slow down over time.  This is the default.\n\nThis sets the default damping for newly-created colliders.  Damping can also be set on a per-collider basis using `Collider:setLinearDamping`.",
              "related": [
                "Collider:getLinearDamping",
                "Collider:setLinearDamping",
                "World:setLinearDamping",
                "World"
              ],
              "summary": "Get the linear damping of the World.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The linear damping.",
                      "name": "damping",
                      "type": "number"
                    },
                    {
                      "description": "Velocity limit below which the damping is not applied.",
                      "name": "threshold",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "deprecated": true,
              "description": "Returns the response time factor of the World.\n\nThe response time controls how relaxed collisions and joints are in the physics simulation, and functions similar to inertia.  A low response time means collisions are resolved quickly, and higher values make objects more spongy and soft.\n\nThe value can be any positive number.  It can be changed on a per-joint basis for `DistanceJoint` and `BallJoint` objects.",
              "key": "World:getResponseTime",
              "module": "lovr.physics",
              "name": "getResponseTime",
              "related": ["World:setResponseTime", "World"],
              "summary": "Get the response time of the World.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The response time setting for the World.",
                      "name": "responseTime",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "deprecated": true,
              "description": "Returns the step count of the World.  The step count influences how many steps are taken during a call to `World:update`.  A higher number of steps will be slower, but more accurate.  The default step count is 20.",
              "key": "World:getStepCount",
              "module": "lovr.physics",
              "name": "getStepCount",
              "related": ["World:update", "World:setStepCount", "World"],
              "summary": "Get the step count of the World.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The step count.",
                      "name": "steps",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns the list of collision tags that were specified when the World was created.  Tags are assigned to colliders using `Collider:setTag`, and collision can be enabled\/disabled for pairs of tags with `World:enableCollisionBetween` and `World:disableCollisionBetween`.",
              "key": "World:getTags",
              "module": "lovr.physics",
              "name": "getTags",
              "related": [
                "lovr.physics.newWorld",
                "Collider:getTag",
                "Collider:setTag",
                "World:enableCollisionBetween",
                "World:disableCollisionBetween",
                "World:isCollisionEnabledBetween",
                "World"
              ],
              "summary": "Get the World\u0027s list of collision tags.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "A table of collision tags (strings).",
                      "name": "tags",
                      "type": "table"
                    }
                  ]
                }
              ]
            },
            {
              "deprecated": true,
              "description": "Returns the tightness of joints in the World.\n\nThe tightness controls how much force is applied to colliders connected by joints.  With a value of 0, no force will be applied and joints won\u0027t have any effect.  With a tightness of 1, a strong force will be used to try to keep the Colliders constrained.  A tightness larger than 1 will overcorrect the joints, which can sometimes be desirable.  Negative tightness values are not supported.",
              "key": "World:getTightness",
              "module": "lovr.physics",
              "name": "getTightness",
              "related": ["World:setTightness", "World"],
              "summary": "Get the tightness of joints in the World.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The tightness of the World.",
                      "name": "tightness",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Interpolates collider poses between their previous pose and their current pose.  Methods like `Collider:getPosition` and `Collider:getOrientation` will return the smoothed values.\n\nAfter `World:update` is called, any interpolation is reset and `World:interpolate` will need to be called again to recompute the interpolated poses.\n\nThis can be used to decouple the physics tick rate from the rendering rate.  For example, the physics simulation can be run at a fixed rate of 30Hz, and collider poses can be interpolated before rendering.  This leads to a more stable simulation, and allows the physics rate to be increased or decreased as desired, independent of the current display refresh rate.",
              "examples": [
                {
                  "code": "function lovr.load()\n  world \u003d lovr.physics.newWorld()\n  time \u003d 0\n  timestep \u003d 1 \/ 30 -- 30Hz\nend\n\nfunction lovr.update(dt)\n  time \u003d time + dt\n\n  -- Update as many times as needed, if any\n  while time \u003e\u003d timestep do\n    world:update(timestep)\n    time \u003d time - timestep\n\n    -- Potentially do per-tick gameplay logic here\n    -- like check for collisions or apply impulses\n  end\n\n  -- Interpolate the colliders\n  local alpha \u003d time \/ timestep\n  world:interpolate(alpha)\nend\n\nfunction lovr.draw(pass)\n  -- Draw colliders as usual, using `Collider:getPose` etc.\nend",
                  "description": "An example of a fixed timestep physics update."
                }
              ],
              "key": "World:interpolate",
              "module": "lovr.physics",
              "name": "interpolate",
              "related": ["World"],
              "summary": "Interpolate collider poses.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The interpolation parameter.  An alpha of zero will use the previous collider pose, an alpha of 1.0 will use the latest collider pose, etc.  Can be less than zero or greater than one.",
                      "name": "alpha",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Returns whether collisions are enabled between a pair of tags.",
              "key": "World:isCollisionEnabledBetween",
              "module": "lovr.physics",
              "name": "isCollisionEnabledBetween",
              "notes": "If either tag is nil, this function returns true, for convenience.  For example, the following function will still work if either of the colliders don\u0027t have a tag:\n\n    function willCollide(c1, c2)\n      return world:isCollisionEnabledBetween(c1:getTag(), c2:getTag())\n    end\n\nBy default, collision is enabled between all tags.\n\nTags can be marked as \"static\" when the world is created, as an optimization hint.  Static tags will never collide with other static tags, regardless of whether collision is enabled between them.",
              "related": [
                "World:disableCollisionBetween",
                "World:enableCollisionBetween",
                "lovr.physics.newWorld",
                "World:getTags",
                "Collider:setTag",
                "World"
              ],
              "summary": "Check if two tags can collide.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The first tag.",
                      "name": "tag1",
                      "type": "string"
                    },
                    {
                      "description": "The second tag.",
                      "name": "tag2",
                      "type": "string"
                    }
                  ],
                  "returns": [
                    {
                      "description": "Whether or not two colliders with the specified tags will collide.",
                      "name": "enabled",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns whether the World has been destroyed.  Destroyed worlds can not be used for anything.",
              "key": "World:isDestroyed",
              "module": "lovr.physics",
              "name": "isDestroyed",
              "related": [
                "World:destroy",
                "Collider:isDestroyed",
                "Shape:isDestroyed",
                "Joint:isDestroyed",
                "World"
              ],
              "summary": "Check if the World has been destroyed.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "Whether the World has been destroyed.",
                      "name": "destroyed",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            },
            {
              "deprecated": true,
              "description": "Returns whether colliders can go to sleep in the World.",
              "key": "World:isSleepingAllowed",
              "module": "lovr.physics",
              "name": "isSleepingAllowed",
              "notes": "If sleeping is enabled, the World will try to detect colliders that haven\u0027t moved for a while and put them to sleep.  Sleeping colliders don\u0027t impact the physics simulation, which makes updates more efficient and improves physics performance.  However, the physics engine isn\u0027t perfect at waking up sleeping colliders and this can lead to bugs where colliders don\u0027t react to forces or collisions properly.\n\nThis can be set on individual colliders.\n\nColliders can be manually put to sleep or woken up using `Collider:setAwake`.",
              "related": [
                "Collider:isSleepingAllowed",
                "Collider:setSleepingAllowed",
                "Collider:isAwake",
                "Collider:setAwake",
                "World:setSleepingAllowed",
                "World"
              ],
              "summary": "Check if colliders can go to sleep.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "Whether colliders can sleep.",
                      "name": "allowed",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Adds a Collider to the world and attaches a `BoxShape`.",
              "key": "World:newBoxCollider",
              "module": "lovr.physics",
              "name": "newBoxCollider",
              "notes": "This will throw an error if there are too many colliders in the world.  The limit defaults to 16384 and can be changed in `lovr.physics.newWorld`.",
              "related": [
                "BoxShape",
                "Collider",
                "World:newCollider",
                "World:newSphereCollider",
                "World:newCapsuleCollider",
                "World:newCylinderCollider",
                "World:newConvexCollider",
                "World:newMeshCollider",
                "World:newTerrainCollider",
                "World"
              ],
              "summary": "Add a Collider with a BoxShape to the World.",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "0",
                      "description": "The x coordinate of the center of the box, in meters.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The y coordinate of the center of the box, in meters.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z coordinate of the center of the box, in meters.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The width of the box, in meters.",
                      "name": "width",
                      "type": "number"
                    },
                    {
                      "default": "width",
                      "description": "The height of the box, in meters.",
                      "name": "height",
                      "type": "number"
                    },
                    {
                      "default": "width",
                      "description": "The depth of the box, in meters.",
                      "name": "depth",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The new Collider.",
                      "name": "collider",
                      "type": "Collider"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The position of the center of the box, in meters.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "description": "The size of the box, in meters.",
                      "name": "size",
                      "type": "Vec3"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The new Collider.",
                      "name": "collider",
                      "type": "Collider"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Adds a Collider to the world and attaches a `CapsuleShape`.",
              "key": "World:newCapsuleCollider",
              "module": "lovr.physics",
              "name": "newCapsuleCollider",
              "notes": "This will throw an error if there are too many colliders in the world.  The limit defaults to 16384 and can be changed in `lovr.physics.newWorld`.\n\nThe length of the capsule goes along its local Z axis.",
              "related": [
                "CapsuleShape",
                "Collider",
                "World:newCollider",
                "World:newBoxCollider",
                "World:newSphereCollider",
                "World:newCylinderCollider",
                "World:newConvexCollider",
                "World:newMeshCollider",
                "World:newTerrainCollider",
                "World"
              ],
              "summary": "Add a Collider with a CapsuleShape to the World.",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "0",
                      "description": "The x coordinate of the center of the capsule, in meters.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The y coordinate of the center of the capsule, in meters.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z coordinate of the center of the capsule, in meters.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The radius of the capsule, in meters.",
                      "name": "radius",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The length of the capsule, not including the caps, in meters.",
                      "name": "length",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The new Collider.",
                      "name": "collider",
                      "type": "Collider"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The position of the center of the capsule, in meters.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "default": "1",
                      "description": "The radius of the capsule, in meters.",
                      "name": "radius",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The length of the capsule, not including the caps, in meters.",
                      "name": "length",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The new Collider.",
                      "name": "collider",
                      "type": "Collider"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Adds a new Collider to the World, without attaching any Shapes to it.  Use `Collider:addShape` to add shapes.",
              "examples": [
                {
                  "code": "function lovr.load()\n  world \u003d lovr.physics.newWorld()\n  collider \u003d world:newCollider(0, 0, 0)\n  shape \u003d lovr.physics.newSphereShape(.5)\n  collider:addShape(shape)\nend"
                }
              ],
              "key": "World:newCollider",
              "module": "lovr.physics",
              "name": "newCollider",
              "notes": "This will throw an error if there are too many colliders in the world.  The limit defaults to 16384 and can be changed in `lovr.physics.newWorld`.",
              "related": [
                "World:newBoxCollider",
                "World:newSphereCollider",
                "World:newCapsuleCollider",
                "World:newCylinderCollider",
                "World:newConvexCollider",
                "World:newMeshCollider",
                "World:newTerrainCollider",
                "Collider:addShape",
                "Collider",
                "Shape",
                "World"
              ],
              "summary": "Add a Collider to the World.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The x position of the Collider.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y position of the Collider.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z position of the Collider.",
                      "name": "z",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The new Collider.",
                      "name": "collider",
                      "type": "Collider"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The position of the Collider.",
                      "name": "position",
                      "type": "Vec3"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The new Collider.",
                      "name": "collider",
                      "type": "Collider"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Adds a Collider to the world and attaches a `ConvexShape`.  A `ConvexShape` is a convex hull of a set of points, kinda like if you wrapped them in wrapping paper.",
              "key": "World:newConvexCollider",
              "module": "lovr.physics",
              "name": "newConvexCollider",
              "notes": "This will throw an error if there are too many colliders in the world.  The limit defaults to 16384 and can be changed in `lovr.physics.newWorld`.",
              "related": [
                "ConvexShape",
                "Collider",
                "World:newCollider",
                "World:newBoxCollider",
                "World:newSphereCollider",
                "World:newCapsuleCollider",
                "World:newCylinderCollider",
                "World:newMeshCollider",
                "World:newTerrainCollider",
                "World"
              ],
              "summary": "Add a Collider with a ConvexShape to the World.",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "0",
                      "description": "The x coordinate of the collider, in meters.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The y coordinate of the collider, in meters.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z coordinate of the collider, in meters.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "A list of vertices to compute a convex hull from.  Can be a table of tables (each with 3 numbers) or a table of numbers (every 3 numbers form a 3D point).",
                      "name": "points",
                      "type": "table"
                    },
                    {
                      "default": "1.0",
                      "description": "A scale to apply to the points.",
                      "name": "scale",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The new Collider.",
                      "name": "collider",
                      "type": "Collider"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The position of the center of the capsule, in meters.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "description": "A list of vertices to compute a convex hull from.  Can be a table of tables (each with 3 numbers) or a table of numbers (every 3 numbers form a 3D point).",
                      "name": "points",
                      "type": "table"
                    },
                    {
                      "default": "1.0",
                      "description": "A scale to apply to the points.",
                      "name": "scale",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The new Collider.",
                      "name": "collider",
                      "type": "Collider"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "default": "0",
                      "description": "The x coordinate of the collider, in meters.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The y coordinate of the collider, in meters.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z coordinate of the collider, in meters.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The ModelData to compute a convex hull from.",
                      "name": "modelData",
                      "type": "ModelData"
                    },
                    {
                      "default": "1.0",
                      "description": "A scale to apply to the points.",
                      "name": "scale",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The new Collider.",
                      "name": "collider",
                      "type": "Collider"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The position of the center of the capsule, in meters.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "description": "The ModelData to compute a convex hull from.",
                      "name": "modelData",
                      "type": "ModelData"
                    },
                    {
                      "default": "1.0",
                      "description": "A scale to apply to the points.",
                      "name": "scale",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The new Collider.",
                      "name": "collider",
                      "type": "Collider"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "default": "0",
                      "description": "The x coordinate of the collider, in meters.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The y coordinate of the collider, in meters.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z coordinate of the collider, in meters.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The Model to compute a convex hull from.",
                      "name": "model",
                      "type": "Model"
                    },
                    {
                      "default": "1.0",
                      "description": "A scale to apply to the points.",
                      "name": "scale",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The new Collider.",
                      "name": "collider",
                      "type": "Collider"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The position of the center of the capsule, in meters.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "description": "The Model to compute a convex hull from.",
                      "name": "model",
                      "type": "Model"
                    },
                    {
                      "default": "1.0",
                      "description": "A scale to apply to the points.",
                      "name": "scale",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The new Collider.",
                      "name": "collider",
                      "type": "Collider"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "default": "0",
                      "description": "The x coordinate of the collider, in meters.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The y coordinate of the collider, in meters.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z coordinate of the collider, in meters.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The Mesh to compute a convex hull from.  It must use the `cpu` storage mode.",
                      "name": "mesh",
                      "type": "Mesh"
                    },
                    {
                      "default": "1.0",
                      "description": "A scale to apply to the points.",
                      "name": "scale",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The new Collider.",
                      "name": "collider",
                      "type": "Collider"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The position of the center of the capsule, in meters.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "description": "The Mesh to compute a convex hull from.  It must use the `cpu` storage mode.",
                      "name": "mesh",
                      "type": "Mesh"
                    },
                    {
                      "default": "1.0",
                      "description": "A scale to apply to the points.",
                      "name": "scale",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The new Collider.",
                      "name": "collider",
                      "type": "Collider"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "default": "0",
                      "description": "The x coordinate of the collider, in meters.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The y coordinate of the collider, in meters.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z coordinate of the collider, in meters.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "An existing ConvexShape to clone.",
                      "name": "template",
                      "type": "ConvexShape"
                    },
                    {
                      "default": "1.0",
                      "description": "A scale to apply to the points.",
                      "name": "scale",
                      "type": "number"
                    }
                  ],
                  "description": "Clones an existing ConvexShape, which is faster than passing the same points multiple times. Clones can have their own scale.  The clone\u0027s scale doesn\u0027t get multiplied with the scale of the template.",
                  "returns": [
                    {
                      "description": "The new Collider.",
                      "name": "collider",
                      "type": "Collider"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The position of the center of the capsule, in meters.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "description": "An existing ConvexShape to clone.",
                      "name": "template",
                      "type": "ConvexShape"
                    },
                    {
                      "default": "1.0",
                      "description": "A scale to apply to the points.",
                      "name": "scale",
                      "type": "number"
                    }
                  ],
                  "description": "Clones an existing ConvexShape, which is faster than passing the same points multiple times. Clones can have their own scale.  The clone\u0027s scale doesn\u0027t get multiplied with the scale of the template.",
                  "returns": [
                    {
                      "description": "The new Collider.",
                      "name": "collider",
                      "type": "Collider"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Adds a Collider to the world and attaches a `CylinderShape`.",
              "key": "World:newCylinderCollider",
              "module": "lovr.physics",
              "name": "newCylinderCollider",
              "notes": "This will throw an error if there are too many colliders in the world.  The limit defaults to 16384 and can be changed in `lovr.physics.newWorld`.\n\nThe length of the cylinder goes along its local Z axis.",
              "related": [
                "CylinderShape",
                "Collider",
                "World:newCollider",
                "World:newBoxCollider",
                "World:newSphereCollider",
                "World:newCapsuleCollider",
                "World:newConvexCollider",
                "World:newMeshCollider",
                "World:newTerrainCollider",
                "World"
              ],
              "summary": "Add a Collider with a CylinderShape to the World.",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "0",
                      "description": "The x coordinate of the center of the cylinder, in meters.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The y coordinate of the center of the cylinder, in meters.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z coordinate of the center of the cylinder, in meters.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The radius of the cylinder, in meters.",
                      "name": "radius",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The length of the cylinder, in meters.",
                      "name": "length",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The new Collider.",
                      "name": "collider",
                      "type": "Collider"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The position of the center of the cylinder, in meters.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "default": "1",
                      "description": "The radius of the cylinder, in meters.",
                      "name": "radius",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The length of the cylinder, in meters.",
                      "name": "length",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The new Collider.",
                      "name": "collider",
                      "type": "Collider"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Adds a Collider to the world and attaches a `MeshShape`.\n\nColliders with mesh shapes are immobile and can only be used for static environment objects. The collider will be kinematic and forces\/velocities will not move it.  Also, these colliders will not detect collisions with other kinematic objects.\n\nMeshShapes are not treated as solid objects, but instead a collection of triangles.  They do not have mass or volume, and there is no concept of being \"inside\" a mesh.  `ConvexShape` is a good alternative for making solid objects.",
              "key": "World:newMeshCollider",
              "module": "lovr.physics",
              "name": "newMeshCollider",
              "notes": "The triangles in a MeshShape should use counterclockwise winding.",
              "related": [
                "Collider",
                "MeshShape",
                "World:newCollider",
                "World:newBoxCollider",
                "World:newSphereCollider",
                "World:newCapsuleCollider",
                "World:newCylinderCollider",
                "World:newConvexCollider",
                "World:newTerrainCollider",
                "Model:getTriangles",
                "World"
              ],
              "summary": "Add a Collider with a MeshShape to the World.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "A table of vertices in the mesh.  Can be a table of tables (each with 3 numbers) or a table of numbers (every 3 numbers form a 3D vertex).",
                      "name": "vertices",
                      "type": "table"
                    },
                    {
                      "description": "A table of triangle indices representing how the vertices are connected together into triangles.",
                      "name": "indices",
                      "type": "table"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The new Collider.",
                      "name": "collider",
                      "type": "Collider"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A ModelData to use for the mesh data.",
                      "name": "modelData",
                      "type": "ModelData"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The new Collider.",
                      "name": "collider",
                      "type": "Collider"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A Model to use for the mesh data.  Similar to calling `Model:getTriangles` and passing it to this function, but has better performance.",
                      "name": "model",
                      "type": "Model"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The new Collider.",
                      "name": "collider",
                      "type": "Collider"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "A Mesh to use for the mesh data.  It must use the `cpu` storage mode.",
                      "name": "mesh",
                      "type": "Mesh"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The new Collider.",
                      "name": "collider",
                      "type": "Collider"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "An existing MeshShape to reuse.",
                      "name": "template",
                      "type": "MeshShape"
                    }
                  ],
                  "description": "Clones an existing MeshShape, which is faster than passing the same mesh multiple times. Clones can have their own scale.  The clone\u0027s scale doesn\u0027t get multiplied with the scale of the template.",
                  "returns": [
                    {
                      "description": "The new Collider.",
                      "name": "collider",
                      "type": "Collider"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Adds a Collider to the world and attaches a `SphereShape`.",
              "key": "World:newSphereCollider",
              "module": "lovr.physics",
              "name": "newSphereCollider",
              "notes": "This will throw an error if there are too many colliders in the world.  The limit defaults to 16384 and can be changed in `lovr.physics.newWorld`.",
              "related": [
                "SphereShape",
                "Collider",
                "World:newCollider",
                "World:newBoxCollider",
                "World:newCapsuleCollider",
                "World:newCylinderCollider",
                "World:newConvexCollider",
                "World:newMeshCollider",
                "World:newTerrainCollider",
                "World"
              ],
              "summary": "Add a Collider with a SphereShape to the World.",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "0",
                      "description": "The x coordinate of the center of the sphere, in meters.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The y coordinate of the center of the sphere, in meters.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The z coordinate of the center of the sphere, in meters.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "default": "1",
                      "description": "The radius of the sphere, in meters.",
                      "name": "radius",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The new Collider.",
                      "name": "collider",
                      "type": "Collider"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The position of the center of the sphere, in meters.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "default": "1",
                      "description": "The radius of the sphere, in meters.",
                      "name": "radius",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The new Collider.",
                      "name": "collider",
                      "type": "Collider"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Adds a Collider to the world and attaches a `TerrainShape`.\n\nColliders with terrain shapes are immobile and can only be used for static environment objects. The collider will be kinematic and forces\/velocities will not move it.  Also, these colliders will not detect collisions with other kinematic objects.\n\nTerrainShapes are not treated as solid objects, but instead a collection of triangles.  They do not have mass or volume, and there is no concept of being \"inside\" the terrain.",
              "key": "World:newTerrainCollider",
              "module": "lovr.physics",
              "name": "newTerrainCollider",
              "related": [
                "Collider",
                "TerrainShape",
                "World:newCollider",
                "World:newBoxCollider",
                "World:newCapsuleCollider",
                "World:newCylinderCollider",
                "World:newSphereCollider",
                "World:newMeshCollider",
                "lovr.data.newImage",
                "World"
              ],
              "summary": "Add a Collider with a TerrainShape to the World.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The width and depth of the terrain, in meters.",
                      "name": "scale",
                      "type": "number"
                    }
                  ],
                  "description": "Create a flat floor collider.",
                  "returns": [
                    {
                      "description": "The new Collider.",
                      "name": "collider",
                      "type": "Collider"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The width and depth of the terrain, in meters.",
                      "name": "scale",
                      "type": "number"
                    },
                    {
                      "description": "A heightmap image describing the terrain elevation at different points.  The red channel brightness of each pixel determines the elevation at corresponding coordinates.  The image must be square and must have one of the formats supported by `Image:getPixel`.",
                      "name": "heightmap",
                      "type": "Image"
                    },
                    {
                      "default": "1.0",
                      "description": "A vertical multiplier for height values to obtain terrain height.  When the image format has pixel values only in the 0 to 1 range, this can be used to scale the height to meters.",
                      "name": "stretch",
                      "type": "number"
                    }
                  ],
                  "description": "Create terrain from a heightmap image.",
                  "returns": [
                    {
                      "description": "The new Collider.",
                      "name": "collider",
                      "type": "Collider"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The width and depth of the terrain, in meters.",
                      "name": "scale",
                      "type": "number"
                    },
                    {
                      "arguments": [
                        { "name": "x", "type": "number" },
                        { "name": "z", "type": "number" }
                      ],
                      "description": "A function that returns terrain height from x and z coordinates.  The x and z inputs will range from `-scale \/ 2` to `scale \/ 2`.",
                      "name": "callback",
                      "returns": { "name": "height", "type": "number" },
                      "type": "function"
                    },
                    {
                      "default": "100",
                      "description": "The number of samples taken across the x and z dimensions.  More samples will result in higher terrain fidelity, but use more CPU and memory.",
                      "name": "samples",
                      "type": "number"
                    }
                  ],
                  "description": "Create terrain defined with a callback function.",
                  "returns": [
                    {
                      "description": "The new Collider.",
                      "name": "collider",
                      "type": "Collider"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Places a shape in the World, returning any shapes it intersects.\n\nA tag filter can be given to filter out shapes by their collider\u0027s tag:\n\n- Use nil to skip filtering.\n- Pass a tag name to only return shapes whose collider has that tag.\n- Pass a tag name with a ~ in front of it to exclude colliders with that tag.\n- Pass multiple tags separated by spaces to include multiple tags (works with ~ too).\n\nProvide an optional callback to call for each shape detected.  If the callbacks nil, this function returns the first shape detected.  In either case this function returns the shape, the hit position, and a penetration vector.  The penetration vector represents the direction and distance the shape would need to move so that it is no longer colliding with the input shape.",
              "key": "World:overlapShape",
              "module": "lovr.physics",
              "name": "overlapShape",
              "related": [
                "World:shapecast",
                "World:raycast",
                "World:queryBox",
                "World:querySphere",
                "World"
              ],
              "summary": "Find colliders that overlap a shape.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The Shape to test.",
                      "name": "shape",
                      "type": "Shape"
                    },
                    {
                      "description": "The x position to place the shape at, in meters.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y position to place the shape at, in meters.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z position to place the shape at, in meters.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The angle the shape is rotated around its rotation axis, in radians.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The maximum distance at which a shape can be detected, in meters.  Zero will detect shapes touching the input shape, 1.0 will detect shapes within 1 meter of the input shape, etc.",
                      "name": "maxDistance",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "Tags to filter by, or nil for no filter.",
                      "name": "filter",
                      "type": "string"
                    },
                    {
                      "description": "The callback to call for each intersection detected.",
                      "name": "callback",
                      "type": "function"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The Shape to test.",
                      "name": "shape",
                      "type": "Shape"
                    },
                    {
                      "description": "The position to place the shape at, in meters.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "description": "The orientation of the shape.",
                      "name": "orientation",
                      "type": "Quat"
                    },
                    {
                      "default": "0",
                      "description": "The maximum distance at which a shape can be detected, in meters.  Zero will detect shapes touching the input shape, 1.0 will detect shapes within 1 meter of the input shape, etc.",
                      "name": "maxDistance",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "Tags to filter by, or nil for no filter.",
                      "name": "filter",
                      "type": "string"
                    },
                    {
                      "description": "The callback to call for each intersection detected.",
                      "name": "callback",
                      "type": "function"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The Shape to test.",
                      "name": "shape",
                      "type": "Shape"
                    },
                    {
                      "description": "The x position to place the shape at, in meters.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y position to place the shape at, in meters.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z position to place the shape at, in meters.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The angle the shape is rotated around its rotation axis, in radians.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the axis of rotation.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the axis of rotation.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the axis of rotation.",
                      "name": "az",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "The maximum distance at which a shape can be detected, in meters.  Zero will detect shapes touching the input shape, 1.0 will detect shapes within 1 meter of the input shape, etc.",
                      "name": "maxDistance",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "Tags to filter by, or nil for no filter.",
                      "name": "filter",
                      "type": "string"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The collider that was hit.",
                      "name": "collider",
                      "type": "Collider"
                    },
                    {
                      "description": "The shape that was hit.",
                      "name": "shape",
                      "type": "Shape"
                    },
                    {
                      "description": "The x position of a world space contact point on the surface of the shape.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y position of a world space contact point on the surface of the shape.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z position of a world space contact point on the surface of the shape.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the penetration vector.",
                      "name": "nx",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the penetration vector.",
                      "name": "ny",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the penetration vector.",
                      "name": "nz",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The Shape to test.",
                      "name": "shape",
                      "type": "Shape"
                    },
                    {
                      "description": "The position to place the shape at, in meters.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "description": "The orientation of the shape.",
                      "name": "orientation",
                      "type": "Quat"
                    },
                    {
                      "default": "0",
                      "description": "The maximum distance at which a shape can be detected, in meters.  Zero will detect shapes touching the input shape, 1.0 will detect shapes within 1 meter of the input shape, etc.",
                      "name": "maxDistance",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "Tags to filter by, or nil for no filter.",
                      "name": "filter",
                      "type": "string"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The collider that was hit.",
                      "name": "collider",
                      "type": "Collider"
                    },
                    {
                      "description": "The shape that was hit.",
                      "name": "shape",
                      "type": "Shape"
                    },
                    {
                      "description": "The x position of a world space contact point on the surface of the shape.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y position of a world space contact point on the surface of the shape.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z position of a world space contact point on the surface of the shape.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the penetration vector.",
                      "name": "nx",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the penetration vector.",
                      "name": "ny",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the penetration vector.",
                      "name": "nz",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Find colliders within an axis-aligned bounding box.  This is a fast but imprecise query that only checks a rough box around colliders.  Use `World:overlapShape` for an exact collision test.\n\nRough queries like this are useful for doing a quick check before doing lots of more expensive collision testing.\n\nPass a callback function to call for each collider detected, or leave the callback off and this function will return the first collider found.",
              "key": "World:queryBox",
              "module": "lovr.physics",
              "name": "queryBox",
              "notes": "This will return sleeping colliders and sensors, but it will ignore disabled colliders.",
              "related": [
                "World:querySphere",
                "World:overlapShape",
                "World:shapecast",
                "World:raycast",
                "World"
              ],
              "summary": "Find colliders that intersect an axis-aligned box.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The x coordinate of the center of the box, in meters.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate of the center of the box, in meters.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z coordinate of the center of the box, in meters.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The width of the box, in meters",
                      "name": "width",
                      "type": "number"
                    },
                    {
                      "description": "The height of the box, in meters",
                      "name": "height",
                      "type": "number"
                    },
                    {
                      "description": "The depth of the box, in meters.",
                      "name": "depth",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "An optional tag filter.  Pass one or more tags separated by spaces to only return colliders with those tags.  Or, put `~` in front of the tags to exclude colliders with those tags.",
                      "name": "filter",
                      "type": "string"
                    },
                    {
                      "description": "A function to call when a collider is detected.  The function will be called with a single `Collider` argument.",
                      "name": "callback",
                      "type": "function"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The position of the center of the box, in meters.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "description": "The size of the box, in meters.",
                      "name": "size",
                      "type": "Vec3"
                    },
                    {
                      "default": "nil",
                      "description": "An optional tag filter.  Pass one or more tags separated by spaces to only return colliders with those tags.  Or, put `~` in front of the tags to exclude colliders with those tags.",
                      "name": "filter",
                      "type": "string"
                    },
                    {
                      "description": "A function to call when a collider is detected.  The function will be called with a single `Collider` argument.",
                      "name": "callback",
                      "type": "function"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The x coordinate of the center of the box, in meters.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate of the center of the box, in meters.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z coordinate of the center of the box, in meters.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The width of the box, in meters",
                      "name": "width",
                      "type": "number"
                    },
                    {
                      "description": "The height of the box, in meters",
                      "name": "height",
                      "type": "number"
                    },
                    {
                      "description": "The depth of the box, in meters.",
                      "name": "depth",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "An optional tag filter.  Pass one or more tags separated by spaces to only return colliders with those tags.  Or, put `~` in front of the tags to exclude colliders with those tags.",
                      "name": "filter",
                      "type": "string"
                    }
                  ],
                  "returns": [
                    {
                      "description": "A Collider that intersected the box.",
                      "name": "collider",
                      "type": "Collider"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The position of the center of the box, in meters.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "description": "The size of the box, in meters.",
                      "name": "size",
                      "type": "Vec3"
                    },
                    {
                      "default": "nil",
                      "description": "An optional tag filter.  Pass one or more tags separated by spaces to only return colliders with those tags.  Or, put `~` in front of the tags to exclude colliders with those tags.",
                      "name": "filter",
                      "type": "string"
                    }
                  ],
                  "returns": [
                    {
                      "description": "A Collider that intersected the box.",
                      "name": "collider",
                      "type": "Collider"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Find colliders within a sphere.  This is a fast but imprecise query that only checks a rough box around colliders.  Use `World:overlapShape` for an exact collision test.\n\nRough queries like this are useful for doing a quick check before doing lots of more expensive collision testing.\n\nPass a callback function to call for each collider detected, or leave the callback off and this function will return the first collider found.",
              "key": "World:querySphere",
              "module": "lovr.physics",
              "name": "querySphere",
              "related": [
                "World:queryBox",
                "World:overlapShape",
                "World:shapecast",
                "World:raycast",
                "World"
              ],
              "summary": "Find colliders that intersect a sphere.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The x coordinate of the center of the sphere.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate of the center of the sphere.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z coordinate of the center of the sphere.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The radius of the sphere, in meters",
                      "name": "radius",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "An optional tag filter.  Pass one or more tags separated by spaces to only return colliders with those tags.  Or, put `~` in front of the tags to exclude colliders with those tags.",
                      "name": "filter",
                      "type": "string"
                    },
                    {
                      "description": "A function to call when an intersection is detected.  The function will be called with a single `Collider` argument.",
                      "name": "callback",
                      "type": "function"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The position of the center of the sphere.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "description": "The radius of the sphere, in meters",
                      "name": "radius",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "An optional tag filter.  Pass one or more tags separated by spaces to only return colliders with those tags.  Or, put `~` in front of the tags to exclude colliders with those tags.",
                      "name": "filter",
                      "type": "string"
                    },
                    {
                      "description": "A function to call when an intersection is detected.  The function will be called with a single `Collider` argument.",
                      "name": "callback",
                      "type": "function"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The x coordinate of the center of the sphere.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate of the center of the sphere.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z coordinate of the center of the sphere.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The radius of the sphere, in meters",
                      "name": "radius",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "An optional tag filter.  Pass one or more tags separated by spaces to only return colliders with those tags.  Or, put `~` in front of the tags to exclude colliders with those tags.",
                      "name": "filter",
                      "type": "string"
                    }
                  ],
                  "returns": [
                    {
                      "description": "A Collider that intersected the sphere.",
                      "name": "collider",
                      "type": "Collider"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The position of the center of the sphere.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "description": "The radius of the sphere, in meters",
                      "name": "radius",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "An optional tag filter.  Pass one or more tags separated by spaces to only return colliders with those tags.  Or, put `~` in front of the tags to exclude colliders with those tags.",
                      "name": "filter",
                      "type": "string"
                    }
                  ],
                  "returns": [
                    {
                      "description": "A Collider that intersected the sphere.",
                      "name": "collider",
                      "type": "Collider"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Traces a ray through the world and calls a function for each collider that was hit.\n\nThe callback can be left off, in which case the closest hit will be returned.",
              "key": "World:raycast",
              "module": "lovr.physics",
              "name": "raycast",
              "notes": "The callback function is passed a collider, a shape, a world-space point, a world-space normal, a triangle index, and a fraction:\n\n    function(collider, shape, x, y, z, nx, ny, nz, tri, fraction)\n      return fraction\n    end\n\nThe callback can return a fraction value used to limit the range of further hits.  For example:\n\n- Returning 0.0 will abort the raycast and ignore all other hits.\n- Returning 1.0 will call the callback for all hits.\n- Returning `fraction` will return successively closer hits.\n\nRaycasts will hit sensors and sleeping colliders, but will not hit disabled colliders.",
              "related": [
                "Shape:raycast",
                "World:shapecast",
                "World:overlapShape",
                "World:queryBox",
                "World:querySphere",
                "World"
              ],
              "summary": "Find colliders that intersect a line.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The x coordinate of the origin of the ray.",
                      "name": "x1",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate of the origin of the ray.",
                      "name": "y1",
                      "type": "number"
                    },
                    {
                      "description": "The z coordinate of the origin of the ray.",
                      "name": "z1",
                      "type": "number"
                    },
                    {
                      "description": "The x coordinate of the endpoint of the ray.",
                      "name": "x2",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate of the endpoint of the ray.",
                      "name": "y2",
                      "type": "number"
                    },
                    {
                      "description": "The z coordinate of the endpoint of the ray.",
                      "name": "z2",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "An optional tag filter.  Pass one or more tags separated by spaces to only return colliders with those tags.  Or, put `~` in front the tags to exclude colliders with those tags.",
                      "name": "filter",
                      "type": "string"
                    },
                    {
                      "arguments": [
                        { "name": "collider", "type": "Collider" },
                        { "name": "shape", "type": "Shape" },
                        { "name": "x", "type": "number" },
                        { "name": "y", "type": "number" },
                        { "name": "z", "type": "number" },
                        { "name": "nx", "type": "number" },
                        { "name": "ny", "type": "number" },
                        { "name": "nz", "type": "number" },
                        { "name": "triangle", "type": "number" },
                        { "name": "fraction", "type": "number" }
                      ],
                      "description": "The function to call when an intersection is detected (see notes).",
                      "name": "callback",
                      "returns": [
                        { "default": "1.0", "name": "limit", "type": "number" }
                      ],
                      "type": "function"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The origin of the ray.",
                      "name": "origin",
                      "type": "Vec3"
                    },
                    {
                      "description": "The endpoint of the ray.",
                      "name": "endpoint",
                      "type": "Vec3"
                    },
                    {
                      "default": "nil",
                      "description": "An optional tag filter.  Pass one or more tags separated by spaces to only return colliders with those tags.  Or, put `~` in front the tags to exclude colliders with those tags.",
                      "name": "filter",
                      "type": "string"
                    },
                    {
                      "arguments": [
                        { "name": "collider", "type": "Collider" },
                        { "name": "shape", "type": "Shape" },
                        { "name": "x", "type": "number" },
                        { "name": "y", "type": "number" },
                        { "name": "z", "type": "number" },
                        { "name": "nx", "type": "number" },
                        { "name": "ny", "type": "number" },
                        { "name": "nz", "type": "number" },
                        { "name": "triangle", "type": "number" },
                        { "name": "fraction", "type": "number" }
                      ],
                      "description": "The function to call when an intersection is detected (see notes).",
                      "name": "callback",
                      "returns": [
                        { "default": "1.0", "name": "limit", "type": "number" }
                      ],
                      "type": "function"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The x coordinate of the origin of the ray.",
                      "name": "x1",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate of the origin of the ray.",
                      "name": "y1",
                      "type": "number"
                    },
                    {
                      "description": "The z coordinate of the origin of the ray.",
                      "name": "z1",
                      "type": "number"
                    },
                    {
                      "description": "The x coordinate of the endpoint of the ray.",
                      "name": "x2",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate of the endpoint of the ray.",
                      "name": "y2",
                      "type": "number"
                    },
                    {
                      "description": "The z coordinate of the endpoint of the ray.",
                      "name": "z2",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "An optional tag filter.  Pass one or more tags separated by spaces to only return colliders with those tags.  Or, put `~` in front the tags to exclude colliders with those tags.",
                      "name": "filter",
                      "type": "string"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The Collider that was hit.",
                      "name": "collider",
                      "type": "Collider"
                    },
                    {
                      "description": "The Shape that was hit.",
                      "name": "shape",
                      "type": "Shape"
                    },
                    {
                      "description": "The x coordinate of the impact point, in world space.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate of the impact point, in world space.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z coordinate of the impact point, in world space.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the normal vector.",
                      "name": "nx",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the normal vector.",
                      "name": "ny",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the normal vector.",
                      "name": "nz",
                      "type": "number"
                    },
                    {
                      "description": "The index of the triangle that was hit, or nil if a MeshShape was not hit.",
                      "name": "triangle",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The origin of the ray.",
                      "name": "origin",
                      "type": "Vec3"
                    },
                    {
                      "description": "The endpoint of the ray.",
                      "name": "endpoint",
                      "type": "Vec3"
                    },
                    {
                      "default": "nil",
                      "description": "An optional tag filter.  Pass one or more tags separated by spaces to only return colliders with those tags.  Or, put `~` in front the tags to exclude colliders with those tags.",
                      "name": "filter",
                      "type": "string"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The Collider that was hit.",
                      "name": "collider",
                      "type": "Collider"
                    },
                    {
                      "description": "The Shape that was hit.",
                      "name": "shape",
                      "type": "Shape"
                    },
                    {
                      "description": "The x coordinate of the impact point, in world space.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate of the impact point, in world space.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z coordinate of the impact point, in world space.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the normal vector.",
                      "name": "nx",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the normal vector.",
                      "name": "ny",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the normal vector.",
                      "name": "nz",
                      "type": "number"
                    },
                    {
                      "description": "The index of the triangle that was hit, or nil if a MeshShape was not hit.",
                      "name": "triangle",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "deprecated": true,
              "description": "Sets the angular damping of the World.  Angular damping makes things less \"spinny\", making them slow down their angular velocity over time. Damping is only applied when angular velocity is over the threshold value.",
              "key": "World:setAngularDamping",
              "module": "lovr.physics",
              "name": "setAngularDamping",
              "notes": "This sets the default damping for newly-created colliders.  Damping can also be set on a per-collider basis using `Collider:setAngularDamping`.",
              "related": [
                "Collider:getAngularDamping",
                "Collider:setAngularDamping",
                "World:getAngularDamping",
                "World"
              ],
              "summary": "Set the angular damping of the World.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The angular damping.",
                      "name": "damping",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "Velocity limit below which the damping is not applied.",
                      "name": "threshold",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Assigns collision callbacks to the world.  These callbacks are used to filter collisions or get notifications when colliders start or stop touching.  Callbacks are called during `World:update`.\n\n### Filter\n\nFilters collisions.  Receives two colliders and returns a boolean indicating if they should collide.  Note that it is much faster to use tags and `World:enableCollisionBetween` to control collision.  This should only be used when the logic for filtering the collision is highly dynamic.\n\n### Enter\n\nCalled when two colliders begin touching.  Receives two colliders and a `Contact` object with more information about the collision.  The `contact` callback will also be called for this collision.\n\n### Exit\n\nCalled when two colliders stop touching.  Receives two colliders.\n\n### Contact\n\nCalled continuously while two colliders are touching.  Receives two colliders and a `Contact` object with more information about the collision.  The contact can also be disabled to disable the collision response, and its friction\/resitution\/velocity can be changed.  There can be multiple active contact areas (called \"manifolds\") between a pair of colliders; this callback will be called for each one.",
              "examples": [
                {
                  "code": "world:setCallbacks({\n  filter \u003d function(a, b)\n    return true\n  end,\n  enter \u003d function(a, b, contact)\n    -- play sounds, spawn particles, etc.\n    -- the collision has not been resolved yet, so the velocity of a and b\n    -- is the velocity before the collision, and can be used to estimate the\n    -- collision force\n  end,\n  exit \u003d function(a, b)\n    -- a and b have stopped touching!\n  end,\n  contact \u003d function(a, b, contact)\n    -- a and b are touching this frame\n    -- use sparingly, as this may be called many times per frame\n    -- use Contact:setFriction and Contact:setResitution to update\n    -- the contact behavior, or Contact:setSurfaceVelocity, for a\n    -- conveyor belt effect, or Contact:setEnabled to disable the\n    -- collision completely.\n  end\n})"
                }
              ],
              "key": "World:setCallbacks",
              "module": "lovr.physics",
              "name": "setCallbacks",
              "notes": "The `Thread` that last set these callbacks must also be the thread to call `World:update`.\n\nNote that when a collider goes to sleep, its active contacts will be removed and the `exit` callback will be called.",
              "related": [
                "World:update",
                "Contact",
                "World:getCallbacks",
                "World"
              ],
              "summary": "Set the World\u0027s collision callbacks.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The World collision callbacks.",
                      "name": "callbacks",
                      "table": [
                        {
                          "description": "The function to use to filter collisions.",
                          "name": "filter",
                          "type": "function"
                        },
                        {
                          "description": "The function to call when 2 colliders start touching.",
                          "name": "enter",
                          "type": "function"
                        },
                        {
                          "description": "The function to call when 2 colliders stop touching.",
                          "name": "exit",
                          "type": "function"
                        },
                        {
                          "description": "The function to call every frame while 2 colliders are in contact.",
                          "name": "contact",
                          "type": "function"
                        }
                      ],
                      "type": "table"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Sets the World\u0027s gravity.  Gravity is a constant acceleration applied to all colliders.  The default is `(0, -9.81, 0)` meters per second squared, causing colliders to fall downward.\n\nUse `Collider:setGravityScale` to change gravity strength for a single collider.",
              "key": "World:setGravity",
              "module": "lovr.physics",
              "name": "setGravity",
              "notes": "Kinematic colliders ignore gravity, since they are not moved by forces.  Colliders with higher mass do not fall faster.",
              "related": [
                "Collider:getGravityScale",
                "Collider:setGravityScale",
                "Collider:getLinearDamping",
                "Collider:setLinearDamping",
                "World:getGravity",
                "World"
              ],
              "summary": "Set the gravity of the World.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The x component of the gravity force.",
                      "name": "xg",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the gravity force.",
                      "name": "yg",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the gravity force.",
                      "name": "zg",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The gravity force.",
                      "name": "gravity",
                      "type": "Vec3"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "deprecated": true,
              "description": "Sets the linear damping of the World.  Linear damping is similar to drag or air resistance, slowing down colliders over time as they move. Damping is only applied when linear velocity is over the threshold value.",
              "key": "World:setLinearDamping",
              "module": "lovr.physics",
              "name": "setLinearDamping",
              "notes": "A linear damping of 0 means colliders won\u0027t slow down over time.  This is the default.\n\nThis sets the default damping for newly-created colliders.  Damping can also be set on a per-collider basis using `Collider:setLinearDamping`.",
              "related": [
                "Collider:getLinearDamping",
                "Collider:setLinearDamping",
                "World:getLinearDamping",
                "World"
              ],
              "summary": "Set the linear damping of the World.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The linear damping.",
                      "name": "damping",
                      "type": "number"
                    },
                    {
                      "default": "0",
                      "description": "Velocity limit below which the damping is not applied.",
                      "name": "threshold",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "deprecated": true,
              "description": "Sets the response time factor of the World.\n\nThe response time controls how relaxed collisions and joints are in the physics simulation, and functions similar to inertia.  A low response time means collisions are resolved quickly, and higher values make objects more spongy and soft.\n\nThe value can be any positive number.  It can be changed on a per-joint basis for `DistanceJoint` and `BallJoint` objects.",
              "key": "World:setResponseTime",
              "module": "lovr.physics",
              "name": "setResponseTime",
              "related": ["World:getResponseTime", "World"],
              "summary": "Set the response time of the World.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The new response time setting for the World.",
                      "name": "responseTime",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "deprecated": true,
              "description": "Sets whether colliders can go to sleep in the World.",
              "key": "World:setSleepingAllowed",
              "module": "lovr.physics",
              "name": "setSleepingAllowed",
              "notes": "If sleeping is enabled, the World will try to detect colliders that haven\u0027t moved for a while and put them to sleep.  Sleeping colliders don\u0027t impact the physics simulation, which makes updates more efficient and improves physics performance.  However, the physics engine isn\u0027t perfect at waking up sleeping colliders and this can lead to bugs where colliders don\u0027t react to forces or collisions properly.\n\nThis can be set on individual colliders.\n\nColliders can be manually put to sleep or woken up using `Collider:setAwake`.",
              "related": [
                "Collider:isSleepingAllowed",
                "Collider:setSleepingAllowed",
                "Collider:isAwake",
                "Collider:setAwake",
                "World:isSleepingAllowed",
                "World"
              ],
              "summary": "Set whether colliders can go to sleep.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "Whether colliders can sleep.",
                      "name": "allowed",
                      "type": "boolean"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "deprecated": true,
              "description": "Sets the step count of the World.  The step count influences how many steps are taken during a call to `World:update`.  A higher number of steps will be slower, but more accurate.  The default step count is 20.",
              "key": "World:setStepCount",
              "module": "lovr.physics",
              "name": "setStepCount",
              "related": ["World:update", "World:getStepCount", "World"],
              "summary": "Set the step count of the World.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The new step count.",
                      "name": "steps",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "deprecated": true,
              "description": "Sets the tightness of joints in the World.\n\nThe tightness controls how much force is applied to colliders connected by joints.  With a value of 0, no force will be applied and joints won\u0027t have any effect.  With a tightness of 1, a strong force will be used to try to keep the Colliders constrained.  A tightness larger than 1 will overcorrect the joints, which can sometimes be desirable.  Negative tightness values are not supported.",
              "key": "World:setTightness",
              "module": "lovr.physics",
              "name": "setTightness",
              "related": ["World:getTightness", "World"],
              "summary": "Set the tightness of joints in the World.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The new tightness for the World.",
                      "name": "tightness",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Moves a shape from a starting point to an endpoint and returns any colliders it touches along its path.\n\nThis is similar to a raycast, but with a `Shape` instead of a point.",
              "key": "World:shapecast",
              "module": "lovr.physics",
              "name": "shapecast",
              "notes": "The callback function is passed a collider, a shape, a world-space point, a world-space normal, a triangle index (for mesh shapes), and a fraction:\n\n    function(collider, shape, x, y, z, nx, ny, nz, tri, fraction)\n      return fraction\n    end\n\nThe callback can return a fraction value used to limit the range of further hits.  For example:\n\n- Returning 0.0 will abort the shapecast and ignore all other hits.\n- Returning 1.0 will call the callback for all hits.\n- Returning `fraction` will return successively closer hits.\n\nShapecasts will hit sensors and sleeping colliders, but will not hit disabled colliders.",
              "related": [
                "World:raycast",
                "World:overlapShape",
                "World:queryBox",
                "World:querySphere",
                "World"
              ],
              "summary": "Move a shape through the world and return any colliders it touches.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The Shape to cast.",
                      "name": "shape",
                      "type": "Shape"
                    },
                    {
                      "description": "The x position to start at.",
                      "name": "x1",
                      "type": "number"
                    },
                    {
                      "description": "The y position to start at.",
                      "name": "y1",
                      "type": "number"
                    },
                    {
                      "description": "The z position to start at.",
                      "name": "z1",
                      "type": "number"
                    },
                    {
                      "description": "The x position to move the shape to.",
                      "name": "x2",
                      "type": "number"
                    },
                    {
                      "description": "The y position to move the shape to.",
                      "name": "y2",
                      "type": "number"
                    },
                    {
                      "description": "The z position to move the shape to.",
                      "name": "z2",
                      "type": "number"
                    },
                    {
                      "description": "The rotation of the shape around its rotation axis, in radians.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the rotation axis.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the rotation axis.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the rotation axis.",
                      "name": "az",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "An optional tag filter.  Pass one or more tags separated by spaces to only return colliders with those tags.  Or, put `~` in front the tags to exclude colliders with those tags.",
                      "name": "filter",
                      "type": "string"
                    },
                    {
                      "arguments": [
                        { "name": "collider", "type": "Collider" },
                        { "name": "shape", "type": "Shape" },
                        { "name": "x", "type": "number" },
                        { "name": "y", "type": "number" },
                        { "name": "z", "type": "number" },
                        { "name": "nx", "type": "number" },
                        { "name": "ny", "type": "number" },
                        { "name": "nz", "type": "number" },
                        { "name": "triangle", "type": "number" },
                        { "name": "fraction", "type": "number" }
                      ],
                      "description": "The function to call when an intersection is detected (see notes).",
                      "name": "callback",
                      "returns": [
                        { "default": "1.0", "name": "limit", "type": "number" }
                      ],
                      "type": "function"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The Shape to cast.",
                      "name": "shape",
                      "type": "Shape"
                    },
                    {
                      "description": "The position to start at.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "description": "The position to move the shape to.",
                      "name": "destination",
                      "type": "Vec3"
                    },
                    {
                      "description": "The orientation of the shape.",
                      "name": "orientation",
                      "type": "Quat"
                    },
                    {
                      "default": "nil",
                      "description": "An optional tag filter.  Pass one or more tags separated by spaces to only return colliders with those tags.  Or, put `~` in front the tags to exclude colliders with those tags.",
                      "name": "filter",
                      "type": "string"
                    },
                    {
                      "arguments": [
                        { "name": "collider", "type": "Collider" },
                        { "name": "shape", "type": "Shape" },
                        { "name": "x", "type": "number" },
                        { "name": "y", "type": "number" },
                        { "name": "z", "type": "number" },
                        { "name": "nx", "type": "number" },
                        { "name": "ny", "type": "number" },
                        { "name": "nz", "type": "number" },
                        { "name": "triangle", "type": "number" },
                        { "name": "fraction", "type": "number" }
                      ],
                      "description": "The function to call when an intersection is detected (see notes).",
                      "name": "callback",
                      "returns": [
                        { "default": "1.0", "name": "limit", "type": "number" }
                      ],
                      "type": "function"
                    }
                  ],
                  "returns": {}
                },
                {
                  "arguments": [
                    {
                      "description": "The Shape to cast.",
                      "name": "shape",
                      "type": "Shape"
                    },
                    {
                      "description": "The x position to start at.",
                      "name": "x1",
                      "type": "number"
                    },
                    {
                      "description": "The y position to start at.",
                      "name": "y1",
                      "type": "number"
                    },
                    {
                      "description": "The z position to start at.",
                      "name": "z1",
                      "type": "number"
                    },
                    {
                      "description": "The x position to move the shape to.",
                      "name": "x2",
                      "type": "number"
                    },
                    {
                      "description": "The y position to move the shape to.",
                      "name": "y2",
                      "type": "number"
                    },
                    {
                      "description": "The z position to move the shape to.",
                      "name": "z2",
                      "type": "number"
                    },
                    {
                      "description": "The rotation of the shape around its rotation axis, in radians.",
                      "name": "angle",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the rotation axis.",
                      "name": "ax",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the rotation axis.",
                      "name": "ay",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the rotation axis.",
                      "name": "az",
                      "type": "number"
                    },
                    {
                      "default": "nil",
                      "description": "An optional tag filter.  Pass one or more tags separated by spaces to only return colliders with those tags.  Or, put `~` in front the tags to exclude colliders with those tags.",
                      "name": "filter",
                      "type": "string"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The Collider that was hit.",
                      "name": "collider",
                      "type": "Collider"
                    },
                    {
                      "description": "The Shape that was hit.",
                      "name": "shape",
                      "type": "Shape"
                    },
                    {
                      "description": "The x coordinate of the impact point.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate of the impact point.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z coordinate of the impact point.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the normal vector.",
                      "name": "nx",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the normal vector.",
                      "name": "ny",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the normal vector.",
                      "name": "nz",
                      "type": "number"
                    },
                    {
                      "description": "The triangle that was hit, or `nil` if a MeshShape was not hit.",
                      "name": "triangle",
                      "type": "number"
                    },
                    {
                      "description": "The fraction along the ray where the impact occurred.",
                      "name": "fraction",
                      "type": "number"
                    }
                  ]
                },
                {
                  "arguments": [
                    {
                      "description": "The Shape to cast.",
                      "name": "shape",
                      "type": "Shape"
                    },
                    {
                      "description": "The position to start at.",
                      "name": "position",
                      "type": "Vec3"
                    },
                    {
                      "description": "The position to move the shape to.",
                      "name": "destination",
                      "type": "Vec3"
                    },
                    {
                      "description": "The orientation of the shape.",
                      "name": "orientation",
                      "type": "Quat"
                    },
                    {
                      "default": "nil",
                      "description": "An optional tag filter.  Pass one or more tags separated by spaces to only return colliders with those tags.  Or, put `~` in front the tags to exclude colliders with those tags.",
                      "name": "filter",
                      "type": "string"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The Collider that was hit.",
                      "name": "collider",
                      "type": "Collider"
                    },
                    {
                      "description": "The Shape that was hit.",
                      "name": "shape",
                      "type": "Shape"
                    },
                    {
                      "description": "The x coordinate of the impact point.",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "description": "The y coordinate of the impact point.",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "description": "The z coordinate of the impact point.",
                      "name": "z",
                      "type": "number"
                    },
                    {
                      "description": "The x component of the normal vector.",
                      "name": "nx",
                      "type": "number"
                    },
                    {
                      "description": "The y component of the normal vector.",
                      "name": "ny",
                      "type": "number"
                    },
                    {
                      "description": "The z component of the normal vector.",
                      "name": "nz",
                      "type": "number"
                    },
                    {
                      "description": "The triangle that was hit, or `nil` if a MeshShape was not hit.",
                      "name": "triangle",
                      "type": "number"
                    },
                    {
                      "description": "The fraction along the ray where the impact occurred.",
                      "name": "fraction",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Updates the World, advancing the physics simulation forward in time and moving all the colliders.",
              "examples": [
                { "code": "function lovr.update(dt)\n  world:update(dt)\nend" }
              ],
              "key": "World:update",
              "module": "lovr.physics",
              "name": "update",
              "notes": "This function must be called from the last thread that called `World:setCallbacks`.  If no callbacks are set, then this can be called from any thread.",
              "related": ["lovr.physics.newWorld", "World"],
              "summary": "Advance the physics simulation.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The amount of time to advance the simulation forward.",
                      "name": "dt",
                      "type": "number"
                    }
                  ],
                  "returns": {}
                }
              ]
            }
          ],
          "module": "lovr.physics",
          "name": "World",
          "related": ["lovr.physics"],
          "sections": [
            {
              "links": [
                "World:update",
                "World:interpolate",
                "World:getGravity",
                "World:setGravity",
                "World:getCallbacks",
                "World:setCallbacks",
                "World:destroy",
                "World:isDestroyed"
              ],
              "name": "Basics"
            },
            {
              "description": "Queries answer some question about the World, like \"do any colliders intersect this line?\" or \"are there any colliders inside this sphere?\".  There are 3 types of queries:\n\n- \"cast\" tests sweep a shape along a line and figure out which colliders are in its path.\n- \"overlap\" tests place a shape at a position and figure out which colliders it touches.\n- \"query\" tests are similar to overlap tests, but they are fast and inexact.  They only\n  check the bounding box of a collider, and only support testing against simple shapes.",
              "links": [
                "World:raycast",
                "World:shapecast",
                "World:overlapShape",
                "World:queryBox",
                "World:querySphere"
              ],
              "name": "Queries"
            },
            {
              "description": "Collision tags are used to ignore collision between certain pairs of colliders.  The list of available tags is defined when creating the world, and colliders can be given a tag using `Collider:setTag`.",
              "links": [
                "World:getTags",
                "World:disableCollisionBetween",
                "World:enableCollisionBetween",
                "World:isCollisionEnabledBetween"
              ],
              "name": "Collision Tags"
            },
            {
              "links": [
                "World:newCollider",
                "World:newBoxCollider",
                "World:newSphereCollider",
                "World:newCapsuleCollider",
                "World:newCylinderCollider",
                "World:newConvexCollider",
                "World:newMeshCollider",
                "World:newTerrainCollider",
                "World:getColliderCount",
                "World:getColliders"
              ],
              "name": "Colliders"
            },
            {
              "links": ["World:getJointCount", "World:getJoints"],
              "name": "Joints"
            }
          ],
          "summary": "An object holding all the colliders and joints in a physics simulation."
        }
      ],
      "sections": [
        {
          "description": "A World holds all of the objects in a physics simulation.  Use methods like `World:newBoxCollider` to add objects to the world.  Call `World:update` each frame to advance the physics simulation and calculate new positions for all the colliders.",
          "links": ["lovr.physics.newWorld"],
          "name": "World"
        },
        {
          "description": "A Collider is a single \"object\" in the physics world.  A Collider has zero or more `Shape` objects attached to it, which determine its collision shape.  Colliders can be connected together with `Joint` objects.",
          "links": [
            "World:newCollider",
            "World:newBoxCollider",
            "World:newSphereCollider",
            "World:newCapsuleCollider",
            "World:newCylinderCollider",
            "World:newConvexCollider",
            "World:newMeshCollider",
            "World:newTerrainCollider"
          ],
          "name": "Colliders"
        },
        {
          "description": "Shapes define the collision shape of a collider.  Normally it isn\u0027t necessary to create shapes manually, instead convenience methods like `World:newSphereCollider` will create a collider with a shape attached.",
          "links": [
            "lovr.physics.newBoxShape",
            "lovr.physics.newSphereShape",
            "lovr.physics.newCapsuleShape",
            "lovr.physics.newCylinderShape",
            "lovr.physics.newConvexShape",
            "lovr.physics.newMeshShape",
            "lovr.physics.newTerrainShape"
          ],
          "name": "Shapes"
        },
        {
          "description": "Joints connect colliders together and constrain their movement in various ways.",
          "links": [
            "lovr.physics.newWeldJoint",
            "lovr.physics.newBallJoint",
            "lovr.physics.newConeJoint",
            "lovr.physics.newDistanceJoint",
            "lovr.physics.newHingeJoint",
            "lovr.physics.newSliderJoint"
          ],
          "name": "Joints"
        }
      ],
      "summary": "Simulates 3D physics.",
      "tag": "modules"
    },
    {
      "description": "The `lovr.system` provides information about the current platform and hardware.\n\nIt also interfaces with the desktop window and window input.",
      "enums": [
        {
          "description": "These are the different permissions that need to be requested using `lovr.system.requestPermission` on some platforms.",
          "key": "Permission",
          "module": "lovr.system",
          "name": "Permission",
          "related": ["lovr.system.requestPermission", "lovr.system"],
          "summary": "Application permissions.",
          "values": [
            {
              "description": "Requests microphone access.",
              "name": "audiocapture"
            }
          ]
        }
      ],
      "functions": [
        {
          "description": "Returns the clipboard text.",
          "key": "lovr.system.getClipboardText",
          "module": "lovr.system",
          "name": "getClipboardText",
          "related": ["lovr.system.setClipboardText", "lovr.system"],
          "summary": "Get the clipboard text.",
          "tag": "system-clipboard",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The clipboard text (may be nil).",
                  "name": "text",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the number of logical cores on the system.",
          "key": "lovr.system.getCoreCount",
          "module": "lovr.system",
          "name": "getCoreCount",
          "related": ["lovr.thread", "lovr.system"],
          "summary": "Get the number of logical cores.",
          "tag": "system-info",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The number of logical cores on the system.",
                  "name": "cores",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the position of the mouse.",
          "key": "lovr.system.getMousePosition",
          "module": "lovr.system",
          "name": "getMousePosition",
          "related": [
            "lovr.system.getMouseX",
            "lovr.system.getMouseY",
            "lovr.mousemoved",
            "lovr.system"
          ],
          "summary": "Get the position of the mouse.",
          "tag": "system-mouse",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The x position of the mouse, relative to the top-left of the window.",
                  "name": "x",
                  "type": "number"
                },
                {
                  "description": "The y position of the mouse, relative to the top-left of the window.",
                  "name": "y",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the x position of the mouse.",
          "key": "lovr.system.getMouseX",
          "module": "lovr.system",
          "name": "getMouseX",
          "related": [
            "lovr.system.getMouseY",
            "lovr.system.getMousePosition",
            "lovr.mousemoved",
            "lovr.system"
          ],
          "summary": "Get the x position of the mouse.",
          "tag": "system-mouse",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The x position of the mouse, relative to the top-left of the window.",
                  "name": "x",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the y position of the mouse.",
          "key": "lovr.system.getMouseY",
          "module": "lovr.system",
          "name": "getMouseY",
          "related": [
            "lovr.system.getMouseX",
            "lovr.system.getMousePosition",
            "lovr.mousemoved",
            "lovr.system"
          ],
          "summary": "Get the y position of the mouse.",
          "tag": "system-mouse",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The y position of the mouse, relative to the top-left of the window.",
                  "name": "y",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the current operating system.",
          "key": "lovr.system.getOS",
          "module": "lovr.system",
          "name": "getOS",
          "related": ["lovr.system"],
          "summary": "Get the current operating system.",
          "tag": "system-info",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "Either \"Windows\", \"macOS\", \"Linux\", \"Android\" or \"Web\".",
                  "name": "os",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the window pixel density.  High DPI windows will usually return 2.0 to indicate that there are 2 pixels for every window coordinate in each axis.  On a normal display, 1.0 is returned, indicating that window coordinates match up with pixels 1:1.",
          "key": "lovr.system.getWindowDensity",
          "module": "lovr.system",
          "name": "getWindowDensity",
          "related": ["lovr.system"],
          "summary": "Get the window pixel density.",
          "tag": "system-window",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The pixel density of the window.",
                  "name": "density",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the dimensions of the desktop window.",
          "key": "lovr.system.getWindowDimensions",
          "module": "lovr.system",
          "name": "getWindowDimensions",
          "notes": "If the window is not open, this will return zeros.",
          "related": [
            "lovr.system.getWindowWidth",
            "lovr.system.getWindowHeight",
            "lovr.system.isWindowOpen",
            "lovr.system"
          ],
          "summary": "Get the dimensions of the window.",
          "tag": "system-window",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The width of the desktop window.",
                  "name": "width",
                  "type": "number"
                },
                {
                  "description": "The height of the desktop window.",
                  "name": "height",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the height of the desktop window.",
          "key": "lovr.system.getWindowHeight",
          "module": "lovr.system",
          "name": "getWindowHeight",
          "notes": "If the window is not open, this will return zero.",
          "related": [
            "lovr.system.getWindowWidth",
            "lovr.system.getWindowDimensions",
            "lovr.system.isWindowOpen",
            "lovr.system"
          ],
          "summary": "Get the height of the window.",
          "tag": "system-window",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The height of the desktop window.",
                  "name": "width",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the width of the desktop window.",
          "key": "lovr.system.getWindowWidth",
          "module": "lovr.system",
          "name": "getWindowWidth",
          "notes": "If the window is not open, this will return zero.",
          "related": [
            "lovr.system.getWindowHeight",
            "lovr.system.getWindowDimensions",
            "lovr.system.isWindowOpen",
            "lovr.system"
          ],
          "summary": "Get the width of the window.",
          "tag": "system-window",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The width of the desktop window.",
                  "name": "width",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns whether key repeat is enabled.",
          "key": "lovr.system.hasKeyRepeat",
          "module": "lovr.system",
          "name": "hasKeyRepeat",
          "notes": "Key repeat is disabled by default.",
          "related": ["lovr.keypressed", "lovr.system"],
          "summary": "Check if key repeat is enabled.",
          "tag": "system-keyboard",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "Whether key repeat is enabled.",
                  "name": "enabled",
                  "type": "boolean"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns whether a key on the keyboard is pressed.",
          "key": "lovr.system.isKeyDown",
          "module": "lovr.system",
          "name": "isKeyDown",
          "related": [
            "lovr.system.wasKeyPressed",
            "lovr.system.wasKeyReleased",
            "lovr.keypressed",
            "lovr.keyreleased",
            "lovr.system"
          ],
          "summary": "Get the state of a key.",
          "tag": "system-keyboard",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The set of keys to check.",
                  "name": "...",
                  "type": "KeyCode"
                }
              ],
              "returns": [
                {
                  "description": "Whether any of the keys are currently pressed.",
                  "name": "down",
                  "type": "boolean"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns whether a mouse button is currently pressed.",
          "key": "lovr.system.isMouseDown",
          "module": "lovr.system",
          "name": "isMouseDown",
          "related": [
            "lovr.mousepressed",
            "lovr.mousereleased",
            "lovr.system.getMouseX",
            "lovr.system.getMouseY",
            "lovr.system.getMousePosition",
            "lovr.system"
          ],
          "summary": "Check if a mouse button is pressed.",
          "tag": "system-mouse",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The index of a button to check.  Use 1 for the primary mouse button, 2 for the secondary button, and 3 for the middle button.  Other indices can be used, but are hardware-specific.",
                  "name": "button",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "Whether the mouse button is currently down.",
                  "name": "down",
                  "type": "boolean"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns whether the desktop window is focused.",
          "key": "lovr.system.isWindowFocused",
          "module": "lovr.system",
          "name": "isWindowFocused",
          "related": [
            "lovr.focus",
            "lovr.headset.isFocused",
            "lovr.system.openWindow",
            "lovr.system.isWindowOpen",
            "lovr.system.isWindowVisible",
            "lovr.system"
          ],
          "summary": "Check if the desktop window is focused.",
          "tag": "system-window",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "Whether the desktop window is focused.",
                  "name": "focused",
                  "type": "boolean"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns whether the desktop window is open.  `t.window` can be set to `nil` in `lovr.conf` to disable automatic opening of the window.  In this case, the window can be opened manually using `lovr.system.openWindow`.",
          "key": "lovr.system.isWindowOpen",
          "module": "lovr.system",
          "name": "isWindowOpen",
          "related": [
            "lovr.system.openWindow",
            "lovr.system.isWindowVisible",
            "lovr.system.isWindowFocused",
            "lovr.system"
          ],
          "summary": "Check if the desktop window is open.",
          "tag": "system-window",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "Whether the desktop window is open.",
                  "name": "open",
                  "type": "boolean"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns whether the desktop window is visible (open and not minimized).",
          "key": "lovr.system.isWindowVisible",
          "module": "lovr.system",
          "name": "isWindowVisible",
          "related": [
            "lovr.visible",
            "lovr.headset.isVisible",
            "lovr.system.openWindow",
            "lovr.system.isWindowOpen",
            "lovr.system.isWindowFocused",
            "lovr.system"
          ],
          "summary": "Check if the desktop window is visible.",
          "tag": "system-window",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "Whether the desktop window is visible.",
                  "name": "visible",
                  "type": "boolean"
                }
              ]
            }
          ]
        },
        {
          "description": "Opens the desktop window.  If the window is already open, this function does nothing.",
          "key": "lovr.system.openWindow",
          "module": "lovr.system",
          "name": "openWindow",
          "notes": "By default, the window is opened automatically, but this can be disabled by setting `t.window` to `nil` in `conf.lua`.",
          "related": ["lovr.system.isWindowOpen", "lovr.conf", "lovr.system"],
          "summary": "Open the desktop window.",
          "tag": "system-window",
          "variants": [
            {
              "arguments": [
                {
                  "description": "Window options.",
                  "name": "options",
                  "table": [
                    {
                      "default": "720",
                      "description": "The width of the window, or 0 to use the width of the monitor.",
                      "name": "width",
                      "type": "number"
                    },
                    {
                      "default": "800",
                      "description": "The height of the window, or 0 to use the height of the monitor.",
                      "name": "height",
                      "type": "number"
                    },
                    {
                      "description": "Whether the window should be fullscreen.",
                      "name": "fullscreen",
                      "type": "boolean"
                    },
                    {
                      "description": "Whether the window should be resizable.",
                      "name": "resizable",
                      "type": "boolean"
                    },
                    {
                      "description": "The window title.",
                      "name": "title",
                      "type": "string"
                    },
                    {
                      "description": "An `Image` or path to an image file to use for the window icon.",
                      "name": "icon",
                      "type": "string"
                    }
                  ],
                  "type": "table"
                }
              ],
              "returns": {}
            }
          ]
        },
        {
          "description": "Fills the event queue with unprocessed events from the operating system.  This function should be called often, otherwise the operating system will consider the application unresponsive. This function is called in the default implementation of `lovr.run`.",
          "key": "lovr.system.pollEvents",
          "module": "lovr.system",
          "name": "pollEvents",
          "related": ["lovr.event.poll", "lovr.system"],
          "summary": "Poll the OS for new window events.",
          "tag": "system-window",
          "variants": [{ "arguments": {}, "returns": {} }]
        },
        {
          "description": "Requests permission to use a feature.  Usually this will pop up a dialog box that the user needs to confirm.  Once the permission request has been acknowledged, the `lovr.permission` callback will be called with the result.  Currently, this is only used for requesting microphone access on Android devices.",
          "key": "lovr.system.requestPermission",
          "module": "lovr.system",
          "name": "requestPermission",
          "related": ["lovr.permission", "lovr.system"],
          "summary": "Request permission to use a feature.",
          "tag": "system-info",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The permission to request.",
                  "name": "permission",
                  "type": "Permission"
                }
              ],
              "returns": {}
            }
          ]
        },
        {
          "description": "Sets the clipboard text.",
          "key": "lovr.system.setClipboardText",
          "module": "lovr.system",
          "name": "setClipboardText",
          "related": ["lovr.system.getClipboardText", "lovr.system"],
          "summary": "Set the clipboard text.",
          "tag": "system-clipboard",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The string to set as the clipboard text.",
                  "name": "text",
                  "type": "string"
                }
              ],
              "returns": {}
            }
          ]
        },
        {
          "description": "Enables or disables key repeat.  Key repeat affects whether `lovr.keypressed` will be fired multiple times while a key is held down.  The `repeat` parameter of the callback can be used to detect whether a key press comes from a \"repeat\" or not.",
          "key": "lovr.system.setKeyRepeat",
          "module": "lovr.system",
          "name": "setKeyRepeat",
          "notes": "Key repeat is disabled by default.  `lovr.textinput` is not affected by key repeat.",
          "related": ["lovr.keypressed", "lovr.system"],
          "summary": "Enable or disable key repeat.",
          "tag": "system-keyboard",
          "variants": [
            {
              "arguments": [
                {
                  "description": "Whether key repeat should be enabled.",
                  "name": "enable",
                  "type": "boolean"
                }
              ],
              "returns": {}
            }
          ]
        },
        {
          "description": "Returns whether a key on the keyboard was pressed this frame.",
          "key": "lovr.system.wasKeyPressed",
          "module": "lovr.system",
          "name": "wasKeyPressed",
          "notes": "Technically this returns whether the key was pressed between the last 2 calls to `lovr.system.pollEvents`, but that function is called automatically at the beginning of each frame in `lovr.run`, so it all works out!",
          "related": [
            "lovr.system.isKeyDown",
            "lovr.system.wasKeyReleased",
            "lovr.keypressed",
            "lovr.keyreleased",
            "lovr.system"
          ],
          "summary": "Check if a key was pressed this frame.",
          "tag": "system-keyboard",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The set of keys to check.",
                  "name": "...",
                  "type": "KeyCode"
                }
              ],
              "returns": [
                {
                  "description": "Whether any of the specified keys were pressed this frame.",
                  "name": "pressed",
                  "type": "boolean"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns whether a key on the keyboard was released this frame.",
          "key": "lovr.system.wasKeyReleased",
          "module": "lovr.system",
          "name": "wasKeyReleased",
          "notes": "Technically this returns whether the key was released between the last 2 calls to `lovr.system.pollEvents`, but that function is called automatically at the beginning of each frame in `lovr.run`, so it all works out!",
          "related": [
            "lovr.system.isKeyDown",
            "lovr.system.wasKeyPressed",
            "lovr.keypressed",
            "lovr.keyreleased",
            "lovr.system"
          ],
          "summary": "Check if a key was released this frame.",
          "tag": "system-keyboard",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The set of keys to check.",
                  "name": "...",
                  "type": "KeyCode"
                }
              ],
              "returns": [
                {
                  "description": "Whether any of the specified keys were released this frame.",
                  "name": "released",
                  "type": "boolean"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns whether a button on the mouse was pressed this frame.",
          "key": "lovr.system.wasMousePressed",
          "module": "lovr.system",
          "name": "wasMousePressed",
          "notes": "Technically this returns whether the button was pressed between the last 2 calls to `lovr.system.pollEvents`, but that function is called automatically at the beginning of each frame in `lovr.run`, so it all works out!",
          "related": [
            "lovr.system.isMouseDown",
            "lovr.system.wasMouseReleased",
            "lovr.mousepressed",
            "lovr.mousereleased",
            "lovr.system"
          ],
          "summary": "Check if a mouse button was pressed this frame.",
          "tag": "system-mouse",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The index of a button to check.  Use 1 for the primary mouse button, 2 for the secondary button, and 3 for the middle button.  Other indices can be used, but are hardware-specific.",
                  "name": "button",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "Whether the mouse button was pressed this frame.",
                  "name": "pressed",
                  "type": "boolean"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns whether a button on the mouse was released this frame.",
          "key": "lovr.system.wasMouseReleased",
          "module": "lovr.system",
          "name": "wasMouseReleased",
          "notes": "Technically this returns whether the button was released between the last 2 calls to `lovr.system.pollEvents`, but that function is called automatically at the beginning of each frame in `lovr.run`, so it all works out!",
          "related": [
            "lovr.system.isMouseDown",
            "lovr.system.wasMousePressed",
            "lovr.mousepressed",
            "lovr.mousereleased",
            "lovr.system"
          ],
          "summary": "Check if a mouse button was released this frame.",
          "tag": "system-mouse",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The index of a button to check.  Use 1 for the primary mouse button, 2 for the secondary button, and 3 for the middle button.  Other indices can be used, but are hardware-specific.",
                  "name": "button",
                  "type": "number"
                }
              ],
              "returns": [
                {
                  "description": "Whether the mouse button was released this frame.",
                  "name": "released",
                  "type": "boolean"
                }
              ]
            }
          ]
        }
      ],
      "key": "lovr.system",
      "name": "system",
      "objects": {},
      "sections": [
        { "name": "System Information", "tag": "system-info" },
        { "name": "Keyboard", "tag": "system-keyboard" },
        { "name": "Mouse", "tag": "system-mouse" },
        { "name": "Clipboard", "tag": "system-clipboard" },
        { "name": "Window", "tag": "system-window" }
      ],
      "summary": "Provides information about the current operating system and platform.",
      "tag": "modules"
    },
    {
      "description": "The `lovr.thread` module provides functions for creating threads and communicating between them.\n\nThese are operating system level threads, which are different from Lua coroutines.\n\nThreads are useful for performing expensive background computation without affecting the framerate or performance of the main thread.  Some examples of this include asset loading, networking and network requests, and physics simulation.\n\nThreads come with some caveats:\n\n- Threads run in a bare Lua environment.  The `lovr` module (and any of lovr\u0027s modules) need to\n  be required before they can be used.\n  - To get `require` to work properly, add `require \u0027lovr.filesystem\u0027` to the thread code.\n- Threads are completely isolated from other threads.  They do not have access to the variables\n  or functions of other threads, and communication between threads must be coordinated through\n  `Channel` objects.\n- The graphics module (or any functions that perform rendering) cannot be used in a thread.\n  Note that this includes creating graphics objects like Models and Textures.  There are \"data\"\n  equivalent `ModelData` and `Image` objects that can be used in threads though.\n- `lovr.system.pollEvents` cannot be called from a thread.\n- Crashes or problems can happen if two threads access the same object at the same time, so\n  special care must be taken to coordinate access to objects from multiple threads.",
      "enums": {},
      "functions": [
        {
          "description": "Returns a named Channel for communicating between threads.",
          "key": "lovr.thread.getChannel",
          "module": "lovr.thread",
          "name": "getChannel",
          "related": ["Channel", "lovr.thread.newChannel", "lovr.thread"],
          "summary": "Get a Channel for communicating between threads.",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The name of the Channel to get.",
                  "name": "name",
                  "type": "string"
                }
              ],
              "returns": [
                {
                  "description": "The Channel with the specified name.",
                  "name": "channel",
                  "type": "Channel"
                }
              ]
            }
          ]
        },
        {
          "description": "Creates a new unnamed `Channel` object.  Usually it\u0027s more convenient to use `lovr.thread.getChannel`, since other threads can use that function to query the channel by name.  Unnamed channels don\u0027t require a unique name, but they need to be sent to other threads somehow (e.g. on a different Channel or as an argument to `Thread:start`).",
          "key": "lovr.thread.newChannel",
          "module": "lovr.thread",
          "name": "newChannel",
          "related": ["lovr.thread.getChannel", "lovr.thread"],
          "summary": "Create a new, unnamed Channel.",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The new Channel.",
                  "name": "channel",
                  "type": "Channel"
                }
              ]
            }
          ]
        },
        {
          "description": "Creates a new Thread from Lua code.",
          "key": "lovr.thread.newThread",
          "module": "lovr.thread",
          "name": "newThread",
          "notes": "The Thread won\\\u0027t start running immediately.  Use `Thread:start` to start it.\n\nThe string argument is assumed to be a filename if there isn\u0027t a newline in the first 1024 characters.  For really short thread code, an extra newline can be added to trick L\u00d6VR into loading it properly.",
          "related": ["Thread:start", "lovr.threaderror", "lovr.thread"],
          "summary": "Create a new Thread.",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The code to run in the Thread.",
                  "name": "code",
                  "type": "string"
                }
              ],
              "returns": [
                {
                  "description": "The new Thread.",
                  "name": "thread",
                  "type": "Thread"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "A file containing code to run in the Thread.",
                  "name": "filename",
                  "type": "string"
                }
              ],
              "returns": [
                {
                  "description": "The new Thread.",
                  "name": "thread",
                  "type": "Thread"
                }
              ]
            },
            {
              "arguments": [
                {
                  "description": "The code to run in the Thread.",
                  "name": "blob",
                  "type": "Blob"
                }
              ],
              "returns": [
                {
                  "description": "The new Thread.",
                  "name": "thread",
                  "type": "Thread"
                }
              ]
            }
          ]
        }
      ],
      "key": "lovr.thread",
      "name": "thread",
      "objects": [
        {
          "constructors": ["lovr.thread.newChannel", "lovr.thread.getChannel"],
          "description": "A Channel is an object used to communicate between `Thread` objects.  Different threads can send messages on the same Channel to communicate with each other.  Messages can be sent and received on a Channel using `Channel:push` and `Channel:pop`, and are received in a first-in-first-out fashion. The following types of data can be passed through Channels: nil, boolean, number, string, lightuserdata, table, vector, and any L\u00d6VR object.",
          "key": "Channel",
          "methods": [
            {
              "description": "Removes all pending messages from the Channel.",
              "key": "Channel:clear",
              "module": "lovr.thread",
              "name": "clear",
              "related": ["Channel"],
              "summary": "Clear all messages from the Channel.",
              "variants": [{ "arguments": {}, "returns": {} }]
            },
            {
              "description": "Returns the number of messages in the Channel.",
              "key": "Channel:getCount",
              "module": "lovr.thread",
              "name": "getCount",
              "related": ["Channel"],
              "summary": "Get the number of messages in the Channel.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The number of messages in the Channel.",
                      "name": "count",
                      "type": "number"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns whether or not the message with the given ID has been read.  Every call to `Channel:push` returns a message ID.",
              "key": "Channel:hasRead",
              "module": "lovr.thread",
              "name": "hasRead",
              "related": ["Channel:push", "Channel"],
              "summary": "Get whether a message has been read.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The ID of the message to check.",
                      "name": "id",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "Whether the message has been read.",
                      "name": "read",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns a message from the Channel without popping it from the queue.  If the Channel is empty, `nil` is returned.  This can be useful to determine if the Channel is empty.",
              "key": "Channel:peek",
              "module": "lovr.thread",
              "name": "peek",
              "notes": "The second return value can be used to detect if a `nil` message is in the queue.",
              "related": ["Channel:pop", "Channel"],
              "summary": "Look at a message from the Channel without popping it.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The message, or `nil` if there is no message.",
                      "name": "message",
                      "type": "*"
                    },
                    {
                      "description": "Whether a message was returned (use to detect nil).",
                      "name": "present",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Pops a message from the Channel.  If the Channel is empty, an optional timeout argument can be used to wait for a message, otherwise `nil` is returned.",
              "key": "Channel:pop",
              "module": "lovr.thread",
              "name": "pop",
              "notes": "Threads can get stuck forever waiting on Channel messages, so be careful.",
              "related": ["Channel:peek", "Channel:push", "Channel"],
              "summary": "Pop a message from the Channel.",
              "variants": [
                {
                  "arguments": [
                    {
                      "default": "false",
                      "description": "How long to wait for a message to be popped, in seconds.  `true` can be used to wait forever and `false` can be used to avoid waiting.",
                      "name": "wait",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The received message, or `nil` if nothing was received.",
                      "name": "message",
                      "type": "*"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Pushes a message onto the Channel.  The following types of data can be pushed: nil, boolean, number, string, table, lightuserdata, vectors, and userdata (L\u00d6VR objects).",
              "key": "Channel:push",
              "module": "lovr.thread",
              "name": "push",
              "notes": "Threads can get stuck forever waiting on Channel messages, so be careful.",
              "related": ["Channel:pop", "Channel:hasRead", "Channel"],
              "summary": "Push a message onto the Channel.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "The message to push.",
                      "name": "message",
                      "type": "*"
                    },
                    {
                      "default": "false",
                      "description": "How long to wait for the message to be popped, in seconds.  `true` can be used to wait forever and `false` can be used to avoid waiting.",
                      "name": "wait",
                      "type": "number"
                    }
                  ],
                  "returns": [
                    {
                      "description": "The ID of the pushed message.",
                      "name": "id",
                      "type": "number"
                    },
                    {
                      "description": "Whether the message was read by another thread before the wait timeout.",
                      "name": "read",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            }
          ],
          "module": "lovr.thread",
          "name": "Channel",
          "related": ["lovr.thread"],
          "summary": "A message channel for communicating between threads."
        },
        {
          "constructors": ["lovr.thread.newThread"],
          "description": "A Thread is an object that runs a chunk of Lua code in the background.  Threads are completely isolated from other threads, meaning they have their own Lua context and can\u0027t access the variables and functions of other threads.  Communication between threads is limited and is accomplished by using `Channel` objects.\n\nTo get `require` to work properly, add `require \u0027lovr.filesystem\u0027` to the thread code.",
          "key": "Thread",
          "methods": [
            {
              "description": "Returns the message for the error that occurred on the Thread, or nil if no error has occurred.",
              "key": "Thread:getError",
              "module": "lovr.thread",
              "name": "getError",
              "related": ["lovr.threaderror", "Thread"],
              "summary": "Get the Thread\u0027s error message.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "The error message, or `nil` if no error has occurred on the Thread.",
                      "name": "error",
                      "type": "string"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Returns whether or not the Thread is currently running.",
              "key": "Thread:isRunning",
              "module": "lovr.thread",
              "name": "isRunning",
              "related": ["Thread:start", "Thread"],
              "summary": "Check if the Thread is running.",
              "variants": [
                {
                  "arguments": {},
                  "returns": [
                    {
                      "description": "Whether or not the Thread is running.",
                      "name": "running",
                      "type": "boolean"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Starts the Thread.",
              "examples": [
                {
                  "code": "function lovr.load()\n  lovr.thread.newThread([[\n    print(...)\n  ]]):start(lovr.getVersion())\nend"
                }
              ],
              "key": "Thread:start",
              "module": "lovr.thread",
              "name": "start",
              "notes": "The arguments can be nil, booleans, numbers, strings, or L\u00d6VR objects.",
              "related": ["Thread"],
              "summary": "Start the Thread.",
              "variants": [
                {
                  "arguments": [
                    {
                      "description": "Up to 4 arguments to pass to the Thread\u0027s function.",
                      "name": "...arguments",
                      "type": "*"
                    }
                  ],
                  "returns": {}
                }
              ]
            },
            {
              "description": "Waits for the Thread to complete, then returns.",
              "key": "Thread:wait",
              "module": "lovr.thread",
              "name": "wait",
              "related": ["Thread:isRunning", "Thread"],
              "summary": "Wait for the Thread to complete.",
              "variants": [{ "arguments": {}, "returns": {} }]
            }
          ],
          "module": "lovr.thread",
          "name": "Thread",
          "related": [
            "lovr.threaderror",
            "lovr.system.getCoreCount",
            "Channel",
            "lovr.thread"
          ],
          "summary": "A separate thread of execution that can run code in parallel with other threads."
        }
      ],
      "related": ["lovr.system.getCoreCount"],
      "summary": "Allows the creation of background threads.",
      "tag": "modules"
    },
    {
      "description": "The `lovr.timer` module provides a few functions that deal with time.  All times are measured in seconds.",
      "enums": {},
      "functions": [
        {
          "description": "Returns the average delta over the last second.",
          "key": "lovr.timer.getAverageDelta",
          "module": "lovr.timer",
          "name": "getAverageDelta",
          "related": ["lovr.timer.getDelta", "lovr.update", "lovr.timer"],
          "summary": "Get the average delta over the last second.",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The average delta, in seconds.",
                  "name": "delta",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the time between the last two frames.  This is the same value as the `dt` argument provided to `lovr.update`.",
          "key": "lovr.timer.getDelta",
          "module": "lovr.timer",
          "name": "getDelta",
          "notes": "The return value of this function will remain the same until `lovr.timer.step` is called.  This function should not be used to measure times for game behavior or benchmarking, use `lovr.timer.getTime` for that.",
          "related": ["lovr.timer.getTime", "lovr.update", "lovr.timer"],
          "summary": "Get the time elapsed since the last update.",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The delta time, in seconds.",
                  "name": "dt",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the current frames per second, averaged over the last 90 frames.",
          "key": "lovr.timer.getFPS",
          "module": "lovr.timer",
          "name": "getFPS",
          "related": ["lovr.timer"],
          "summary": "Get the current frames per second.",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The current FPS.",
                  "name": "fps",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Returns the time since some time in the past.  This can be used to measure the difference between two points in time.",
          "key": "lovr.timer.getTime",
          "module": "lovr.timer",
          "name": "getTime",
          "related": ["lovr.headset.getTime", "lovr.timer"],
          "summary": "Get the current time.",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The current time, in seconds.",
                  "name": "time",
                  "type": "number"
                }
              ]
            }
          ]
        },
        {
          "description": "Sleeps the application for a specified number of seconds.  While the game is asleep, no code will be run, no graphics will be drawn, and the window will be unresponsive.",
          "key": "lovr.timer.sleep",
          "module": "lovr.timer",
          "name": "sleep",
          "related": ["lovr.timer"],
          "summary": "Go to sleep.",
          "variants": [
            {
              "arguments": [
                {
                  "description": "The number of seconds to sleep for.",
                  "name": "duration",
                  "type": "number"
                }
              ],
              "returns": {}
            }
          ]
        },
        {
          "description": "Steps the timer, returning the new delta time.  This is called automatically in `lovr.run` and it\u0027s used to calculate the new `dt` to pass to `lovr.update`.",
          "key": "lovr.timer.step",
          "module": "lovr.timer",
          "name": "step",
          "related": ["lovr.timer"],
          "summary": "Steps the internal clock.",
          "variants": [
            {
              "arguments": {},
              "returns": [
                {
                  "description": "The amount of time since the last call to this function, in seconds.",
                  "name": "delta",
                  "type": "number"
                }
              ]
            }
          ]
        }
      ],
      "key": "lovr.timer",
      "name": "timer",
      "objects": {},
      "summary": "Exposes a high resolution timer.",
      "tag": "modules"
    },
    {
      "description": "L\u00d6VR includes Lua 5.3\u0027s `utf8` library, even on Lua versions that don\u0027t support it.  Lua\u0027s regular strings aren\u0027t utf8-aware, so this library makes it easier to work with multi-byte characters that are outside the ASCII range.\n\nSee the [Lua reference manual](https:\/\/www.lua.org\/manual\/5.3\/manual.html#6.5) for documentation.",
      "enums": {},
      "examples": [
        {
          "code": "local utf8 \u003d require \u0027utf8\u0027\n\nlocal str \u003d \u0027L\u00d6VR\u0027\n\nprint(string.len(str)) --\u003e prints 5, because \u00d6 takes up 2 bytes\nprint(utf8.len(str))   --\u003e prints 4"
        }
      ],
      "external": true,
      "functions": {},
      "key": "utf8",
      "name": "utf8",
      "objects": {},
      "summary": "UTF-8 string processing.",
      "tag": "libraries"
    }
  ]
}
